#!/usr/bin/env bash
set -eu
set -o pipefail

readonly DIR="$(cd $(dirname ${BASH_SOURCE[0]}) && pwd)"
source "$DIR/common-setup.sh"

REPO="$1"
DIFF=
DIFF_ERR=
STATUS=
STATUS_ERR=

checkRepo() {
    if [[ ! -d "$REPO" ]] ; then
        echo "Error: no such directory: $REPO"
        exit 1
    fi
}

getStatus() {
    DIFF="$(git -C "$REPO" diff HEAD)"
    DIFF_ERR=$?
    STATUS="$(git -C "$REPO" status --porcelain --ignored)"
    STATUS_ERR=$?
}

checkStatus() {
    if [[ "$DIFF_ERR" -ne 0 || "$STATUS_ERR" -ne 0 ]]; then
        >&2 echo "Error: could not determine whether $REPO contains unsaved modifications"
        exit 1
    elif [[ -n "$DIFF" || -n "$STATUS" ]] ; then
        >&2 echo "$DIFF"
        >&2 echo "$STATUS"
        >&2 echo "Error: $REPO contains unsaved modifications"
        exit 1
    fi
}

fetchAll() {
    git -C "$REPO" fetch --all
}

checkRevs() {
    local local_rev=
    local remote_rev=

    for branch in $(git -C "$REPO" for-each-ref --format='%(refname:short)' refs/heads/); do
        local_rev=$(git -C "$REPO" rev-parse "$branch")

        [[ $? -eq 0 ]] || exit 1

        for remote in $(git -C "$REPO" remote); do
            remote_rev=$(git -C "$REPO" merge-base "$local_rev" "remotes/$remote/$branch")

            if [[ $? -ne 0 ]]; then
                >&2 echo "Error: problem retrieving branch \"$remote\" from remote \"$remote\""
                exit 1
            elif [[ "$local_rev" != "$remote_rev" ]]; then
                >&2 echo "Error: branch \"$branch\" has not been pushed to remote \"$remote\""
                exit 1
            fi
        done
    done
}

removeRepo() {
    rm -rf "$REPO"
    mkdir "$REPO"
}

writeNixFiles() {
    gitThunk > "$REPO/default.nix"
    gitManifest "$REPO" > "$REPO/git.nix"
}

main() {
    checkRepo
    getStatus
    checkStatus
    fetchAll
    checkRevs

    # If we've gotten here, we're pretty sure this is safe
    removeRepo
    writeNixFiles
}

main "$@"
