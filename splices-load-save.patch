diff --git a/compiler/basicTypes/DataCon.hs b/compiler/basicTypes/DataCon.hs
index efcb26d047..3dd7e14b12 100644
--- a/compiler/basicTypes/DataCon.hs
+++ b/compiler/basicTypes/DataCon.hs
@@ -811,7 +811,6 @@ instance Binary SrcUnpackedness where
            1 -> return SrcUnpack
            _ -> return NoSrcUnpack
 
-
 -- | Compare strictness annotations
 eqHsBang :: HsImplBang -> HsImplBang -> Bool
 eqHsBang HsLazy               HsLazy              = True
diff --git a/compiler/basicTypes/IdInfo.hs b/compiler/basicTypes/IdInfo.hs
index aed09b6a42..f6febaf4dc 100644
--- a/compiler/basicTypes/IdInfo.hs
+++ b/compiler/basicTypes/IdInfo.hs
@@ -18,7 +18,7 @@ module IdInfo (
         RecSelParent(..),
 
         -- * The IdInfo type
-        IdInfo,
+        IdInfo,         -- Abstract
         vanillaIdInfo, noCafIdInfo,
 
         -- ** The OneShotInfo type
diff --git a/compiler/basicTypes/IdInfo.hs-boot b/compiler/basicTypes/IdInfo.hs-boot
index 229ff9abb0..cacfe6af2e 100644
--- a/compiler/basicTypes/IdInfo.hs-boot
+++ b/compiler/basicTypes/IdInfo.hs-boot
@@ -1,7 +1,6 @@
 module IdInfo where
 import GhcPrelude
 import Outputable
-
 data IdInfo
 data IdDetails
 
@@ -9,3 +8,4 @@ vanillaIdInfo :: IdInfo
 coVarDetails :: IdDetails
 isCoVarDetails :: IdDetails -> Bool
 pprIdDetails :: IdDetails -> SDoc
+
diff --git a/compiler/basicTypes/OccName.hs b/compiler/basicTypes/OccName.hs
index fa54967e8a..1af53fb3dc 100644
--- a/compiler/basicTypes/OccName.hs
+++ b/compiler/basicTypes/OccName.hs
@@ -394,10 +394,6 @@ instance Uniquable OccName where
 newtype OccEnv a = A (UniqFM a)
   deriving Data
 
-instance Binary a => Binary (OccEnv a) where
-  put_ bh (A a) = put_ bh a
-  get bh = A <$> get bh
-
 emptyOccEnv :: OccEnv a
 unitOccEnv  :: OccName -> a -> OccEnv a
 extendOccEnv :: OccEnv a -> OccName -> a -> OccEnv a
diff --git a/compiler/basicTypes/PatSyn.hs b/compiler/basicTypes/PatSyn.hs
index 76b93e4224..2e838d6b82 100644
--- a/compiler/basicTypes/PatSyn.hs
+++ b/compiler/basicTypes/PatSyn.hs
@@ -32,7 +32,6 @@ import Outputable
 import Unique
 import Util
 import BasicTypes
-import Binary
 import Var
 import FieldLabel
 
@@ -329,10 +328,6 @@ instance Data.Data PatSyn where
     gunfold _ _  = error "gunfold"
     dataTypeOf _ = mkNoRepType "PatSyn"
 
-instance Binary PatSyn where
-  put = error "Binary PatSyn: not implemented yet"
-  get = error "Binary PatSyn: not implemented yet"
-
 {-
 ************************************************************************
 *                                                                      *
diff --git a/compiler/basicTypes/RdrName.hs b/compiler/basicTypes/RdrName.hs
index a4f1a68e65..610233ed9a 100644
--- a/compiler/basicTypes/RdrName.hs
+++ b/compiler/basicTypes/RdrName.hs
@@ -75,7 +75,6 @@ import GhcPrelude
 import Module
 import Name
 import Avail
-import Binary
 import NameSet
 import Maybes
 import SrcLoc
@@ -467,10 +466,6 @@ data GlobalRdrElt
          -- INVARIANT: either gre_lcl = True or gre_imp is non-empty
          -- See Note [GlobalRdrElt provenance]
 
-instance Binary GlobalRdrElt where
-  put_ bh (GRE a b c d) = put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
-  get bh = GRE <$> get bh <*> get bh <*> get bh <*> get bh
-
 -- | The children of a Name are the things that are abbreviated by the ".."
 --   notation in export lists.  See Note [Parents]
 data Parent = NoParent
@@ -479,18 +474,6 @@ data Parent = NoParent
               -- ^ See Note [Parents for record fields]
             deriving (Eq, Data)
 
-instance Binary Parent where
-  put_ bh p = case p of
-    NoParent      -> putByte bh 0
-    ParentIs p    -> putByte bh 1 >> put_ bh p
-    FldParent a b -> putByte bh 2 >> put_ bh a >> put_ bh b
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> pure NoParent
-      1 -> ParentIs <$> get bh
-      _ -> FldParent <$> get bh <*> get bh
-
 instance Outputable Parent where
    ppr NoParent        = empty
    ppr (ParentIs n)    = text "parent:" <> ppr n
@@ -1151,10 +1134,6 @@ data ImportSpec = ImpSpec { is_decl :: ImpDeclSpec,
                             is_item :: ImpItemSpec }
                 deriving( Eq, Ord, Data )
 
-instance Binary ImportSpec where
-  put_ bh (ImpSpec a b) = put_ bh a >> put_ bh b
-  get bh = ImpSpec <$> get bh <*> get bh
-
 -- | Import Declaration Specification
 --
 -- Describes a particular import declaration and is
@@ -1172,11 +1151,6 @@ data ImpDeclSpec
         is_dloc     :: SrcSpan     -- ^ The location of the entire import declaration
     } deriving Data
 
-instance Binary ImpDeclSpec where
-  put_ bh (ImpDeclSpec a b c d) =
-    put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
-  get bh = ImpDeclSpec <$> get bh <*> get bh <*> get bh <*> get bh
-
 -- | Import Item Specification
 --
 -- Describes import info a particular Name
@@ -1198,16 +1172,6 @@ data ImpItemSpec
         -- only @T@ is named explicitly.
   deriving Data
 
-instance Binary ImpItemSpec where
-  put_ bh s = case s of
-    ImpAll      -> putByte bh 0
-    ImpSome a b -> putByte bh 1 >> put_ bh a >> put_ bh b
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> pure ImpAll
-      _ -> ImpSome <$> get bh <*> get bh
-
 instance Eq ImpDeclSpec where
   p1 == p2 = case p1 `compare` p2 of EQ -> True; _ -> False
 
diff --git a/compiler/ghc.cabal.in b/compiler/ghc.cabal.in
index 3521bdc06c..01628dcad1 100644
--- a/compiler/ghc.cabal.in
+++ b/compiler/ghc.cabal.in
@@ -210,7 +210,6 @@ Library
         NameSet
         OccName
         RdrName
-        SeName
         NameCache
         SrcLoc
         UniqSupply
@@ -319,11 +318,6 @@ Library
         HsDecls
         HsDoc
         HsExpr
-        HsExprBin
-        HsExprBin_ConversionPS2SE
-        HsExprBin_ConversionSE2PS
-        HsExprBin_Conversions
-        HsExprBin_Instances
         HsImpExp
         HsLit
         PlaceHolder
diff --git a/compiler/hsSyn/HsBinds.hs b/compiler/hsSyn/HsBinds.hs
index 9c3665f025..98f503b0d9 100644
--- a/compiler/hsSyn/HsBinds.hs
+++ b/compiler/hsSyn/HsBinds.hs
@@ -12,7 +12,6 @@ Datatype for: @BindGroup@, @Bind@, @Sig@, @Bind@.
 {-# LANGUAGE FlexibleContexts #-}
 {-# LANGUAGE UndecidableInstances #-} -- Note [Pass sensitive types]
                                       -- in module PlaceHolder
-{-# LANGUAGE TypeFamilies #-}
 {-# LANGUAGE ConstraintKinds #-}
 {-# LANGUAGE BangPatterns #-}
 {-# LANGUAGE TypeFamilies #-}
@@ -323,12 +322,10 @@ data NPatBindTc = NPatBindTc {
 type instance XFunBind    (GhcPass pL) GhcPs = NoExt
 type instance XFunBind    (GhcPass pL) GhcRn = NameSet -- Free variables
 type instance XFunBind    (GhcPass pL) GhcTc = NameSet -- Free variables
-type instance XFunBind    (GhcPass pL) GhcSe = NoExt
 
 type instance XPatBind    GhcPs (GhcPass pR) = NoExt
 type instance XPatBind    GhcRn (GhcPass pR) = NameSet -- Free variables
 type instance XPatBind    GhcTc (GhcPass pR) = NPatBindTc
-type instance XPatBind    GhcSe (GhcPass pR) = NoExt
 
 type instance XVarBind    (GhcPass pL) (GhcPass pR) = NoExt
 type instance XAbsBinds   (GhcPass pL) (GhcPass pR) = NoExt
@@ -385,7 +382,6 @@ data PatSynBind idL idR
 type instance XPSB         (GhcPass idL) GhcPs = NoExt
 type instance XPSB         (GhcPass idL) GhcRn = NameSet
 type instance XPSB         (GhcPass idL) GhcTc = NameSet
-type instance XPSB         (GhcPass idL) GhcSe = NoExt
 
 type instance XXPatSynBind (GhcPass idL) (GhcPass idR) = NoExt
 
@@ -832,7 +828,6 @@ type instance XIPBinds       GhcPs = NoExt
 type instance XIPBinds       GhcRn = NoExt
 type instance XIPBinds       GhcTc = TcEvBinds -- binds uses of the
                                                -- implicit parameters
-type instance XIPBinds       GhcSe = NoExt
 
 
 type instance XXHsIPBinds    (GhcPass p) = NoExt
@@ -953,7 +948,7 @@ data Sig pass
         -- the desired Id itself, replete with its name, type
         -- and IdDetails.  Otherwise it's just like a type
         -- signature: there should be an accompanying binding
-  | IdSig (XIdSig pass) (IdSigId pass)
+  | IdSig (XIdSig pass) Id
 
         -- | An ordinary fixity declaration
         --
@@ -1182,9 +1177,7 @@ ppr_sig (TypeSig _ vars ty)  = pprVarSig (map unLoc vars) (ppr ty)
 ppr_sig (ClassOpSig _ is_deflt vars ty)
   | is_deflt                 = text "default" <+> pprVarSig (map unLoc vars) (ppr ty)
   | otherwise                = pprVarSig (map unLoc vars) (ppr ty)
-ppr_sig (IdSig _ id)         = case getVarType id of
-  Nothing -> ppr id
-  Just t  -> pprVarSig [id] (ppr t)
+ppr_sig (IdSig _ id)         = pprVarSig [id] (ppr (varType id))
 ppr_sig (FixSig _ fix_sig)   = ppr fix_sig
 ppr_sig (SpecSig _ var ty inl@(InlinePragma { inl_inline = spec }))
   = pragSrcBrackets (inl_src inl) pragmaSrc (pprSpec (unLoc var)
diff --git a/compiler/hsSyn/HsDecls.hs b/compiler/hsSyn/HsDecls.hs
index db5510c706..f84fcfd5ec 100644
--- a/compiler/hsSyn/HsDecls.hs
+++ b/compiler/hsSyn/HsDecls.hs
@@ -10,7 +10,6 @@
 {-# LANGUAGE UndecidableInstances #-} -- Note [Pass sensitive types]
                                       -- in module PlaceHolder
 {-# LANGUAGE ConstraintKinds #-}
-{-# LANGUAGE FlexibleInstances #-}
 {-# LANGUAGE TypeFamilies #-}
 
 -- | Abstract syntax of global declarations.
@@ -578,17 +577,14 @@ type instance XFamDecl      (GhcPass _) = NoExt
 type instance XSynDecl      GhcPs = NoExt
 type instance XSynDecl      GhcRn = NameSet -- FVs
 type instance XSynDecl      GhcTc = NameSet -- FVs
-type instance XSynDecl      GhcSe = NoExt
 
 type instance XDataDecl     GhcPs = NoExt
 type instance XDataDecl     GhcRn = DataDeclRn
 type instance XDataDecl     GhcTc = DataDeclRn
-type instance XDataDecl     GhcSe = NoExt
 
 type instance XClassDecl    GhcPs = NoExt
 type instance XClassDecl    GhcRn = NameSet -- FVs
 type instance XClassDecl    GhcTc = NameSet -- FVs
-type instance XClassDecl    GhcSe = NoExt
 
 type instance XXTyClDecl    (GhcPass _) = NoExt
 
@@ -699,6 +695,7 @@ hsDeclHasCusk (XTyClDecl _) = panic "hsDeclHasCusk"
 -- ~~~~~~~~~~~~~~~~~~~~~~~~
 
 instance (p ~ GhcPass pass, OutputableBndrId p) => Outputable (TyClDecl p) where
+
     ppr (FamDecl { tcdFam = decl }) = ppr decl
     ppr (SynDecl { tcdLName = ltycon, tcdTyVars = tyvars, tcdFixity = fixity
                  , tcdRhs = rhs })
@@ -1871,7 +1868,6 @@ data DerivStrategy pass
 type instance XViaStrategy GhcPs = LHsSigType GhcPs
 type instance XViaStrategy GhcRn = LHsSigType GhcRn
 type instance XViaStrategy GhcTc = Type
-type instance XViaStrategy GhcSe = LHsSigType GhcSe
 
 instance (p ~ GhcPass pass, OutputableBndrId p)
         => Outputable (DerivStrategy p) where
@@ -1972,12 +1968,10 @@ data ForeignDecl pass
 type instance XForeignImport   GhcPs = NoExt
 type instance XForeignImport   GhcRn = NoExt
 type instance XForeignImport   GhcTc = Coercion
-type instance XForeignImport   GhcSe = NoExt
 
 type instance XForeignExport   GhcPs = NoExt
 type instance XForeignExport   GhcRn = NoExt
 type instance XForeignExport   GhcTc = Coercion
-type instance XForeignExport   GhcSe = NoExt
 
 type instance XXForeignDecl    (GhcPass _) = NoExt
 
@@ -2120,7 +2114,6 @@ data HsRuleRn = HsRuleRn NameSet NameSet -- Free-vars from the LHS and RHS
 type instance XHsRule       GhcPs = NoExt
 type instance XHsRule       GhcRn = HsRuleRn
 type instance XHsRule       GhcTc = HsRuleRn
-type instance XHsRule       GhcSe = NoExt
 
 type instance XXRuleDecl    (GhcPass _) = NoExt
 
diff --git a/compiler/hsSyn/HsExpr.hs b/compiler/hsSyn/HsExpr.hs
index 72042690cd..6ca37e07ce 100644
--- a/compiler/hsSyn/HsExpr.hs
+++ b/compiler/hsSyn/HsExpr.hs
@@ -10,7 +10,7 @@
                                       -- in module PlaceHolder
 {-# LANGUAGE ConstraintKinds #-}
 {-# LANGUAGE ExistentialQuantification #-}
-{-# LANGUAGE DeriveFunctor, DeriveFoldable, DeriveTraversable #-}
+{-# LANGUAGE DeriveFunctor #-}
 {-# LANGUAGE TypeFamilies #-}
 
 -- | Abstract Haskell syntax for expressions.
@@ -442,11 +442,11 @@ data HsExpr p
   --             'ApiAnnotation.AnnClose'
 
   -- For details on above see note [Api annotations] in ApiAnnotation
-  | HsDo        (XDo p)                    -- Type of the whole expression
-                (HsStmtContext (DoName p)) -- The parameterisation is unimportant
-                                           -- because in this context we never use
-                                           -- the PatGuard or ParStmt variant
-                (Located [ExprLStmt p])    -- "do":one or more stmts
+  | HsDo        (XDo p)                  -- Type of the whole expression
+                (HsStmtContext Name)     -- The parameterisation is unimportant
+                                         -- because in this context we never use
+                                         -- the PatGuard or ParStmt variant
+                (Located [ExprLStmt p]) -- "do":one or more stmts
 
   -- | Syntactic list: [a,b,c,...]
   --
@@ -476,6 +476,7 @@ data HsExpr p
   --
   --  - 'ApiAnnotation.AnnKeywordId' : 'ApiAnnotation.AnnOpen' @'{'@,
   --         'ApiAnnotation.AnnDotdot','ApiAnnotation.AnnClose' @'}'@
+
   -- For details on above see note [Api annotations] in ApiAnnotation
   | RecordUpd
       { rupd_ext  :: XRecordUpd p
@@ -718,12 +719,10 @@ type instance XApp           (GhcPass _) = NoExt
 type instance XAppTypeE      GhcPs = LHsWcType GhcPs
 type instance XAppTypeE      GhcRn = LHsWcType GhcRn
 type instance XAppTypeE      GhcTc = LHsWcType GhcRn
-type instance XAppTypeE      GhcSe = LHsWcType GhcSe
 
 type instance XOpApp         GhcPs = NoExt
 type instance XOpApp         GhcRn = Fixity
 type instance XOpApp         GhcTc = Fixity
-type instance XOpApp         GhcSe = NoExt
 
 type instance XNegApp        (GhcPass _) = NoExt
 type instance XPar           (GhcPass _) = NoExt
@@ -734,7 +733,6 @@ type instance XExplicitTuple (GhcPass _) = NoExt
 type instance XExplicitSum   GhcPs = NoExt
 type instance XExplicitSum   GhcRn = NoExt
 type instance XExplicitSum   GhcTc = [Type]
-type instance XExplicitSum   GhcSe = NoExt
 
 type instance XCase          (GhcPass _) = NoExt
 type instance XIf            (GhcPass _) = NoExt
@@ -742,39 +740,32 @@ type instance XIf            (GhcPass _) = NoExt
 type instance XMultiIf       GhcPs = NoExt
 type instance XMultiIf       GhcRn = NoExt
 type instance XMultiIf       GhcTc = Type
-type instance XMultiIf       GhcSe = NoExt
 
 type instance XLet           (GhcPass _) = NoExt
 
 type instance XDo            GhcPs = NoExt
 type instance XDo            GhcRn = NoExt
 type instance XDo            GhcTc = Type
-type instance XDo            GhcSe = NoExt
 
 type instance XExplicitList  GhcPs = NoExt
 type instance XExplicitList  GhcRn = NoExt
 type instance XExplicitList  GhcTc = Type
-type instance XExplicitList  GhcSe = NoExt
 
 type instance XRecordCon     GhcPs = NoExt
 type instance XRecordCon     GhcRn = NoExt
 type instance XRecordCon     GhcTc = RecordConTc
-type instance XRecordCon     GhcSe = NoExt
 
 type instance XRecordUpd     GhcPs = NoExt
 type instance XRecordUpd     GhcRn = NoExt
 type instance XRecordUpd     GhcTc = RecordUpdTc
-type instance XRecordUpd     GhcSe = NoExt
 
 type instance XExprWithTySig GhcPs = (LHsSigWcType GhcPs)
 type instance XExprWithTySig GhcRn = (LHsSigWcType GhcRn)
 type instance XExprWithTySig GhcTc = (LHsSigWcType GhcRn)
-type instance XExprWithTySig GhcSe = (LHsSigWcType GhcSe)
 
 type instance XArithSeq      GhcPs = NoExt
 type instance XArithSeq      GhcRn = NoExt
 type instance XArithSeq      GhcTc = PostTcExpr
-type instance XArithSeq      GhcSe = NoExt
 
 type instance XSCC           (GhcPass _) = NoExt
 type instance XCoreAnn       (GhcPass _) = NoExt
@@ -789,12 +780,10 @@ type instance XProc          (GhcPass _) = NoExt
 type instance XStatic        GhcPs = NoExt
 type instance XStatic        GhcRn = NameSet
 type instance XStatic        GhcTc = NameSet
-type instance XStatic        GhcSe = NoExt
 
 type instance XArrApp        GhcPs = NoExt
 type instance XArrApp        GhcRn = NoExt
 type instance XArrApp        GhcTc = Type
-type instance XArrApp        GhcSe = NoExt
 
 type instance XArrForm       (GhcPass _) = NoExt
 type instance XTick          (GhcPass _) = NoExt
@@ -831,7 +820,6 @@ type instance XPresent         (GhcPass _) = NoExt
 type instance XMissing         GhcPs = NoExt
 type instance XMissing         GhcRn = NoExt
 type instance XMissing         GhcTc = Type
-type instance XMissing         GhcSe = NoExt
 
 type instance XXTupArg         (GhcPass _) = NoExt
 
@@ -1405,7 +1393,6 @@ data HsCmd id
 type instance XCmdArrApp  GhcPs = NoExt
 type instance XCmdArrApp  GhcRn = NoExt
 type instance XCmdArrApp  GhcTc = Type
-type instance XCmdArrApp  GhcSe = NoExt
 
 type instance XCmdArrForm (GhcPass _) = NoExt
 type instance XCmdApp     (GhcPass _) = NoExt
@@ -1418,7 +1405,6 @@ type instance XCmdLet     (GhcPass _) = NoExt
 type instance XCmdDo      GhcPs = NoExt
 type instance XCmdDo      GhcRn = NoExt
 type instance XCmdDo      GhcTc = Type
-type instance XCmdDo      GhcSe = NoExt
 
 type instance XCmdWrap    (GhcPass _) = NoExt
 type instance XXCmd       (GhcPass _) = NoExt
@@ -1450,7 +1436,6 @@ data CmdTopTc
 type instance XCmdTop  GhcPs = NoExt
 type instance XCmdTop  GhcRn = CmdSyntaxTable GhcRn -- See Note [CmdSyntaxTable]
 type instance XCmdTop  GhcTc = CmdTopTc
-type instance XCmdTop  GhcSe = NoExt
 
 type instance XXCmdTop (GhcPass _) = NoExt
 
@@ -1601,7 +1586,6 @@ data MatchGroupTc
 type instance XMG         GhcPs b = NoExt
 type instance XMG         GhcRn b = NoExt
 type instance XMG         GhcTc b = MatchGroupTc
-type instance XMG         GhcSe b = NoExt
 
 type instance XXMatchGroup (GhcPass _) b = NoExt
 
@@ -2001,34 +1985,28 @@ type instance XLastStmt        (GhcPass _) (GhcPass _) b = NoExt
 type instance XBindStmt        (GhcPass _) GhcPs b = NoExt
 type instance XBindStmt        (GhcPass _) GhcRn b = NoExt
 type instance XBindStmt        (GhcPass _) GhcTc b = Type
-type instance XBindStmt        (GhcPass _) GhcSe b = NoExt
 
 type instance XApplicativeStmt (GhcPass _) GhcPs b = NoExt
 type instance XApplicativeStmt (GhcPass _) GhcRn b = NoExt
 type instance XApplicativeStmt (GhcPass _) GhcTc b = Type
-type instance XApplicativeStmt (GhcPass _) GhcSe b = NoExt
 
 type instance XBodyStmt        (GhcPass _) GhcPs b = NoExt
 type instance XBodyStmt        (GhcPass _) GhcRn b = NoExt
 type instance XBodyStmt        (GhcPass _) GhcTc b = Type
-type instance XBodyStmt        (GhcPass _) GhcSe b = NoExt
 
 type instance XLetStmt         (GhcPass _) (GhcPass _) b = NoExt
 
 type instance XParStmt         (GhcPass _) GhcPs b = NoExt
 type instance XParStmt         (GhcPass _) GhcRn b = NoExt
 type instance XParStmt         (GhcPass _) GhcTc b = Type
-type instance XParStmt         (GhcPass _) GhcSe b = NoExt
 
 type instance XTransStmt       (GhcPass _) GhcPs b = NoExt
 type instance XTransStmt       (GhcPass _) GhcRn b = NoExt
 type instance XTransStmt       (GhcPass _) GhcTc b = Type
-type instance XTransStmt       (GhcPass _) GhcSe b = NoExt
 
 type instance XRecStmt         (GhcPass _) GhcPs b = NoExt
 type instance XRecStmt         (GhcPass _) GhcRn b = NoExt
 type instance XRecStmt         (GhcPass _) GhcTc b = RecStmtTc
-type instance XRecStmt         (GhcPass _) GhcSe b = NoExt
 
 type instance XXStmtLR         (GhcPass _) (GhcPass _) b = NoExt
 
@@ -2727,7 +2705,7 @@ data HsMatchContext id -- Not an extensible tag
   | ThPatSplice            -- ^A Template Haskell pattern splice
   | ThPatQuote             -- ^A Template Haskell pattern quotation [p| (a,b) |]
   | PatSyn                 -- ^A pattern synonym declaration
-  deriving (Functor, Foldable, Traversable)
+  deriving Functor
 deriving instance (Data id) => Data (HsMatchContext id)
 
 instance OutputableBndr id => Outputable (HsMatchContext id) where
@@ -2744,7 +2722,6 @@ instance OutputableBndr id => Outputable (HsMatchContext id) where
   ppr ThPatQuote            = text "ThPatQuote"
   ppr PatSyn                = text "PatSyn"
 
-
 isPatSynCtxt :: HsMatchContext id -> Bool
 isPatSynCtxt ctxt =
   case ctxt of
@@ -2765,7 +2742,7 @@ data HsStmtContext id
   | PatGuard (HsMatchContext id)     -- ^Pattern guard for specified thing
   | ParStmtCtxt (HsStmtContext id)   -- ^A branch of a parallel stmt
   | TransStmtCtxt (HsStmtContext id) -- ^A branch of a transform stmt
-  deriving (Functor, Foldable, Traversable)
+  deriving Functor
 deriving instance (Data id) => Data (HsStmtContext id)
 
 isListCompExpr :: HsStmtContext id -> Bool
diff --git a/compiler/hsSyn/HsExpr.hs-boot b/compiler/hsSyn/HsExpr.hs-boot
index 4b8c15dfc8..109e9814e5 100644
--- a/compiler/hsSyn/HsExpr.hs-boot
+++ b/compiler/hsSyn/HsExpr.hs-boot
@@ -5,7 +5,7 @@
 {-# LANGUAGE ConstraintKinds #-}
 {-# LANGUAGE RoleAnnotations #-}
 {-# LANGUAGE ExistentialQuantification #-}
-{-# LANGUAGE TypeFamilies #-} -- needed to use OutputableBndrId
+{-# LANGUAGE TypeFamilies #-}
 
 module HsExpr where
 
diff --git a/compiler/hsSyn/HsExprBin.hs b/compiler/hsSyn/HsExprBin.hs
deleted file mode 100644
index 7967f934fb..0000000000
--- a/compiler/hsSyn/HsExprBin.hs
+++ /dev/null
@@ -1,149 +0,0 @@
-module HsExprBin
-  ( getModuleSplicesPath
-  , whenSet
-  , HsSpliceData(..)
-  , nonEmptyHsSpliceData
-  , emptyHsSpliceData
-  , SpliceResult(..)
-  , recordSpliceResult
-  , lookupSpliceResult
-  , exprSE2PS
-  , declSE2PS
-  , exprPS2SE
-  , declPS2SE
-  , handleUnsupported
-  ) where
-
-import Binary
-import GhcPrelude
-import HsDecls
-import HsExpr
-import HsExprBin_Conversions
-import qualified HsExprBin_ConversionSE2PS as SE2PS
-import qualified HsExprBin_ConversionPS2SE as PS2SE
-import HsExprBin_Instances ()
-import HsExtension
-import Module
-import Outputable
-import SrcLoc
-import TcRnTypes
-
-import qualified Data.Map.Strict as Map
-import System.FilePath
-
-{-
-
-Note [Serialisable AST phase]
-
-There is an AST phase called GhcSe, where 'Se' stands for Serialisable.
-It is quite close to GhcPs, in that it mostly represents ASTs the same way,
-except for (syntax-level) types and names, which are represented in a way
-that is (binary) serialisation friendly.
-
-The motivation for this new phase is to be able to serialise ASTs of Haskell
-code. (No existing phase has this property.) One use case would be to save
-ASTs resulting from the evaluation of Template Haskell code and to reuse them
-later, in place of evaluating the Template Haskell code. More generally,
-it seems useful to be able to persist or load parsed ASTs, may it be for
-IDE-style interactions or plugins.
-
-The purpose of the HsExprBin* modules is to define:
-- conversions from GhcSe to GhcPs, and back, with the four functions exported
-  by this module;
-- Binary instances for AST data types, only when "instantiated" at the GhcSe
-  phase.
-
-The former is done in two modules: HsExprBin_ConversionSE2PS and
-HsExprBin_ConversionPS2SE. The latter in HsExprBin_Instances.
-
--}
-
--- * .hs-splice file contents
-
-getModuleSplicesPath :: FilePath -> Module -> FilePath
-getModuleSplicesPath splicesDir m = splicesDir
-  </> toPath (moduleNameString (moduleName m)) <.> "hs-splice"
-
-  where toPath = map (\c -> if c == '.' then '/' else c)
-
-whenSet :: Monad m => Maybe a -> (a -> m b) -> m b -> m b
-whenSet m j n = maybe n j m
-
-newtype HsSpliceData = HsSpliceData { hsSpliceMap :: Map.Map SrcSpan SpliceResult }
-
-emptyHsSpliceData :: HsSpliceData
-emptyHsSpliceData = HsSpliceData Map.empty
-
-nonEmptyHsSpliceData :: HsSpliceData -> Bool
-nonEmptyHsSpliceData = not . Map.null . hsSpliceMap
-
-data SpliceResult
-  = SRExpr  (LHsExpr GhcSe)
-  | SRDecls [LHsDecl GhcSe] -- TODO: change to HsGroup ?
-  -- TODO: add patterns and types?
-
-instance Binary SpliceResult where
-  put_ bh r = case r of
-    SRExpr e -> putByte bh 0 >> put_ bh e
-    SRDecls ds -> putByte bh 1 >> put_ bh ds
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> SRExpr <$> get bh
-      1 -> SRDecls <$> get bh
-      _ -> panic "Binary SpliceResult: unknown tag"
-
-instance Binary HsSpliceData where
-  put_ bh (HsSpliceData m) = put_ bh (Map.toList m)
-  get bh = (\l -> HsSpliceData (Map.fromList l)) <$> get bh
-
-recordSpliceResult :: SrcSpan -> SpliceResult -> HsSpliceData -> HsSpliceData
-recordSpliceResult loc res (HsSpliceData m) = HsSpliceData (Map.insert loc res m)
-
-lookupSpliceResult :: SrcSpan -> HsSpliceData -> Maybe SpliceResult
-lookupSpliceResult loc (HsSpliceData m) = Map.lookup loc m
-
--- * High-level conversion interface
-
--- Converting Se -> Ps
-
--- | Convert a serialisable expression AST to a parsed expression AST
-exprSE2PS :: LHsExpr GhcSe -> RnM (ConvResult (LHsExpr GhcPs))
-exprSE2PS = runConv . SE2PS.cvLHsExpr
-
--- | Convert a serialisable declaration AST to a parsed declaration AST
-declSE2PS :: LHsDecl GhcSe -> RnM (ConvResult (LHsDecl GhcPs))
-declSE2PS = runConv . SE2PS.cvLHsDecl
-
--- Converting Ps -> Se
-
--- | Convert a parsed expression AST to a serialisable expression AST
-exprPS2SE :: LHsExpr GhcPs -> RnM (ConvResult (LHsExpr GhcSe))
-exprPS2SE = runConv . PS2SE.cvLHsExpr
-
--- | Convert a parsed declaration AST to a serialisable expression AST
-declPS2SE :: LHsDecl GhcPs -> RnM (ConvResult (LHsDecl GhcSe))
-declPS2SE = runConv . PS2SE.cvLHsDecl
-
--- * Error reporting
-
--- | Panics with a nice error when we encounter an unsupported
---   construct, or returns the actual result if the conversion
---   succeeded.
-handleUnsupported
-  :: Located SDoc -- ^ TH expression that got evaluated
-  -> Maybe SDoc -- ^ code resulting from the evaluation of the 1st arg
-  -> ConvResult a -- ^ result of the conversion
-  -> RnM a
-handleUnsupported (L loc thDoc) resDoc convRes = case convRes of
-  ConvOK a -> pure a
-  ConvError (ConvUnsupported conName tyName subexprDoc) ->
-    pprPanic "HsExprBin.handleUnsupported" . vcat $
-      [ text "GHC encountered a Haskell construct not supported by -{load, save}-splices:"
-      , nest 4 $ subexprDoc <> text (" - constructor " ++ conName ++ " of type " ++ tyName)
-      , text "while evaluating the following expression from "  <> ppr loc <> text ":"
-      , nest 4 $ thDoc
-      ] ++
-      maybe [] (\d -> [text "which resulted in:" , nest 4 d]) resDoc
-
-  ConvError (ConvFailure errorStr) -> panic errorStr
diff --git a/compiler/hsSyn/HsExprBin.hs-boot b/compiler/hsSyn/HsExprBin.hs-boot
deleted file mode 100644
index 964847e097..0000000000
--- a/compiler/hsSyn/HsExprBin.hs-boot
+++ /dev/null
@@ -1,4 +0,0 @@
-module HsExprBin where
-
-data HsSpliceData
-emptyHsSpliceData :: HsSpliceData
\ No newline at end of file
diff --git a/compiler/hsSyn/HsExprBin_ConversionPS2SE.hs b/compiler/hsSyn/HsExprBin_ConversionPS2SE.hs
deleted file mode 100644
index 839564fbfe..0000000000
--- a/compiler/hsSyn/HsExprBin_ConversionPS2SE.hs
+++ /dev/null
@@ -1,812 +0,0 @@
-{-# LANGUAGE GADTs #-}
-module HsExprBin_ConversionPS2SE where
-
-import Control.Applicative
-import Data.Traversable
-
-import Bag (mapBagM)
-import Class
-import CoreSyn ( Tickish(..) )
-import GhcPrelude
-import HsBinds
-import HsDecls
-import HsExpr
-import HsExprBin_Conversions
-import HsExtension
-import HsLit
-import HsPat
-import HsTypes
-
--- * Conversion from serialisable ASTs to parsed ASTs
-
-cvLHsDecl :: LHsDecl GhcPs -> Conv (LHsDecl GhcSe)
-cvLHsDecl = traverse cvHsDecl
-
-cvHsDecl :: HsDecl GhcPs -> Conv (HsDecl GhcSe)
-cvHsDecl (TyClD a b) = TyClD <$> pure a <*> cvTyClDecl b
-cvHsDecl (InstD a b) = InstD <$> pure a <*> cvInstDecl b
-cvHsDecl (DerivD a b) = DerivD <$> pure a <*> cvDerivDecl b
-cvHsDecl (ValD a b) = ValD <$> pure a <*> cvHsBindLR b
-cvHsDecl (SigD a b) = SigD <$> pure a <*> cvSig b
-cvHsDecl (DefD a b) = DefD <$> pure a <*> cvDefaultDecl b
-cvHsDecl (ForD a b) = ForD <$> pure a <*> cvForeignDecl b
-cvHsDecl (WarningD a b) = WarningD <$> pure a <*> cvWarningDecls b
-cvHsDecl (RoleAnnotD a b) = RoleAnnotD <$> pure a <*> cvRoleAnnotDecl b
-cvHsDecl (AnnD a b) = AnnD <$> pure a <*> cvAnnDecl b
-cvHsDecl (RuleD a b) = RuleD <$> pure a <*> cvRuleDecls b
-cvHsDecl (SpliceD a b) = SpliceD <$> pure a <*> cvSpliceDecl b
-cvHsDecl (DocD a b) = pure (DocD a b)
-cvHsDecl (XHsDecl a) = pure (XHsDecl a)
-
-cvAnnDecl :: AnnDecl GhcPs -> Conv (AnnDecl GhcSe)
-cvAnnDecl (HsAnnotation a b c d) =
-  HsAnnotation a b <$> cvAnnProvenance c <*> cvLHsExpr d
-cvAnnDecl (XAnnDecl a) = pure (XAnnDecl a)
-
-cvInstDecl :: InstDecl GhcPs -> Conv (InstDecl GhcSe)
-cvInstDecl (ClsInstD a b) = ClsInstD a <$> cvClsInstDecl b
-cvInstDecl (DataFamInstD a b) = DataFamInstD a <$> cvDataFamInstDecl b
-cvInstDecl (TyFamInstD a b) = TyFamInstD a <$> cvTyFamInstDecl b
-cvInstDecl (XInstDecl a) = pure (XInstDecl a)
-
-cvClsInstDecl :: ClsInstDecl GhcPs -> Conv (ClsInstDecl GhcSe)
-cvClsInstDecl (ClsInstDecl a b c d e f g) =
-  ClsInstDecl a
-    <$> cvHsImplicitBndrs (traverse cvType) b
-    <*> mapBagM (traverse cvHsBindLR) c
-    <*> traverse (traverse cvSig) d
-    <*> traverse (traverse cvTyFamInstDecl) e
-    <*> traverse (traverse cvDataFamInstDecl) f
-    <*> pure g
-cvClsInstDecl (XClsInstDecl a) = pure (XClsInstDecl a)
-
-cvDerivDecl :: DerivDecl GhcPs -> Conv (DerivDecl GhcSe)
-cvDerivDecl (DerivDecl a b c d) =
-  DerivDecl a <$> cvHsWildCardBndrs (cvHsImplicitBndrs $ traverse cvType) b
-              <*> traverse (traverse cvDerivStrategy) c
-              <*> pure d
-cvDerivDecl (XDerivDecl a) = pure (XDerivDecl a)
-
-cvDerivStrategy
-  :: DerivStrategy GhcPs -> Conv (DerivStrategy GhcSe)
-cvDerivStrategy StockStrategy = pure StockStrategy
-cvDerivStrategy AnyclassStrategy = pure AnyclassStrategy
-cvDerivStrategy NewtypeStrategy = pure NewtypeStrategy
-cvDerivStrategy (ViaStrategy a) = ViaStrategy
-  <$> cvHsImplicitBndrs (traverse cvType) a
-
-cvTyClDecl :: TyClDecl GhcPs -> Conv (TyClDecl GhcSe)
-cvTyClDecl (FamDecl a b) = FamDecl <$> pure a <*> cvFamilyDecl b
-cvTyClDecl (SynDecl a b c d e) =
-  SynDecl a
-    <$> convertName b
-    <*> cvLHsQTyVars c <*> pure d
-    <*> traverse cvType e
-cvTyClDecl (DataDecl a b c d e) =
-  DataDecl a
-    <$> convertName b
-    <*> cvLHsQTyVars c <*> pure d
-    <*> cvHsDataDefn e
-cvTyClDecl (ClassDecl a b c d e f g h i j k) =
-  ClassDecl a
-    <$> traverse (traverse (traverse cvType)) b
-    <*> convertName c
-    <*> cvLHsQTyVars d
-    <*> pure e
-    <*> traverse (traverse cvFunDep) f
-    <*> traverse (traverse cvSig) g
-    <*> mapBagM (traverse cvHsBindLR) h
-    <*> traverse (traverse cvFamilyDecl) i
-    <*> traverse (traverse $ cvFamEqn cvLHsQTyVars (traverse cvType)) j
-    <*> pure k
-cvTyClDecl (XTyClDecl a) = pure (XTyClDecl a)
-
-cvRoleAnnotDecl :: RoleAnnotDecl GhcPs -> Conv (RoleAnnotDecl GhcSe)
-cvRoleAnnotDecl (RoleAnnotDecl a b c) =
-  RoleAnnotDecl a <$> convertName b <*> pure c
-cvRoleAnnotDecl (XRoleAnnotDecl a) = pure (XRoleAnnotDecl a)
-
-cvRuleDecls :: RuleDecls GhcPs -> Conv (RuleDecls GhcSe)
-cvRuleDecls (HsRules a b c) = HsRules a b <$> traverse (traverse cvRuleDecl) c
-cvRuleDecls (XRuleDecls a) = pure (XRuleDecls a)
-
-cvRuleDecl :: RuleDecl GhcPs -> Conv (RuleDecl GhcSe)
-cvRuleDecl (HsRule a b c d e f) =
-  HsRule a b c <$> traverse (traverse cvRuleBndr) d
-               <*> cvLHsExpr e <*> cvLHsExpr f
-cvRuleDecl (XRuleDecl a) = pure (XRuleDecl a)
-
-cvSpliceDecl :: SpliceDecl GhcPs -> Conv (SpliceDecl GhcSe)
-cvSpliceDecl (SpliceDecl a b c) =
-  SpliceDecl a <$> traverse cvHsSplice b <*> pure c
-cvSpliceDecl (XSpliceDecl a) = pure (XSpliceDecl a)
-
-cvHsSplice :: HsSplice GhcPs -> Conv (HsSplice GhcSe)
-cvHsSplice (HsTypedSplice a b c d) =
-  HsTypedSplice a b <$> convertName c <*> cvLHsExpr d
-cvHsSplice (HsUntypedSplice a b c d) =
-  HsUntypedSplice a b <$> convertName c <*> cvLHsExpr d
-cvHsSplice (HsQuasiQuote a b c d e) =
-  HsQuasiQuote a <$> convertName b <*> convertName c <*> pure d <*> pure e
-cvHsSplice (HsSpliced {}) =
-  unsupported "HsSpliced" "HsSplice" (error "<not printable>")
-cvHsSplice (XSplice a) = pure (XSplice a)
-
-cvRuleBndr :: RuleBndr GhcPs -> Conv (RuleBndr GhcSe)
-cvRuleBndr (RuleBndr a b) = RuleBndr a <$> convertName b
-cvRuleBndr (RuleBndrSig a b c) =
-  RuleBndrSig a <$> convertName b <*> cvHsSigWcType c
-cvRuleBndr (XRuleBndr a) = pure (XRuleBndr a)
-
-cvFamEqn
-  :: ( XCFamEqn GhcPs a b ~ XCFamEqn GhcSe c d
-     , XXFamEqn GhcPs a b ~ XXFamEqn GhcSe c d
-     )
-  => (a -> Conv c)
-  -> (b -> Conv d)
-  -> FamEqn GhcPs a b
-  -> Conv (FamEqn GhcSe c d)
-cvFamEqn goPats goRhs (FamEqn a b c d e) =
-  FamEqn a <$> convertName b <*> goPats c <*> pure d <*> goRhs e
-cvFamEqn _ _ (XFamEqn a) = pure (XFamEqn a)
-
-cvFamilyDecl :: FamilyDecl GhcPs -> Conv (FamilyDecl GhcSe)
-cvFamilyDecl (FamilyDecl a b c d e f g) =
-  FamilyDecl a
-    <$> cvFamilyInfo b <*> convertName c
-    <*> cvLHsQTyVars d <*> pure e
-    <*> traverse cvFamilyResultSig f
-    <*> traverse (traverse cvInjectivityAnn) g
-cvFamilyDecl (XFamilyDecl a) = pure (XFamilyDecl a)
-
-cvAnnProvenance :: ConvertName a b => AnnProvenance a -> Conv (AnnProvenance b)
-cvAnnProvenance (ValueAnnProvenance a) = ValueAnnProvenance <$> convertName a
-cvAnnProvenance (TypeAnnProvenance a) = TypeAnnProvenance <$> convertName a
-cvAnnProvenance ModuleAnnProvenance = pure ModuleAnnProvenance
-
-cvInjectivityAnn
-  :: InjectivityAnn GhcPs -> Conv (InjectivityAnn GhcSe)
-cvInjectivityAnn (InjectivityAnn a b) =
-  InjectivityAnn <$> convertName a <*> convertName b
-
-cvFamilyResultSig
-  :: FamilyResultSig GhcPs -> Conv (FamilyResultSig GhcSe)
-cvFamilyResultSig (NoSig a) = pure (NoSig a)
-cvFamilyResultSig (KindSig a b) = KindSig a <$> traverse cvType b
-cvFamilyResultSig (TyVarSig a b) = TyVarSig a <$> traverse cvHsTyVarBndr b
-cvFamilyResultSig (XFamilyResultSig a) = pure (XFamilyResultSig a)
-
-cvFamilyInfo
-  :: FamilyInfo GhcPs -> Conv (FamilyInfo GhcSe)
-cvFamilyInfo DataFamily = pure DataFamily
-cvFamilyInfo OpenTypeFamily = pure OpenTypeFamily
-cvFamilyInfo (ClosedTypeFamily a) =
-  ClosedTypeFamily <$> traverse (traverse (traverse (cvFamInstEqn (traverse cvType)))) a
-
-cvFamInstEqn
-  :: ( XCFamEqn GhcPs (HsTyPats GhcPs) a
-       ~ XCFamEqn GhcSe (HsTyPats GhcSe) b
-     , XHsIB GhcPs (FamEqn GhcPs (HsTyPats p) a)
-       ~ XHsIB GhcSe (FamEqn GhcSe (HsTyPats GhcSe) b)
-     , XXFamEqn GhcPs (HsTyPats GhcPs) a
-       ~ XXFamEqn GhcSe (HsTyPats GhcSe) b
-     , XXHsImplicitBndrs GhcPs (FamEqn GhcPs (HsTyPats GhcPs) a)
-       ~ XXHsImplicitBndrs GhcSe (FamEqn GhcSe (HsTyPats GhcSe) b)
-     )
-  => (a -> Conv b)
-  -> FamInstEqn GhcPs a
-  -> Conv (FamInstEqn GhcSe b)
-cvFamInstEqn f = cvHsImplicitBndrs (cvFamEqn (traverse (traverse cvType)) f)
-
-cvFunDep :: ConvertName a b => FunDep a -> Conv (FunDep b)
-cvFunDep (xs, ys) = (,) <$> convertName xs <*> convertName ys
-
-cvLHsQTyVars :: LHsQTyVars GhcPs -> Conv (LHsQTyVars GhcSe)
-cvLHsQTyVars (HsQTvs a b) = HsQTvs a <$> traverse (traverse cvHsTyVarBndr) b
-cvLHsQTyVars (XLHsQTyVars a) = pure (XLHsQTyVars a)
-
-cvForeignDecl :: ForeignDecl GhcPs -> Conv (ForeignDecl GhcSe)
-cvForeignDecl (ForeignImport a b c d) =
-  ForeignImport a
-    <$> convertName b
-    <*> cvHsImplicitBndrs (traverse cvType) c
-    <*> pure d
-cvForeignDecl (ForeignExport a b c d) =
-  ForeignExport a
-    <$> convertName b
-    <*> cvHsImplicitBndrs (traverse cvType) c
-    <*> pure d
-cvForeignDecl (XForeignDecl a) = pure (XForeignDecl a)
-
-cvDefaultDecl :: DefaultDecl GhcPs -> Conv (DefaultDecl GhcSe)
-cvDefaultDecl (DefaultDecl a b) = DefaultDecl a <$> traverse (traverse cvType) b
-cvDefaultDecl (XDefaultDecl a) = pure (XDefaultDecl a)
-
-cvTyFamInstDecl
-  :: TyFamInstDecl GhcPs -> Conv (TyFamInstDecl GhcSe)
-cvTyFamInstDecl (TyFamInstDecl d) =
-  TyFamInstDecl <$> cvFamInstEqn (traverse cvType) d
-
-cvDataFamInstDecl
-  :: DataFamInstDecl GhcPs -> Conv (DataFamInstDecl GhcSe)
-cvDataFamInstDecl (DataFamInstDecl d) =
-  DataFamInstDecl <$> cvFamInstEqn cvHsDataDefn d
-
-cvHsDataDefn :: HsDataDefn GhcPs -> Conv (HsDataDefn GhcSe)
-cvHsDataDefn (HsDataDefn a b c d e f g) =
-  HsDataDefn a b
-    <$> traverse (traverse (traverse cvType)) c <*> pure d
-    <*> traverse (traverse cvType) e
-    <*> traverse (traverse cvConDecl) f <*> cvHsDeriving g
-cvHsDataDefn (XHsDataDefn a) = pure (XHsDataDefn a)
-
-cvConDecl :: ConDecl GhcPs -> Conv (ConDecl GhcSe)
-cvConDecl (ConDeclGADT a b c d e f g h) =
-  ConDeclGADT a
-    <$> convertName b
-    <*> pure c
-    <*> cvLHsQTyVars d
-    <*> traverse (traverse (traverse (traverse cvType))) e
-    <*> cvHsConDeclDetails f
-    <*> traverse cvType g
-    <*> pure h
-cvConDecl (ConDeclH98 a b c d e f g) =
-  ConDeclH98 a
-    <$> convertName b
-    <*> pure c
-    <*> traverse (traverse cvHsTyVarBndr) d
-    <*> traverse (traverse (traverse (traverse cvType))) e
-    <*> cvHsConDeclDetails f
-    <*> pure g
-cvConDecl (XConDecl a) = pure (XConDecl a)
-
-cvHsDeriving :: HsDeriving GhcPs -> Conv (HsDeriving GhcSe)
-cvHsDeriving = traverse (traverse (traverse cvHsDerivingClause))
-
-cvHsDerivingClause
-  :: HsDerivingClause GhcPs -> Conv (HsDerivingClause GhcSe)
-cvHsDerivingClause (HsDerivingClause a b c) =
-  HsDerivingClause a
-    <$> traverse (traverse cvDerivStrategy) b
-    <*> traverse (traverse (cvHsImplicitBndrs (traverse cvType))) c
-cvHsDerivingClause (XHsDerivingClause a) = pure (XHsDerivingClause a)
-
-cvHsConDeclDetails
-  :: HsConDeclDetails GhcPs -> Conv (HsConDeclDetails GhcSe)
-cvHsConDeclDetails =
-  cvHsConDetails (traverse cvType)
-                 (traverse (traverse (traverse cvConDeclField)))
-
-cvHsConDetails
-  :: (a -> Conv c) -> (b -> Conv d) -> HsConDetails a b -> Conv (HsConDetails c d)
-cvHsConDetails f _  (PrefixCon a) = PrefixCon <$> traverse f a
-cvHsConDetails _ g     (RecCon a) = RecCon    <$> g a
-cvHsConDetails f _ (InfixCon a b) = InfixCon  <$> f a <*> f b
-
-cvConDeclField :: ConDeclField GhcPs -> Conv (ConDeclField GhcSe)
-cvConDeclField (ConDeclField a b c d) =
-  ConDeclField a <$> traverse (traverse cvFieldOcc) b <*> traverse cvType c
-                 <*> pure d
-cvConDeclField (XConDeclField a) = pure (XConDeclField a)
-
-cvWarningDecls :: WarnDecls GhcPs -> Conv (WarnDecls GhcSe)
-cvWarningDecls (Warnings a b c) =
-  Warnings a b <$> traverse (traverse cvWarningDecl) c
-cvWarningDecls (XWarnDecls a) = pure (XWarnDecls a)
-
-cvWarningDecl :: WarnDecl GhcPs -> Conv (WarnDecl GhcSe)
-cvWarningDecl (Warning a b c) = Warning a <$> convertName b <*> pure c
-cvWarningDecl (XWarnDecl a) = pure (XWarnDecl a)
-
--- expressions
-
-cvLHsExpr :: LHsExpr GhcPs -> Conv (LHsExpr GhcSe)
-cvLHsExpr = traverse cvHsExpr
-
-cvHsExpr :: HsExpr GhcPs -> Conv (HsExpr GhcSe)
-cvHsExpr e = case e of
-  HsVar a b -> HsVar a <$> convertName b
-  HsUnboundVar a b -> pure (HsUnboundVar a b)
-  HsConLikeOut a b -> pure (HsConLikeOut a b)
-  HsRecFld a b -> HsRecFld a <$> cvAFieldOcc b
-  HsOverLabel a b c -> HsOverLabel a <$> convertName b <*> pure c
-  HsIPVar a b -> pure (HsIPVar a b)
-  HsOverLit a b -> HsOverLit a <$> cvOverLit b
-  HsLit a b -> HsLit a <$> cvLit b
-  HsLam a b -> HsLam a <$> cvMatchGroup cvLHsExpr b
-  HsLamCase a b -> HsLamCase a <$> cvMatchGroup cvLHsExpr b
-  HsApp a b c -> HsApp a <$> cvLHsExpr b <*> cvLHsExpr c
-  HsAppType a b -> HsAppType <$> cvLHsWcType a <*> cvLHsExpr b
-  OpApp a b c d -> OpApp a <$> cvLHsExpr b <*> cvLHsExpr c <*> cvLHsExpr d
-  NegApp a b c -> NegApp a <$> cvLHsExpr b <*> cvSyntaxExpr c
-  HsPar a b -> HsPar a <$> cvLHsExpr b
-  SectionL a b c -> SectionL a <$> cvLHsExpr b <*> cvLHsExpr c
-  SectionR a b c -> SectionR a <$> cvLHsExpr b <*> cvLHsExpr c
-  ExplicitTuple a b c -> ExplicitTuple a <$> traverse (traverse cvHsTupArg) b
-                                         <*> pure c
-  ExplicitSum a b c d -> ExplicitSum a b c <$> cvLHsExpr d
-  ExplicitList a b c -> ExplicitList a <$> traverse cvSyntaxExpr b <*> traverse cvLHsExpr c
-  HsCase a b c -> HsCase a <$> cvLHsExpr b <*> cvMatchGroup cvLHsExpr c
-  HsIf a b c d e -> HsIf a <$> traverse cvSyntaxExpr b
-                           <*> cvLHsExpr c <*> cvLHsExpr d <*> cvLHsExpr e
-  HsMultiIf a b -> HsMultiIf a <$> traverse (traverse (cvGRHS cvLHsExpr)) b
-  HsLet a b c -> HsLet a <$> traverse cvHsLocalBinds b <*> cvLHsExpr c
-  HsDo a b c -> HsDo a
-    <$> convertName b <*> traverse (traverse (traverse (cvStmtLR cvLHsExpr))) c
-  RecordCon a b c -> RecordCon a <$> convertName b <*> cvRecordBinds c
-  RecordUpd a b c -> RecordUpd a <$> cvLHsExpr b
-                                 <*> traverse (traverse cvHsRecUpdField) c
-  ExprWithTySig a b -> ExprWithTySig <$> cvHsSigWcType a <*> cvLHsExpr b
-  ArithSeq a b c -> ArithSeq a <$> traverse cvSyntaxExpr b <*> cvArithSeqInfo c
-  HsSCC a b c d -> HsSCC a b c <$> cvLHsExpr d
-  HsCoreAnn a b c d -> HsCoreAnn a b c <$> cvLHsExpr d
-  HsStatic a b -> HsStatic a <$> cvLHsExpr b
-  EWildPat a -> pure (EWildPat a)
-  EAsPat a b c -> EAsPat a <$> convertName b <*> cvLHsExpr c
-  EViewPat a b c -> EViewPat a <$> cvLHsExpr b <*> cvLHsExpr c
-  ELazyPat a b -> ELazyPat a <$> cvLHsExpr b
-  HsProc a b c -> HsProc a <$> traverse cvPat b <*> traverse cvHsCmdTop c
-  HsBinTick a b c d -> HsBinTick a b c <$> cvLHsExpr d
-  HsTickPragma a b c d e -> HsTickPragma a b c d <$> cvLHsExpr e
-  HsSpliceE a b -> HsSpliceE a <$> cvHsSplice b
-  HsBracket a b -> HsBracket a <$> cvHsBracket b
-  HsTick a b c -> HsTick a <$> cvTickish b <*> cvLHsExpr c
-  XExpr a -> pure (XExpr a)
-  HsArrApp {} -> unsupported "HsArrApp" "HsExpr" (error "<not printable>")
-  HsArrForm {} -> unsupported "HsArrForm" "HsExpr" (error "<not printable>")
-  HsWrap {} -> unsupported "HsWrap" "HsExpr" (error "<not printable>")
-  HsRnBracketOut {} -> unsupported "HsRnBracketOut" "HsExpr" (error "<not printable>")
-  HsTcBracketOut {} -> unsupported "HsTcBracketOut" "HsExpr" (error "<not printable>")
-
-cvHsBracket :: HsBracket GhcPs -> Conv (HsBracket GhcSe)
-cvHsBracket (ExpBr a b) = ExpBr a <$> cvLHsExpr b
-cvHsBracket (PatBr a b) = PatBr a <$> traverse cvPat b
-cvHsBracket (DecBrL a b) = DecBrL a <$> traverse (traverse cvHsDecl) b
-cvHsBracket (DecBrG a b) = DecBrG a <$> cvHsGroup b
-cvHsBracket (TypBr a b) = TypBr a <$> traverse cvType b
-cvHsBracket (VarBr a b c) = VarBr a b <$> convertName c
-cvHsBracket (TExpBr a b) = TExpBr a <$> cvLHsExpr b
-cvHsBracket (XBracket a) = pure (XBracket a)
-
-cvTickish :: ConvertName a b => Tickish a -> Conv (Tickish b)
-cvTickish (ProfNote a b c) = pure (ProfNote a b c)
-cvTickish (HpcTick a b) = pure (HpcTick a b)
-cvTickish (Breakpoint a b) = Breakpoint a <$> convertName b
-cvTickish (SourceNote a b) = pure (SourceNote a b)
-
-cvHsGroup :: HsGroup GhcPs -> Conv (HsGroup GhcSe)
-cvHsGroup (HsGroup a b c d e f g h i j k l) = HsGroup a
-  <$> cvHsValBindsLR b <*> traverse (traverse cvSpliceDecl) c
-  <*> traverse cvTyClGroup d
-  <*> traverse (traverse cvDerivDecl) e
-  <*> traverse (traverse cvFixitySig) f
-  <*> traverse (traverse cvDefaultDecl) g
-  <*> traverse (traverse cvForeignDecl) h
-  <*> traverse (traverse cvWarningDecls) i
-  <*> traverse (traverse cvAnnDecl) j
-  <*> traverse (traverse cvRuleDecls) k
-  <*> pure l
-cvHsGroup (XHsGroup a) = pure (XHsGroup a)
-
-cvTyClGroup :: TyClGroup GhcPs -> Conv (TyClGroup GhcSe)
-cvTyClGroup (TyClGroup a b c d) = TyClGroup a
-  <$> traverse (traverse cvTyClDecl) b
-  <*> traverse (traverse cvRoleAnnotDecl) c
-  <*> traverse (traverse cvInstDecl) d
-cvTyClGroup (XTyClGroup a) = pure (XTyClGroup a)
-
-cvHsCmdTop :: HsCmdTop GhcPs -> Conv (HsCmdTop GhcSe)
-cvHsCmdTop (HsCmdTop a b) = HsCmdTop a <$> traverse cvHsCmd b
-cvHsCmdTop (XCmdTop a) = pure (XCmdTop a)
-
-cvHsCmd :: HsCmd GhcPs -> Conv (HsCmd GhcSe)
-cvHsCmd (HsCmdArrApp a b c d e) = HsCmdArrApp a
-  <$> cvLHsExpr b <*> cvLHsExpr c <*> pure d <*> pure e
-cvHsCmd (HsCmdArrForm a b c d e) = HsCmdArrForm a
-  <$> cvLHsExpr b <*> pure c <*> pure d
-  <*> traverse (traverse cvHsCmdTop) e
-cvHsCmd (HsCmdApp a b c) = HsCmdApp a <$> traverse cvHsCmd b <*> cvLHsExpr c
-cvHsCmd (HsCmdLam a b) = HsCmdLam a <$> cvMatchGroup (traverse cvHsCmd) b
-cvHsCmd (HsCmdPar a b) = HsCmdPar a <$> traverse cvHsCmd b
-cvHsCmd (HsCmdCase a b c) = HsCmdCase a
-  <$> cvLHsExpr b <*> cvMatchGroup (traverse cvHsCmd) c
-cvHsCmd (HsCmdIf a b c d e) = HsCmdIf a
-  <$> traverse cvSyntaxExpr b
-  <*> cvLHsExpr c
-  <*> traverse cvHsCmd d
-  <*> traverse cvHsCmd e
-cvHsCmd (HsCmdLet a b c) = HsCmdLet a
-  <$> traverse cvHsLocalBinds b <*> traverse cvHsCmd c
-cvHsCmd (HsCmdDo a b) = HsCmdDo a
-  <$> traverse (traverse (traverse (cvStmtLR (traverse cvHsCmd)))) b
-cvHsCmd (HsCmdWrap {}) = unsupported "HsCmdWrap" "HsCmd" (error "<not printable>")
-cvHsCmd (XCmd a) = pure (XCmd a)
-
-cvArithSeqInfo :: ArithSeqInfo GhcPs -> Conv (ArithSeqInfo GhcSe)
-cvArithSeqInfo (From e) = From <$> cvLHsExpr e
-cvArithSeqInfo (FromThen a b) = FromThen <$> cvLHsExpr a <*> cvLHsExpr b
-cvArithSeqInfo (FromTo a b) = FromTo <$> cvLHsExpr a <*> cvLHsExpr b
-cvArithSeqInfo (FromThenTo a b c) = FromThenTo <$> cvLHsExpr a <*> cvLHsExpr b <*> cvLHsExpr c
-
-cvHsTupArg :: HsTupArg GhcPs -> Conv (HsTupArg GhcSe)
-cvHsTupArg (Present a b) = Present a <$> cvLHsExpr b
-cvHsTupArg (Missing a) = pure (Missing a)
-cvHsTupArg (XTupArg a) = pure (XTupArg a)
-
-cvAFieldOcc
-  :: AmbiguousFieldOcc GhcPs -> Conv (AmbiguousFieldOcc GhcSe)
-cvAFieldOcc (Unambiguous a b) = Unambiguous a <$> convertName b
-cvAFieldOcc (Ambiguous a b) = Ambiguous a <$> convertName b
-cvAFieldOcc (XAmbiguousFieldOcc a) = pure (XAmbiguousFieldOcc a)
-
-cvOverLit :: HsOverLit GhcPs -> Conv (HsOverLit GhcSe)
-cvOverLit (OverLit a b c) = OverLit a b <$> cvHsExpr c
-cvOverLit (XOverLit a) = pure (XOverLit a)
-
-cvLit :: HsLit GhcPs -> Conv (HsLit GhcSe)
-cvLit (HsChar a b) = pure (HsChar a b)
-cvLit (HsCharPrim a b) = pure (HsCharPrim a b)
-cvLit (HsString a b) = pure (HsString a b)
-cvLit (HsStringPrim a b) = pure (HsStringPrim a b)
-cvLit (HsInt a b) = pure (HsInt a b)
-cvLit (HsIntPrim a b) = pure (HsIntPrim a b)
-cvLit (HsWordPrim a b) = pure (HsWordPrim a b)
-cvLit (HsInt64Prim a b) = pure (HsInt64Prim a b)
-cvLit (HsWord64Prim a b) = pure (HsWord64Prim a b)
-cvLit (HsInteger a b c) = HsInteger a b <$> convertType c
-cvLit (HsRat a b c) = HsRat a b <$> convertType c
-cvLit (HsFloatPrim a b) = pure (HsFloatPrim a b)
-cvLit (HsDoublePrim a b) = pure (HsDoublePrim a b)
-cvLit (XLit a) = pure (XLit a)
-
-cvMatchGroup
-  :: ( XMG GhcPs a ~ XMG GhcSe b
-     , XCMatch GhcPs a ~ XCMatch GhcSe b
-     , XCGRHSs GhcPs a ~ XCGRHSs GhcSe b
-     , XCGRHS GhcPs a ~ XCGRHS GhcSe b
-     , XXMatchGroup GhcPs a ~ XXMatchGroup GhcSe b
-     , XXMatch GhcPs a ~ XXMatch GhcSe b
-     , XXGRHSs GhcPs a ~ XXGRHSs GhcSe b
-     , XXGRHS GhcPs a ~ XXGRHS GhcSe b
-     )
-  => (a -> Conv b) -> MatchGroup GhcPs a -> Conv (MatchGroup GhcSe b)
-cvMatchGroup f (MG a b c) = MG a
-  <$> traverse (traverse (traverse (cvMatch f))) b
-  <*> pure c
-cvMatchGroup _ (XMatchGroup a) = pure (XMatchGroup a)
-
-cvMatch
-  :: ( XCMatch GhcPs a ~ XCMatch GhcSe b
-     , XCGRHSs GhcPs a ~ XCGRHSs GhcSe b
-     , XCGRHS GhcPs a ~ XCGRHS GhcSe b
-     , XXMatch GhcPs a ~ XXMatch GhcSe b
-     , XXGRHSs GhcPs a ~ XXGRHSs GhcSe b
-     , XXGRHS GhcPs a ~ XXGRHS GhcSe b
-     )
-  => (a -> Conv b) -> Match GhcPs a -> Conv (Match GhcSe b)
-cvMatch f (Match a b c d) = Match a
-   <$> convertName b <*> traverse (traverse cvPat) c <*> cvGRHSs f d
-cvMatch _ (XMatch a) = pure (XMatch a)
-
-cvPat :: Pat GhcPs -> Conv (Pat GhcSe)
-cvPat (WildPat a) = pure (WildPat a)
-cvPat (VarPat a b) = VarPat a <$> convertName b
-cvPat (LazyPat a b) = LazyPat a <$> traverse cvPat b
-cvPat (AsPat a b c) = AsPat a <$> convertName b <*> traverse cvPat c
-cvPat (ParPat a b) = ParPat a <$> traverse cvPat b
-cvPat (BangPat a b) = BangPat a <$> traverse cvPat b
-cvPat (ListPat a b) = ListPat a
-  <$> traverse (traverse cvPat) b
-cvPat (TuplePat a b c) = TuplePat a
-  <$> traverse (traverse cvPat) b
-  <*> pure c
-cvPat (SumPat a b c d) = SumPat a
-  <$> traverse cvPat b
-  <*> pure c <*> pure d
-cvPat (ConPatIn a b) = ConPatIn <$> convertName a <*> cvHsConPatDetails b
-cvPat (ViewPat a b c) = ViewPat a <$> cvLHsExpr b <*> traverse cvPat c
-cvPat (LitPat a b) = LitPat a <$> cvLit b
-cvPat (NPat a b c d) = NPat a
-  <$> traverse cvOverLit b <*> traverse cvSyntaxExpr c
-  <*> cvSyntaxExpr d
-cvPat (NPlusKPat a b c d e f) = NPlusKPat a
-  <$> convertName b
-  <*> traverse cvOverLit c <*> cvOverLit d
-  <*> cvSyntaxExpr e <*> cvSyntaxExpr f
-cvPat (SigPat a b) = SigPat <$> cvHsSigWcType a <*> traverse cvPat b
-cvPat (SplicePat a b) = SplicePat a <$> cvHsSplice b
-cvPat (CoPat {}) = unsupported "CoPat" "Pat" (error "<not printable>")
-cvPat (ConPatOut {}) = unsupported "ConPatOut" "Pat" (error "<not printable>")
-cvPat (XPat a) = pure (XPat a)
-
-cvGRHSs
-  :: ( XCGRHSs GhcPs a ~ XCGRHSs GhcSe b
-     , XCGRHS GhcPs a ~ XCGRHS GhcSe b
-     , XXGRHSs GhcPs a ~ XXGRHSs GhcSe b
-     , XXGRHS GhcPs a ~ XXGRHS GhcSe b
-     )
-  => (a -> Conv b) -> GRHSs GhcPs a -> Conv (GRHSs GhcSe b)
-cvGRHSs f (GRHSs a b c) = GRHSs a
-  <$> traverse (traverse (cvGRHS f)) b
-  <*> traverse cvHsLocalBinds c
-cvGRHSs _ (XGRHSs a) = pure (XGRHSs a)
-
-cvGRHS
-  :: ( XCGRHS GhcPs a ~ XCGRHS GhcSe b
-     , XXGRHS GhcPs a ~ XXGRHS GhcSe b
-     )
-  => (a -> Conv b) -> GRHS GhcPs a -> Conv (GRHS GhcSe b)
-cvGRHS f (GRHS a b c) = GRHS a
-  <$> traverse (traverse (cvStmtLR cvLHsExpr)) b <*> f c
-cvGRHS _ (XGRHS a) = pure (XGRHS a)
-
-cvHsLocalBinds
-  :: HsLocalBinds GhcPs -> Conv (HsLocalBinds GhcSe)
-cvHsLocalBinds (HsValBinds a b) = HsValBinds a <$> cvHsValBindsLR b
-cvHsLocalBinds (HsIPBinds a b) = HsIPBinds a <$> cvHsIPBinds b
-cvHsLocalBinds (EmptyLocalBinds a) = pure (EmptyLocalBinds a)
-cvHsLocalBinds (XHsLocalBindsLR a) = pure (XHsLocalBindsLR a)
-
-cvHsValBindsLR
-  :: HsValBindsLR GhcPs GhcPs -> Conv (HsValBindsLR GhcSe GhcSe)
-cvHsValBindsLR (ValBinds a b c) = ValBinds a
-  <$> mapBagM (traverse cvHsBindLR) b
-  <*> traverse (traverse cvSig) c
-cvHsValBindsLR (XValBindsLR _) =
-  unsupported "XValBindsLR" "HsValBindsLR" (error "<not printable>")
-
-cvHsConPatDetails
-  :: HsConPatDetails GhcPs -> Conv (HsConPatDetails GhcSe)
-cvHsConPatDetails (PrefixCon a) = PrefixCon <$> traverse (traverse cvPat) a
-cvHsConPatDetails (RecCon a) = RecCon <$> cvHsRecFieldsPat a
-cvHsConPatDetails (InfixCon a b) = InfixCon
-  <$> traverse cvPat a <*> traverse cvPat b
-
-cvHsRecFields
-  :: (thing -> Conv thing')
-  -> HsRecFields GhcPs thing
-  -> Conv (HsRecFields GhcSe thing')
-cvHsRecFields f (HsRecFields a b) =
-  HsRecFields <$> traverse (traverse (cvHsRecField' cvFieldOcc f)) a <*> pure b
-
-cvHsRecField'
-  :: (id -> Conv id')
-  -> (thing -> Conv thing')
-  -> HsRecField' id thing
-  -> Conv (HsRecField' id' thing')
-cvHsRecField' f g (HsRecField a b c) =
-  HsRecField <$> traverse f a <*> g b <*> pure c
-
-cvHsRecFieldsPat
-  :: HsRecFields GhcPs (LPat GhcPs) -> Conv (HsRecFields GhcSe (LPat GhcSe))
-cvHsRecFieldsPat = cvHsRecFields (traverse cvPat)
-
-cvHsRecUpdField
-  :: HsRecUpdField GhcPs -> Conv (HsRecUpdField GhcSe)
-cvHsRecUpdField = cvHsRecField' cvAFieldOcc cvLHsExpr
-
-cvRecordBinds
-  :: HsRecordBinds GhcPs -> Conv (HsRecordBinds GhcSe)
-cvRecordBinds = cvHsRecFields cvLHsExpr
-
-cvFieldOcc :: FieldOcc GhcPs -> Conv (FieldOcc GhcSe)
-cvFieldOcc (FieldOcc a b) = FieldOcc a <$> convertName b
-cvFieldOcc (XFieldOcc a) = pure (XFieldOcc a)
-
-cvStmtLR
-  :: ( XLastStmt GhcPs GhcPs a ~ XLastStmt GhcSe GhcSe b
-     , XBindStmt GhcPs GhcPs a ~ XBindStmt GhcSe GhcSe b
-     , XBodyStmt GhcPs GhcPs a ~ XBodyStmt GhcSe GhcSe b
-     , XApplicativeStmt GhcPs GhcPs a ~ XApplicativeStmt GhcSe GhcSe b
-     , XLetStmt GhcPs GhcPs a ~ XLetStmt GhcSe GhcSe b
-     , XRecStmt GhcPs GhcPs a ~ XRecStmt GhcSe GhcSe b
-     , XParStmt GhcPs GhcPs a ~ XParStmt GhcSe GhcSe b
-     , XTransStmt GhcPs GhcPs a ~ XTransStmt GhcSe GhcSe b
-     , XXStmtLR GhcPs GhcPs a ~ XXStmtLR GhcSe GhcSe b
-     )
-  => (a -> Conv b) -> StmtLR GhcPs GhcPs a -> Conv (StmtLR GhcSe GhcSe b)
-cvStmtLR k (LastStmt a b c d) = LastStmt a
-  <$> k b <*> pure c <*> cvSyntaxExpr d
-cvStmtLR k (BindStmt a b c d e) = BindStmt a
-  <$> traverse cvPat b <*> k c
-  <*> cvSyntaxExpr d <*> cvSyntaxExpr e
-cvStmtLR k (BodyStmt a b c d) = BodyStmt a
-  <$> k b <*> cvSyntaxExpr c
-  <*> cvSyntaxExpr d
-cvStmtLR _ (ApplicativeStmt a b c) = ApplicativeStmt a
-  <$> traverse
-        (\(se, aa) -> (,) <$> cvSyntaxExpr se <*> cvApplicativeArg aa)
-        b
-  <*> traverse cvSyntaxExpr c
-cvStmtLR _ (LetStmt a b) = LetStmt a <$> traverse cvHsLocalBinds b
-cvStmtLR k (RecStmt a b c d e f g) = RecStmt a
-  <$> traverse (traverse (cvStmtLR k)) b
-  <*> convertName c
-  <*> convertName d
-  <*> cvSyntaxExpr e
-  <*> cvSyntaxExpr f
-  <*> cvSyntaxExpr g
-cvStmtLR _ (ParStmt a b c d) = ParStmt a
-  <$> traverse cvParStmtBlock b
-  <*> cvHsExpr c
-  <*> cvSyntaxExpr d
-cvStmtLR _ (TransStmt a b c d e f g h i) = TransStmt a b
-  <$> traverse (traverse (cvStmtLR cvLHsExpr)) c
-  <*> traverse (\(x, y) -> (,) <$> convertName x <*> convertName y) d
-  <*> cvLHsExpr e
-  <*> traverse cvLHsExpr f
-  <*> cvSyntaxExpr g
-  <*> cvSyntaxExpr h
-  <*> cvHsExpr i
-cvStmtLR _ (XStmtLR a) = pure (XStmtLR a)
-
-cvParStmtBlock
-  :: ParStmtBlock GhcPs GhcPs -> Conv (ParStmtBlock GhcSe GhcSe)
-cvParStmtBlock (ParStmtBlock a b c d) = ParStmtBlock a
-  <$> traverse (traverse (cvStmtLR cvLHsExpr)) b
-  <*> convertName c
-  <*> cvSyntaxExpr d
-cvParStmtBlock (XParStmtBlock a) = pure (XParStmtBlock a)
-
-cvSyntaxExpr :: SyntaxExpr GhcPs -> Conv (SyntaxExpr GhcSe)
-cvSyntaxExpr (SyntaxExpr a b c) =
-  SyntaxExpr <$> cvHsExpr a <*> pure b <*> pure c
-
-cvHsIPBinds
-  :: HsIPBinds GhcPs -> Conv (HsIPBinds GhcSe)
-cvHsIPBinds (IPBinds a b) = IPBinds a <$> traverse (traverse cvIPBind) b
-cvHsIPBinds (XHsIPBinds a) = pure (XHsIPBinds a)
-
-cvIPBind :: IPBind GhcPs -> Conv (IPBind GhcSe)
-cvIPBind (IPBind a b c) = IPBind a <$> convertName b <*> cvLHsExpr c
-cvIPBind (XIPBind a) = pure (XIPBind a)
-
-cvHsBindLR
-  :: HsBindLR GhcPs GhcPs -> Conv (HsBindLR GhcSe GhcSe)
-cvHsBindLR (FunBind a b c d e) = FunBind a
-  <$> convertName b
-  <*> cvMatchGroup cvLHsExpr c
-  <*> pure d <*> pure e
-cvHsBindLR (PatBind a b c d ) = PatBind a
-  <$> traverse cvPat b <*> cvGRHSs cvLHsExpr c <*> pure d
-cvHsBindLR (VarBind a b c d) = VarBind a
-  <$> convertName b <*> cvLHsExpr c <*> pure d
-cvHsBindLR (PatSynBind a b) = PatSynBind a <$> cvPatSynBind b
-cvHsBindLR (AbsBinds {}) =
-  unsupported "AbsBind" "HsBindLR" (error "<not printable>")
-cvHsBindLR (XHsBindsLR a) = pure (XHsBindsLR a)
-
-cvHsWildCardBndrs
-  :: ( XHsWC GhcPs thing ~ XHsWC GhcSe thing'
-     , XXHsWildCardBndrs GhcPs thing ~ XXHsWildCardBndrs GhcSe thing'
-     )
-  => (thing -> Conv thing')
-  -> HsWildCardBndrs GhcPs thing
-  -> Conv (HsWildCardBndrs GhcSe thing')
-cvHsWildCardBndrs thingF (HsWC a b) = HsWC a <$> thingF b
-cvHsWildCardBndrs _ (XHsWildCardBndrs a) = pure (XHsWildCardBndrs a)
-
-cvLHsWcType
-  :: LHsWcType GhcPs -> Conv (LHsWcType GhcSe)
-cvLHsWcType = cvHsWildCardBndrs (traverse cvType)
-
-cvHsSigWcType
-  :: LHsSigWcType GhcPs -> Conv (LHsSigWcType GhcSe)
-cvHsSigWcType = cvHsWildCardBndrs (cvHsImplicitBndrs (traverse cvType))
-
-cvHsImplicitBndrs
-  :: ( XHsIB GhcPs thing ~ XHsIB GhcSe thing'
-     , XXHsImplicitBndrs GhcPs thing ~ XXHsImplicitBndrs GhcSe thing'
-     )
-  => (thing -> Conv thing')
-  -> HsImplicitBndrs GhcPs thing
-  -> Conv (HsImplicitBndrs GhcSe thing')
-cvHsImplicitBndrs f (HsIB a b) = HsIB a <$> f b
-cvHsImplicitBndrs _ (XHsImplicitBndrs a) = pure (XHsImplicitBndrs a)
-
-cvType :: HsType GhcPs -> Conv (HsType GhcSe)
-cvType (HsForAllTy a b c) = HsForAllTy a
-  <$> traverse (traverse cvHsTyVarBndr) b
-  <*> traverse cvType c
-cvType (HsQualTy a b c) = HsQualTy a
-  <$> traverse (traverse (traverse cvType)) b
-  <*> traverse cvType c
-cvType (HsTyVar a b c) = HsTyVar a b <$> convertName c
-cvType (HsAppTy a b c) = HsAppTy a
-  <$> traverse cvType b
-  <*> traverse cvType c
-cvType (HsFunTy a b c) = HsFunTy a
-  <$> traverse cvType b
-  <*> traverse cvType c
-cvType (HsListTy a b) = HsListTy a <$> traverse cvType b
-cvType (HsTupleTy a b c) = HsTupleTy a b <$> traverse (traverse cvType) c
-cvType (HsSumTy a b) = HsSumTy a <$> traverse (traverse cvType) b
-cvType (HsOpTy a b c d) = HsOpTy a
-  <$> traverse cvType b
-  <*> convertName c
-  <*> traverse cvType d
-cvType (HsParTy a b) = HsParTy a <$> traverse cvType b
-cvType (HsIParamTy a b c) = HsIParamTy a b <$> traverse cvType c
-cvType (HsKindSig a b c) = HsKindSig a
-  <$> traverse cvType b
-  <*> traverse cvType c
-cvType (HsBangTy a b c) = HsBangTy a b <$> traverse cvType c
-cvType (HsRecTy a b) = HsRecTy a <$> traverse (traverse cvConDeclField) b
-cvType (HsExplicitListTy a b c) = HsExplicitListTy a b
-  <$> traverse (traverse cvType) c
-cvType (HsExplicitTupleTy a b) = HsExplicitTupleTy a
-  <$> traverse (traverse cvType) b
-cvType (HsTyLit a b) = pure (HsTyLit a b)
-cvType (HsWildCardTy a) = pure (HsWildCardTy a)
-cvType (HsDocTy a b c) = HsDocTy a <$> traverse cvType b <*> pure c
-cvType (HsSpliceTy a b) = HsSpliceTy a <$> cvHsSplice b
-cvType (HsStarTy a b) = pure (HsStarTy a b)
-cvType (XHsType a) = pure (XHsType a)
-
-cvHsTyVarBndr
-  :: HsTyVarBndr GhcPs -> Conv (HsTyVarBndr GhcSe)
-cvHsTyVarBndr (UserTyVar a b) = UserTyVar a <$> convertName b
-cvHsTyVarBndr (KindedTyVar a b c) = KindedTyVar a
-  <$> convertName b
-  <*> traverse cvType c
-cvHsTyVarBndr (XTyVarBndr a) = pure (XTyVarBndr a)
-
-cvApplicativeArg
-  :: ApplicativeArg GhcPs -> Conv (ApplicativeArg GhcSe)
-cvApplicativeArg (ApplicativeArgOne a b c d) = ApplicativeArgOne a
-  <$> traverse cvPat b <*> cvLHsExpr c <*> pure d
-cvApplicativeArg (ApplicativeArgMany a b c d) = ApplicativeArgMany a
-  <$> traverse (traverse (cvStmtLR cvLHsExpr)) b <*> cvHsExpr c
-  <*> traverse cvPat d
-cvApplicativeArg (XApplicativeArg a) = pure (XApplicativeArg a)
-
-cvSig :: Sig GhcPs -> Conv (Sig GhcSe)
-cvSig (TypeSig a b c) = TypeSig a <$> convertName b <*> cvHsSigWcType c
-cvSig (PatSynSig a b c) = PatSynSig a
-  <$> convertName b <*> cvHsImplicitBndrs (traverse cvType) c
-cvSig (ClassOpSig a b c d) = ClassOpSig a b
-  <$> convertName c <*> cvHsImplicitBndrs (traverse cvType) d
-cvSig (InlineSig a b c) = InlineSig a <$> convertName b <*> pure c
-cvSig (FixSig a b) = FixSig a <$> cvFixitySig b
-cvSig (SpecSig a b c d) = SpecSig a
-  <$> convertName b
-  <*> traverse (cvHsImplicitBndrs (traverse cvType)) c
-  <*> pure d
-cvSig (SpecInstSig a b c) = SpecInstSig a b
-  <$> cvHsImplicitBndrs (traverse cvType) c
-cvSig (SCCFunSig a b c d) = SCCFunSig a b <$> convertName c <*> pure d
-cvSig (CompleteMatchSig a b c d) = CompleteMatchSig a b
-  <$> convertName c <*> convertName d
-cvSig (MinimalSig a b c) = MinimalSig a b <$> traverse (traverse convertName) c
-cvSig (IdSig {}) = unsupported "IdSig" "Sig" (error "<not printable>")
-cvSig (XSig a) = pure (XSig a)
-
-cvFixitySig :: FixitySig GhcPs -> Conv (FixitySig GhcSe)
-cvFixitySig (FixitySig a b c) = FixitySig a <$> convertName b <*> pure c
-cvFixitySig (XFixitySig a) = pure (XFixitySig a)
-
-cvPatSynBind :: PatSynBind GhcPs GhcPs -> Conv (PatSynBind GhcSe GhcSe)
-cvPatSynBind (PSB a b c d e) = PSB a
-  <$> convertName b
-  <*> cvHsPatSynDetails convertName c <*> traverse cvPat d
-  <*> cvHsPatSynDir e
-cvPatSynBind (XPatSynBind a) = pure (XPatSynBind a)
-
-cvHsPatSynDetails
-  :: (a -> Conv b)
-  -> HsPatSynDetails a
-  -> Conv (HsPatSynDetails b)
-cvHsPatSynDetails f = cvHsConDetails f (traverse (cvRecordPatSynField f))
-
-cvRecordPatSynField
-  :: (a -> Conv b)
-  -> RecordPatSynField a
-  -> Conv (RecordPatSynField b)
-cvRecordPatSynField f (RecordPatSynField a b) =
-  RecordPatSynField <$> f a <*> f b
-
-cvHsPatSynDir :: HsPatSynDir GhcPs -> Conv (HsPatSynDir GhcSe)
-cvHsPatSynDir Unidirectional = pure Unidirectional
-cvHsPatSynDir ImplicitBidirectional = pure ImplicitBidirectional
-cvHsPatSynDir (ExplicitBidirectional a) = ExplicitBidirectional
-  <$> cvMatchGroup cvLHsExpr a
diff --git a/compiler/hsSyn/HsExprBin_ConversionSE2PS.hs b/compiler/hsSyn/HsExprBin_ConversionSE2PS.hs
deleted file mode 100644
index 8fbc941a71..0000000000
--- a/compiler/hsSyn/HsExprBin_ConversionSE2PS.hs
+++ /dev/null
@@ -1,813 +0,0 @@
-{-# LANGUAGE GADTs #-}
-module HsExprBin_ConversionSE2PS where
-
-import Control.Applicative
-import Data.Traversable
-
-import Bag (mapBagM)
-import Class
-import CoreSyn ( Tickish(..) )
-import GhcPrelude
-import HsBinds
-import HsDecls
-import HsExpr
-import HsExprBin_Conversions
-import HsExtension
-import HsLit
-import HsPat
-import HsTypes
-
--- * Conversion from serialisable ASTs to parsed ASTs
-
-cvLHsDecl :: LHsDecl GhcSe -> Conv (LHsDecl GhcPs)
-cvLHsDecl = traverse cvHsDecl
-
-cvHsDecl :: HsDecl GhcSe -> Conv (HsDecl GhcPs)
-cvHsDecl (TyClD a b) = TyClD <$> pure a <*> cvTyClDecl b
-cvHsDecl (InstD a b) = InstD <$> pure a <*> cvInstDecl b
-cvHsDecl (DerivD a b) = DerivD <$> pure a <*> cvDerivDecl b
-cvHsDecl (ValD a b) = ValD <$> pure a <*> cvHsBindLR b
-cvHsDecl (SigD a b) = SigD <$> pure a <*> cvSig b
-cvHsDecl (DefD a b) = DefD <$> pure a <*> cvDefaultDecl b
-cvHsDecl (ForD a b) = ForD <$> pure a <*> cvForeignDecl b
-cvHsDecl (WarningD a b) = WarningD <$> pure a <*> cvWarningDecls b
-cvHsDecl (RoleAnnotD a b) = RoleAnnotD <$> pure a <*> cvRoleAnnotDecl b
-cvHsDecl (AnnD a b) = AnnD <$> pure a <*> cvAnnDecl b
-cvHsDecl (RuleD a b) = RuleD <$> pure a <*> cvRuleDecls b
-cvHsDecl (SpliceD a b) = SpliceD <$> pure a <*> cvSpliceDecl b
-cvHsDecl (DocD a b) = pure (DocD a b)
-cvHsDecl (XHsDecl a) = pure (XHsDecl a)
-
-cvAnnDecl :: AnnDecl GhcSe -> Conv (AnnDecl GhcPs)
-cvAnnDecl (HsAnnotation a b c d) =
-  HsAnnotation a b <$> cvAnnProvenance c <*> cvLHsExpr d
-cvAnnDecl (XAnnDecl a) = pure (XAnnDecl a)
-
-cvInstDecl :: InstDecl GhcSe -> Conv (InstDecl GhcPs)
-cvInstDecl (ClsInstD a b) = ClsInstD a <$> cvClsInstDecl b
-cvInstDecl (DataFamInstD a b) = DataFamInstD a <$> cvDataFamInstDecl b
-cvInstDecl (TyFamInstD a b) = TyFamInstD a <$> cvTyFamInstDecl b
-cvInstDecl (XInstDecl a) = pure (XInstDecl a)
-
-cvClsInstDecl :: ClsInstDecl GhcSe -> Conv (ClsInstDecl GhcPs)
-cvClsInstDecl (ClsInstDecl a b c d e f g) =
-  ClsInstDecl a
-    <$> cvHsImplicitBndrs (traverse cvType) b
-    <*> mapBagM (traverse cvHsBindLR) c
-    <*> traverse (traverse cvSig) d
-    <*> traverse (traverse cvTyFamInstDecl) e
-    <*> traverse (traverse cvDataFamInstDecl) f
-    <*> pure g
-cvClsInstDecl (XClsInstDecl a) = pure (XClsInstDecl a)
-
-cvDerivDecl :: DerivDecl GhcSe -> Conv (DerivDecl GhcPs)
-cvDerivDecl (DerivDecl a b c d) =
-  DerivDecl a <$> cvHsWildCardBndrs (cvHsImplicitBndrs $ traverse cvType) b
-              <*> traverse (traverse cvDerivStrategy) c
-              <*> pure d
-cvDerivDecl (XDerivDecl a) = pure (XDerivDecl a)
-
-cvDerivStrategy
-  :: DerivStrategy GhcSe -> Conv (DerivStrategy GhcPs)
-cvDerivStrategy StockStrategy = pure StockStrategy
-cvDerivStrategy AnyclassStrategy = pure AnyclassStrategy
-cvDerivStrategy NewtypeStrategy = pure NewtypeStrategy
-cvDerivStrategy (ViaStrategy a) = ViaStrategy
-  <$> cvHsImplicitBndrs (traverse cvType) a
-
-cvTyClDecl :: TyClDecl GhcSe -> Conv (TyClDecl GhcPs)
-cvTyClDecl (FamDecl a b) = FamDecl <$> pure a <*> cvFamilyDecl b
-cvTyClDecl (SynDecl a b c d e) =
-  SynDecl a
-    <$> convertName b
-    <*> cvLHsQTyVars c <*> pure d
-    <*> traverse cvType e
-cvTyClDecl (DataDecl a b c d e) =
-  DataDecl a
-    <$> convertName b
-    <*> cvLHsQTyVars c <*> pure d
-    <*> cvHsDataDefn e
-cvTyClDecl (ClassDecl a b c d e f g h i j k) =
-  ClassDecl a
-    <$> traverse (traverse (traverse cvType)) b
-    <*> convertName c
-    <*> cvLHsQTyVars d
-    <*> pure e
-    <*> traverse (traverse cvFunDep) f
-    <*> traverse (traverse cvSig) g
-    <*> mapBagM (traverse cvHsBindLR) h
-    <*> traverse (traverse cvFamilyDecl) i
-    <*> traverse (traverse $ cvFamEqn cvLHsQTyVars (traverse cvType)) j
-    <*> pure k
-cvTyClDecl (XTyClDecl a) = pure (XTyClDecl a)
-
-cvRoleAnnotDecl :: RoleAnnotDecl GhcSe -> Conv (RoleAnnotDecl GhcPs)
-cvRoleAnnotDecl (RoleAnnotDecl a b c) =
-  RoleAnnotDecl a <$> convertName b <*> pure c
-cvRoleAnnotDecl (XRoleAnnotDecl a) = pure (XRoleAnnotDecl a)
-
-cvRuleDecls :: RuleDecls GhcSe -> Conv (RuleDecls GhcPs)
-cvRuleDecls (HsRules a b c) = HsRules a b <$> traverse (traverse cvRuleDecl) c
-cvRuleDecls (XRuleDecls a) = pure (XRuleDecls a)
-
-cvRuleDecl :: RuleDecl GhcSe -> Conv (RuleDecl GhcPs)
-cvRuleDecl (HsRule a b c d e f) =
-  HsRule a b c <$> traverse (traverse cvRuleBndr) d
-               <*> cvLHsExpr e <*> cvLHsExpr f
-cvRuleDecl (XRuleDecl a) = pure (XRuleDecl a)
-
-cvSpliceDecl :: SpliceDecl GhcSe -> Conv (SpliceDecl GhcPs)
-cvSpliceDecl (SpliceDecl a b c) =
-  SpliceDecl a <$> traverse cvHsSplice b <*> pure c
-cvSpliceDecl (XSpliceDecl a) = pure (XSpliceDecl a)
-
-cvHsSplice :: HsSplice GhcSe -> Conv (HsSplice GhcPs)
-cvHsSplice (HsTypedSplice a b c d) =
-  HsTypedSplice a b <$> convertName c <*> cvLHsExpr d
-cvHsSplice (HsUntypedSplice a b c d) =
-  HsUntypedSplice a b <$> convertName c <*> cvLHsExpr d
-cvHsSplice (HsQuasiQuote a b c d e) =
-  HsQuasiQuote a <$> convertName b <*> convertName c <*> pure d <*> pure e
-cvHsSplice (HsSpliced {}) =
-  unsupported "HsSpliced" "HsSplice" (error "<not printable>")
-cvHsSplice (XSplice a) = pure (XSplice a)
-
-cvRuleBndr :: RuleBndr GhcSe -> Conv (RuleBndr GhcPs)
-cvRuleBndr (RuleBndr a b) = RuleBndr a <$> convertName b
-cvRuleBndr (RuleBndrSig a b c) =
-  RuleBndrSig a <$> convertName b <*> cvHsSigWcType c
-cvRuleBndr (XRuleBndr a) = pure (XRuleBndr a)
-
-cvFamEqn
-  :: ( XCFamEqn GhcSe a b ~ XCFamEqn GhcPs c d
-     , XXFamEqn GhcSe a b ~ XXFamEqn GhcPs c d
-     )
-  => (a -> Conv c)
-  -> (b -> Conv d)
-  -> FamEqn GhcSe a b
-  -> Conv (FamEqn GhcPs c d)
-cvFamEqn goPats goRhs (FamEqn a b c d e) =
-  FamEqn a <$> convertName b <*> goPats c <*> pure d <*> goRhs e
-cvFamEqn _ _ (XFamEqn a) = pure (XFamEqn a)
-
-cvFamilyDecl :: FamilyDecl GhcSe -> Conv (FamilyDecl GhcPs)
-cvFamilyDecl (FamilyDecl a b c d e f g) =
-  FamilyDecl a
-    <$> cvFamilyInfo b <*> convertName c
-    <*> cvLHsQTyVars d <*> pure e
-    <*> traverse cvFamilyResultSig f
-    <*> traverse (traverse cvInjectivityAnn) g
-cvFamilyDecl (XFamilyDecl a) = pure (XFamilyDecl a)
-
-cvAnnProvenance :: ConvertName a b => AnnProvenance a -> Conv (AnnProvenance b)
-cvAnnProvenance (ValueAnnProvenance a) = ValueAnnProvenance <$> convertName a
-cvAnnProvenance (TypeAnnProvenance a) = TypeAnnProvenance <$> convertName a
-cvAnnProvenance ModuleAnnProvenance = pure ModuleAnnProvenance
-
-cvInjectivityAnn
-  :: InjectivityAnn GhcSe -> Conv (InjectivityAnn GhcPs)
-cvInjectivityAnn (InjectivityAnn a b) =
-  InjectivityAnn <$> convertName a <*> convertName b
-
-cvFamilyResultSig
-  :: FamilyResultSig GhcSe -> Conv (FamilyResultSig GhcPs)
-cvFamilyResultSig (NoSig a) = pure (NoSig a)
-cvFamilyResultSig (KindSig a b) = KindSig a <$> traverse cvType b
-cvFamilyResultSig (TyVarSig a b) = TyVarSig a <$> traverse cvHsTyVarBndr b
-cvFamilyResultSig (XFamilyResultSig a) = pure (XFamilyResultSig a)
-
-cvFamilyInfo
-  :: FamilyInfo GhcSe -> Conv (FamilyInfo GhcPs)
-cvFamilyInfo DataFamily = pure DataFamily
-cvFamilyInfo OpenTypeFamily = pure OpenTypeFamily
-cvFamilyInfo (ClosedTypeFamily a) =
-  ClosedTypeFamily <$> traverse (traverse (traverse (cvFamInstEqn (traverse cvType)))) a
-
-cvFamInstEqn
-  :: ( XCFamEqn GhcSe (HsTyPats GhcSe) a
-       ~ XCFamEqn GhcPs (HsTyPats GhcPs) b
-     , XHsIB GhcSe (FamEqn GhcSe (HsTyPats p) a)
-       ~ XHsIB GhcPs (FamEqn GhcPs (HsTyPats GhcPs) b)
-     , XXFamEqn GhcSe (HsTyPats GhcSe) a
-       ~ XXFamEqn GhcPs (HsTyPats GhcPs) b
-     , XXHsImplicitBndrs GhcSe (FamEqn GhcSe (HsTyPats GhcSe) a)
-       ~ XXHsImplicitBndrs GhcPs (FamEqn GhcPs (HsTyPats GhcPs) b)
-     )
-  => (a -> Conv b)
-  -> FamInstEqn GhcSe a
-  -> Conv (FamInstEqn GhcPs b)
-cvFamInstEqn f = cvHsImplicitBndrs (cvFamEqn (traverse (traverse cvType)) f)
-
-cvFunDep :: ConvertName a b => FunDep a -> Conv (FunDep b)
-cvFunDep (xs, ys) = (,) <$> convertName xs <*> convertName ys
-
-cvLHsQTyVars :: LHsQTyVars GhcSe -> Conv (LHsQTyVars GhcPs)
-cvLHsQTyVars (HsQTvs a b) = HsQTvs a <$> traverse (traverse cvHsTyVarBndr) b
-cvLHsQTyVars (XLHsQTyVars a) = pure (XLHsQTyVars a)
-
-cvForeignDecl :: ForeignDecl GhcSe -> Conv (ForeignDecl GhcPs)
-cvForeignDecl (ForeignImport a b c d) =
-  ForeignImport a
-    <$> convertName b
-    <*> cvHsImplicitBndrs (traverse cvType) c
-    <*> pure d
-cvForeignDecl (ForeignExport a b c d) =
-  ForeignExport a
-    <$> convertName b
-    <*> cvHsImplicitBndrs (traverse cvType) c
-    <*> pure d
-cvForeignDecl (XForeignDecl a) = pure (XForeignDecl a)
-
-cvDefaultDecl :: DefaultDecl GhcSe -> Conv (DefaultDecl GhcPs)
-cvDefaultDecl (DefaultDecl a b) = DefaultDecl a <$> traverse (traverse cvType) b
-cvDefaultDecl (XDefaultDecl a) = pure (XDefaultDecl a)
-
-cvTyFamInstDecl
-  :: TyFamInstDecl GhcSe -> Conv (TyFamInstDecl GhcPs)
-cvTyFamInstDecl (TyFamInstDecl d) =
-  TyFamInstDecl <$> cvFamInstEqn (traverse cvType) d
-
-cvDataFamInstDecl
-  :: DataFamInstDecl GhcSe -> Conv (DataFamInstDecl GhcPs)
-cvDataFamInstDecl (DataFamInstDecl d) =
-  DataFamInstDecl <$> cvFamInstEqn cvHsDataDefn d
-
-cvHsDataDefn :: HsDataDefn GhcSe -> Conv (HsDataDefn GhcPs)
-cvHsDataDefn (HsDataDefn a b c d e f g) =
-  HsDataDefn a b
-    <$> traverse (traverse (traverse cvType)) c <*> pure d
-    <*> traverse (traverse cvType) e
-    <*> traverse (traverse cvConDecl) f <*> cvHsDeriving g
-cvHsDataDefn (XHsDataDefn a) = pure (XHsDataDefn a)
-
-cvConDecl :: ConDecl GhcSe -> Conv (ConDecl GhcPs)
-cvConDecl (ConDeclGADT a b c d e f g h) =
-  ConDeclGADT a
-    <$> convertName b
-    <*> pure c
-    <*> cvLHsQTyVars d
-    <*> traverse (traverse (traverse (traverse cvType))) e
-    <*> cvHsConDeclDetails f
-    <*> traverse cvType g
-    <*> pure h
-cvConDecl (ConDeclH98 a b c d e f g) =
-  ConDeclH98 a
-    <$> convertName b
-    <*> pure c
-    <*> traverse (traverse cvHsTyVarBndr) d
-    <*> traverse (traverse (traverse (traverse cvType))) e
-    <*> cvHsConDeclDetails f
-    <*> pure g
-cvConDecl (XConDecl a) = pure (XConDecl a)
-
-cvHsDeriving :: HsDeriving GhcSe -> Conv (HsDeriving GhcPs)
-cvHsDeriving = traverse (traverse (traverse cvHsDerivingClause))
-
-cvHsDerivingClause
-  :: HsDerivingClause GhcSe -> Conv (HsDerivingClause GhcPs)
-cvHsDerivingClause (HsDerivingClause a b c) =
-  HsDerivingClause a
-    <$> traverse (traverse cvDerivStrategy) b
-    <*> traverse (traverse (cvHsImplicitBndrs (traverse cvType))) c
-cvHsDerivingClause (XHsDerivingClause a) = pure (XHsDerivingClause a)
-
-cvHsConDeclDetails
-  :: HsConDeclDetails GhcSe -> Conv (HsConDeclDetails GhcPs)
-cvHsConDeclDetails =
-  cvHsConDetails (traverse cvType)
-                 (traverse (traverse (traverse cvConDeclField)))
-
-cvHsConDetails
-  :: (a -> Conv c) -> (b -> Conv d) -> HsConDetails a b -> Conv (HsConDetails c d)
-cvHsConDetails f _  (PrefixCon a) = PrefixCon <$> traverse f a
-cvHsConDetails _ g     (RecCon a) = RecCon    <$> g a
-cvHsConDetails f _ (InfixCon a b) = InfixCon  <$> f a <*> f b
-
-cvConDeclField :: ConDeclField GhcSe -> Conv (ConDeclField GhcPs)
-cvConDeclField (ConDeclField a b c d) =
-  ConDeclField a <$> traverse (traverse cvFieldOcc) b <*> traverse cvType c
-                 <*> pure d
-cvConDeclField (XConDeclField a) = pure (XConDeclField a)
-
-cvWarningDecls :: WarnDecls GhcSe -> Conv (WarnDecls GhcPs)
-cvWarningDecls (Warnings a b c) =
-  Warnings a b <$> traverse (traverse cvWarningDecl) c
-cvWarningDecls (XWarnDecls a) = pure (XWarnDecls a)
-
-cvWarningDecl :: WarnDecl GhcSe -> Conv (WarnDecl GhcPs)
-cvWarningDecl (Warning a b c) = Warning a <$> convertName b <*> pure c
-cvWarningDecl (XWarnDecl a) = pure (XWarnDecl a)
-
--- expressions
-
-cvLHsExpr :: LHsExpr GhcSe -> Conv (LHsExpr GhcPs)
-cvLHsExpr = traverse cvHsExpr
-
-cvHsExpr :: HsExpr GhcSe -> Conv (HsExpr GhcPs)
-cvHsExpr e = case e of
-  HsVar a b -> HsVar a <$> convertName b
-  HsUnboundVar a b -> pure (HsUnboundVar a b)
-  HsConLikeOut a b -> pure (HsConLikeOut a b)
-  HsRecFld a b -> HsRecFld a <$> cvAFieldOcc b
-  HsOverLabel a b c -> HsOverLabel a <$> convertName b <*> pure c
-  HsIPVar a b -> pure (HsIPVar a b)
-  HsOverLit a b -> HsOverLit a <$> cvOverLit b
-  HsLit a b -> HsLit a <$> cvLit b
-  HsLam a b -> HsLam a <$> cvMatchGroup cvLHsExpr b
-  HsLamCase a b -> HsLamCase a <$> cvMatchGroup cvLHsExpr b
-  HsApp a b c -> HsApp a <$> cvLHsExpr b <*> cvLHsExpr c
-  HsAppType a b -> HsAppType
-    <$> cvHsWildCardBndrs (traverse cvType) a <*> cvLHsExpr b
-  OpApp a b c d -> OpApp a <$> cvLHsExpr b <*> cvLHsExpr c <*> cvLHsExpr d
-  NegApp a b c -> NegApp a <$> cvLHsExpr b <*> cvSyntaxExpr c
-  HsPar a b -> HsPar a <$> cvLHsExpr b
-  SectionL a b c -> SectionL a <$> cvLHsExpr b <*> cvLHsExpr c
-  SectionR a b c -> SectionR a <$> cvLHsExpr b <*> cvLHsExpr c
-  ExplicitTuple a b c -> ExplicitTuple a <$> traverse (traverse cvHsTupArg) b
-                                         <*> pure c
-  ExplicitSum a b c d -> ExplicitSum a b c <$> cvLHsExpr d
-  ExplicitList a b c -> ExplicitList a <$> traverse cvSyntaxExpr b <*> traverse cvLHsExpr c
-  HsCase a b c -> HsCase a <$> cvLHsExpr b <*> cvMatchGroup cvLHsExpr c
-  HsIf a b c d e -> HsIf a <$> traverse cvSyntaxExpr b
-                           <*> cvLHsExpr c <*> cvLHsExpr d <*> cvLHsExpr e
-  HsMultiIf a b -> HsMultiIf a <$> traverse (traverse (cvGRHS cvLHsExpr)) b
-  HsLet a b c -> HsLet a <$> traverse cvHsLocalBinds b <*> cvLHsExpr c
-  HsDo a b c -> HsDo a
-    <$> convertName b <*> traverse (traverse (traverse (cvStmtLR cvLHsExpr))) c
-  RecordCon a b c -> RecordCon a <$> convertName b <*> cvRecordBinds c
-  RecordUpd a b c -> RecordUpd a <$> cvLHsExpr b
-                                 <*> traverse (traverse cvHsRecUpdField) c
-  ExprWithTySig a b -> ExprWithTySig <$> cvHsSigWcType a <*> cvLHsExpr b
-  ArithSeq a b c -> ArithSeq a <$> traverse cvSyntaxExpr b <*> cvArithSeqInfo c
-  HsSCC a b c d -> HsSCC a b c <$> cvLHsExpr d
-  HsCoreAnn a b c d -> HsCoreAnn a b c <$> cvLHsExpr d
-  HsStatic a b -> HsStatic a <$> cvLHsExpr b
-  EWildPat a -> pure (EWildPat a)
-  EAsPat a b c -> EAsPat a <$> convertName b <*> cvLHsExpr c
-  EViewPat a b c -> EViewPat a <$> cvLHsExpr b <*> cvLHsExpr c
-  ELazyPat a b -> ELazyPat a <$> cvLHsExpr b
-  HsProc a b c -> HsProc a <$> traverse cvPat b <*> traverse cvHsCmdTop c
-  HsBinTick a b c d -> HsBinTick a b c <$> cvLHsExpr d
-  HsTickPragma a b c d e -> HsTickPragma a b c d <$> cvLHsExpr e
-  HsSpliceE a b -> HsSpliceE a <$> cvHsSplice b
-  HsBracket a b -> HsBracket a <$> cvHsBracket b
-  HsTick a b c -> HsTick a <$> cvTickish b <*> cvLHsExpr c
-  XExpr a -> pure (XExpr a)
-  HsArrApp {} -> unsupported "HsArrApp" "HsExpr" (error "<not printable>")
-  HsArrForm {} -> unsupported "HsArrForm" "HsExpr" (error "<not printable>")
-  HsWrap {} -> unsupported "HsWrap" "HsExpr" (error "<not printable>")
-  HsRnBracketOut {} -> unsupported "HsRnBracketOut" "HsExpr" (error "<not printable>")
-  HsTcBracketOut {} -> unsupported "HsTcBracketOut" "HsExpr" (error "<not printable>")
-
-cvHsBracket :: HsBracket GhcSe -> Conv (HsBracket GhcPs)
-cvHsBracket (ExpBr a b) = ExpBr a <$> cvLHsExpr b
-cvHsBracket (PatBr a b) = PatBr a <$> traverse cvPat b
-cvHsBracket (DecBrL a b) = DecBrL a <$> traverse (traverse cvHsDecl) b
-cvHsBracket (DecBrG a b) = DecBrG a <$> cvHsGroup b
-cvHsBracket (TypBr a b) = TypBr a <$> traverse cvType b
-cvHsBracket (VarBr a b c) = VarBr a b <$> convertName c
-cvHsBracket (TExpBr a b) = TExpBr a <$> cvLHsExpr b
-cvHsBracket (XBracket a) = pure (XBracket a)
-
-cvTickish :: ConvertName a b => Tickish a -> Conv (Tickish b)
-cvTickish (ProfNote a b c) = pure (ProfNote a b c)
-cvTickish (HpcTick a b) = pure (HpcTick a b)
-cvTickish (Breakpoint a b) = Breakpoint a <$> convertName b
-cvTickish (SourceNote a b) = pure (SourceNote a b)
-
-cvHsGroup :: HsGroup GhcSe -> Conv (HsGroup GhcPs)
-cvHsGroup (HsGroup a b c d e f g h i j k l) = HsGroup a
-  <$> cvHsValBindsLR b <*> traverse (traverse cvSpliceDecl) c
-  <*> traverse cvTyClGroup d
-  <*> traverse (traverse cvDerivDecl) e
-  <*> traverse (traverse cvFixitySig) f
-  <*> traverse (traverse cvDefaultDecl) g
-  <*> traverse (traverse cvForeignDecl) h
-  <*> traverse (traverse cvWarningDecls) i
-  <*> traverse (traverse cvAnnDecl) j
-  <*> traverse (traverse cvRuleDecls) k
-  <*> pure l
-cvHsGroup (XHsGroup a) = pure (XHsGroup a)
-
-cvTyClGroup :: TyClGroup GhcSe -> Conv (TyClGroup GhcPs)
-cvTyClGroup (TyClGroup a b c d) = TyClGroup a
-  <$> traverse (traverse cvTyClDecl) b
-  <*> traverse (traverse cvRoleAnnotDecl) c
-  <*> traverse (traverse cvInstDecl) d
-cvTyClGroup (XTyClGroup a) = pure (XTyClGroup a)
-
-cvHsCmdTop :: HsCmdTop GhcSe -> Conv (HsCmdTop GhcPs)
-cvHsCmdTop (HsCmdTop a b) = HsCmdTop a <$> traverse cvHsCmd b
-cvHsCmdTop (XCmdTop a) = pure (XCmdTop a)
-
-cvHsCmd :: HsCmd GhcSe -> Conv (HsCmd GhcPs)
-cvHsCmd (HsCmdArrApp a b c d e) = HsCmdArrApp a
-  <$> cvLHsExpr b <*> cvLHsExpr c <*> pure d <*> pure e
-cvHsCmd (HsCmdArrForm a b c d e) = HsCmdArrForm a
-  <$> cvLHsExpr b <*> pure c <*> pure d
-  <*> traverse (traverse cvHsCmdTop) e
-cvHsCmd (HsCmdApp a b c) = HsCmdApp a <$> traverse cvHsCmd b <*> cvLHsExpr c
-cvHsCmd (HsCmdLam a b) = HsCmdLam a <$> cvMatchGroup (traverse cvHsCmd) b
-cvHsCmd (HsCmdPar a b) = HsCmdPar a <$> traverse cvHsCmd b
-cvHsCmd (HsCmdCase a b c) = HsCmdCase a
-  <$> cvLHsExpr b <*> cvMatchGroup (traverse cvHsCmd) c
-cvHsCmd (HsCmdIf a b c d e) = HsCmdIf a
-  <$> traverse cvSyntaxExpr b
-  <*> cvLHsExpr c
-  <*> traverse cvHsCmd d
-  <*> traverse cvHsCmd e
-cvHsCmd (HsCmdLet a b c) = HsCmdLet a
-  <$> traverse cvHsLocalBinds b <*> traverse cvHsCmd c
-cvHsCmd (HsCmdDo a b) = HsCmdDo a
-  <$> traverse (traverse (traverse (cvStmtLR (traverse cvHsCmd)))) b
-cvHsCmd (HsCmdWrap {}) = unsupported "HsCmdWrap" "HsCmd" (error "<not printable>")
-cvHsCmd (XCmd a) = pure (XCmd a)
-
-cvArithSeqInfo :: ArithSeqInfo GhcSe -> Conv (ArithSeqInfo GhcPs)
-cvArithSeqInfo (From e) = From <$> cvLHsExpr e
-cvArithSeqInfo (FromThen a b) = FromThen <$> cvLHsExpr a <*> cvLHsExpr b
-cvArithSeqInfo (FromTo a b) = FromTo <$> cvLHsExpr a <*> cvLHsExpr b
-cvArithSeqInfo (FromThenTo a b c) = FromThenTo <$> cvLHsExpr a <*> cvLHsExpr b <*> cvLHsExpr c
-
-cvHsTupArg :: HsTupArg GhcSe -> Conv (HsTupArg GhcPs)
-cvHsTupArg (Present a b) = Present a <$> cvLHsExpr b
-cvHsTupArg (Missing a) = pure (Missing a)
-cvHsTupArg (XTupArg a) = pure (XTupArg a)
-
-cvAFieldOcc
-  :: AmbiguousFieldOcc GhcSe -> Conv (AmbiguousFieldOcc GhcPs)
-cvAFieldOcc (Unambiguous a b) = Unambiguous a <$> convertName b
-cvAFieldOcc (Ambiguous a b) = Ambiguous a <$> convertName b
-cvAFieldOcc (XAmbiguousFieldOcc a) = pure (XAmbiguousFieldOcc a)
-
-cvOverLit :: HsOverLit GhcSe -> Conv (HsOverLit GhcPs)
-cvOverLit (OverLit a b c) = OverLit a b <$> cvHsExpr c
-cvOverLit (XOverLit a) = pure (XOverLit a)
-
-cvLit :: HsLit GhcSe -> Conv (HsLit GhcPs)
-cvLit (HsChar a b) = pure (HsChar a b)
-cvLit (HsCharPrim a b) = pure (HsCharPrim a b)
-cvLit (HsString a b) = pure (HsString a b)
-cvLit (HsStringPrim a b) = pure (HsStringPrim a b)
-cvLit (HsInt a b) = pure (HsInt a b)
-cvLit (HsIntPrim a b) = pure (HsIntPrim a b)
-cvLit (HsWordPrim a b) = pure (HsWordPrim a b)
-cvLit (HsInt64Prim a b) = pure (HsInt64Prim a b)
-cvLit (HsWord64Prim a b) = pure (HsWord64Prim a b)
-cvLit (HsInteger a b c) = HsInteger a b <$> convertType c
-cvLit (HsRat a b c) = HsRat a b <$> convertType c
-cvLit (HsFloatPrim a b) = pure (HsFloatPrim a b)
-cvLit (HsDoublePrim a b) = pure (HsDoublePrim a b)
-cvLit (XLit a) = pure (XLit a)
-
-cvMatchGroup
-  :: ( XMG GhcSe a ~ XMG GhcPs b
-     , XCMatch GhcSe a ~ XCMatch GhcPs b
-     , XCGRHSs GhcSe a ~ XCGRHSs GhcPs b
-     , XCGRHS GhcSe a ~ XCGRHS GhcPs b
-     , XXMatchGroup GhcSe a ~ XXMatchGroup GhcPs b
-     , XXMatch GhcSe a ~ XXMatch GhcPs b
-     , XXGRHSs GhcSe a ~ XXGRHSs GhcPs b
-     , XXGRHS GhcSe a ~ XXGRHS GhcPs b
-     )
-  => (a -> Conv b) -> MatchGroup GhcSe a -> Conv (MatchGroup GhcPs b)
-cvMatchGroup f (MG a b c) = MG a
-  <$> traverse (traverse (traverse (cvMatch f))) b
-  <*> pure c
-cvMatchGroup _ (XMatchGroup a) = pure (XMatchGroup a)
-
-cvMatch
-  :: ( XCMatch GhcSe a ~ XCMatch GhcPs b
-     , XCGRHSs GhcSe a ~ XCGRHSs GhcPs b
-     , XCGRHS GhcSe a ~ XCGRHS GhcPs b
-     , XXMatch GhcSe a ~ XXMatch GhcPs b
-     , XXGRHSs GhcSe a ~ XXGRHSs GhcPs b
-     , XXGRHS GhcSe a ~ XXGRHS GhcPs b
-     )
-  => (a -> Conv b) -> Match GhcSe a -> Conv (Match GhcPs b)
-cvMatch f (Match a b c d) = Match a
-   <$> convertName b <*> traverse (traverse cvPat) c <*> cvGRHSs f d
-cvMatch _ (XMatch a) = pure (XMatch a)
-
-cvPat :: Pat GhcSe -> Conv (Pat GhcPs)
-cvPat (WildPat a) = pure (WildPat a)
-cvPat (VarPat a b) = VarPat a <$> convertName b
-cvPat (LazyPat a b) = LazyPat a <$> traverse cvPat b
-cvPat (AsPat a b c) = AsPat a <$> convertName b <*> traverse cvPat c
-cvPat (ParPat a b) = ParPat a <$> traverse cvPat b
-cvPat (BangPat a b) = BangPat a <$> traverse cvPat b
-cvPat (ListPat a b) = ListPat a
-  <$> traverse (traverse cvPat) b
-cvPat (TuplePat a b c) = TuplePat a
-  <$> traverse (traverse cvPat) b
-  <*> pure c
-cvPat (SumPat a b c d) = SumPat a
-  <$> traverse cvPat b
-  <*> pure c <*> pure d
-cvPat (ConPatIn a b) = ConPatIn <$> convertName a <*> cvHsConPatDetails b
-cvPat (ViewPat a b c) = ViewPat a <$> cvLHsExpr b <*> traverse cvPat c
-cvPat (LitPat a b) = LitPat a <$> cvLit b
-cvPat (NPat a b c d) = NPat a
-  <$> traverse cvOverLit b <*> traverse cvSyntaxExpr c
-  <*> cvSyntaxExpr d
-cvPat (NPlusKPat a b c d e f) = NPlusKPat a
-  <$> convertName b
-  <*> traverse cvOverLit c <*> cvOverLit d
-  <*> cvSyntaxExpr e <*> cvSyntaxExpr f
-cvPat (SigPat a b) = SigPat <$> cvHsSigWcType a <*> traverse cvPat b
-cvPat (SplicePat a b) = SplicePat a <$> cvHsSplice b
-cvPat (CoPat {}) = unsupported "CoPat" "Pat" (error "<not printable>")
-cvPat (ConPatOut {}) = unsupported "ConPatOut" "Pat" (error "<not printable>")
-cvPat (XPat a) = pure (XPat a)
-
-cvGRHSs
-  :: ( XCGRHSs GhcSe a ~ XCGRHSs GhcPs b
-     , XCGRHS GhcSe a ~ XCGRHS GhcPs b
-     , XXGRHSs GhcSe a ~ XXGRHSs GhcPs b
-     , XXGRHS GhcSe a ~ XXGRHS GhcPs b
-     )
-  => (a -> Conv b) -> GRHSs GhcSe a -> Conv (GRHSs GhcPs b)
-cvGRHSs f (GRHSs a b c) = GRHSs a
-  <$> traverse (traverse (cvGRHS f)) b
-  <*> traverse cvHsLocalBinds c
-cvGRHSs _ (XGRHSs a) = pure (XGRHSs a)
-
-cvGRHS
-  :: ( XCGRHS GhcSe a ~ XCGRHS GhcPs b
-     , XXGRHS GhcSe a ~ XXGRHS GhcPs b
-     )
-  => (a -> Conv b) -> GRHS GhcSe a -> Conv (GRHS GhcPs b)
-cvGRHS f (GRHS a b c) = GRHS a
-  <$> traverse (traverse (cvStmtLR cvLHsExpr)) b <*> f c
-cvGRHS _ (XGRHS a) = pure (XGRHS a)
-
-cvHsLocalBinds
-  :: HsLocalBinds GhcSe -> Conv (HsLocalBinds GhcPs)
-cvHsLocalBinds (HsValBinds a b) = HsValBinds a <$> cvHsValBindsLR b
-cvHsLocalBinds (HsIPBinds a b) = HsIPBinds a <$> cvHsIPBinds b
-cvHsLocalBinds (EmptyLocalBinds a) = pure (EmptyLocalBinds a)
-cvHsLocalBinds (XHsLocalBindsLR a) = pure (XHsLocalBindsLR a)
-
-cvHsValBindsLR
-  :: HsValBindsLR GhcSe GhcSe -> Conv (HsValBindsLR GhcPs GhcPs)
-cvHsValBindsLR (ValBinds a b c) = ValBinds a
-  <$> mapBagM (traverse cvHsBindLR) b
-  <*> traverse (traverse cvSig) c
-cvHsValBindsLR (XValBindsLR _) =
-  unsupported "XValBindsLR" "HsValBindsLR" (error "<not printable>")
-
-cvHsConPatDetails
-  :: HsConPatDetails GhcSe -> Conv (HsConPatDetails GhcPs)
-cvHsConPatDetails (PrefixCon a) = PrefixCon <$> traverse (traverse cvPat) a
-cvHsConPatDetails (RecCon a) = RecCon <$> cvHsRecFieldsPat a
-cvHsConPatDetails (InfixCon a b) = InfixCon
-  <$> traverse cvPat a <*> traverse cvPat b
-
-cvHsRecFields
-  :: (thing -> Conv thing')
-  -> HsRecFields GhcSe thing
-  -> Conv (HsRecFields GhcPs thing')
-cvHsRecFields f (HsRecFields a b) =
-  HsRecFields <$> traverse (traverse (cvHsRecField' cvFieldOcc f)) a <*> pure b
-
-cvHsRecField'
-  :: (id -> Conv id')
-  -> (thing -> Conv thing')
-  -> HsRecField' id thing
-  -> Conv (HsRecField' id' thing')
-cvHsRecField' f g (HsRecField a b c) =
-  HsRecField <$> traverse f a <*> g b <*> pure c
-
-cvHsRecFieldsPat
-  :: HsRecFields GhcSe (LPat GhcSe) -> Conv (HsRecFields GhcPs (LPat GhcPs))
-cvHsRecFieldsPat = cvHsRecFields (traverse cvPat)
-
-cvHsRecUpdField
-  :: HsRecUpdField GhcSe -> Conv (HsRecUpdField GhcPs)
-cvHsRecUpdField = cvHsRecField' cvAFieldOcc cvLHsExpr
-
-cvRecordBinds
-  :: HsRecordBinds GhcSe -> Conv (HsRecordBinds GhcPs)
-cvRecordBinds = cvHsRecFields cvLHsExpr
-
-cvFieldOcc :: FieldOcc GhcSe -> Conv (FieldOcc GhcPs)
-cvFieldOcc (FieldOcc a b) = FieldOcc a <$> convertName b
-cvFieldOcc (XFieldOcc a) = pure (XFieldOcc a)
-
-cvStmtLR
-  :: ( XLastStmt GhcSe GhcSe a ~ XLastStmt GhcPs GhcPs b
-     , XBindStmt GhcSe GhcSe a ~ XBindStmt GhcPs GhcPs b
-     , XBodyStmt GhcSe GhcSe a ~ XBodyStmt GhcPs GhcPs b
-     , XApplicativeStmt GhcSe GhcSe a ~ XApplicativeStmt GhcPs GhcPs b
-     , XLetStmt GhcSe GhcSe a ~ XLetStmt GhcPs GhcPs b
-     , XRecStmt GhcSe GhcSe a ~ XRecStmt GhcPs GhcPs b
-     , XParStmt GhcSe GhcSe a ~ XParStmt GhcPs GhcPs b
-     , XTransStmt GhcSe GhcSe a ~ XTransStmt GhcPs GhcPs b
-     , XXStmtLR GhcSe GhcSe a ~ XXStmtLR GhcPs GhcPs b
-     )
-  => (a -> Conv b) -> StmtLR GhcSe GhcSe a -> Conv (StmtLR GhcPs GhcPs b)
-cvStmtLR k (LastStmt a b c d) = LastStmt a
-  <$> k b <*> pure c <*> cvSyntaxExpr d
-cvStmtLR k (BindStmt a b c d e) = BindStmt a
-  <$> traverse cvPat b <*> k c
-  <*> cvSyntaxExpr d <*> cvSyntaxExpr e
-cvStmtLR k (BodyStmt a b c d) = BodyStmt a
-  <$> k b <*> cvSyntaxExpr c
-  <*> cvSyntaxExpr d
-cvStmtLR _ (ApplicativeStmt a b c) = ApplicativeStmt a
-  <$> traverse
-        (\(se, aa) -> (,) <$> cvSyntaxExpr se <*> cvApplicativeArg aa)
-        b
-  <*> traverse cvSyntaxExpr c
-cvStmtLR _ (LetStmt a b) = LetStmt a <$> traverse cvHsLocalBinds b
-cvStmtLR k (RecStmt a b c d e f g) = RecStmt a
-  <$> traverse (traverse (cvStmtLR k)) b
-  <*> convertName c
-  <*> convertName d
-  <*> cvSyntaxExpr e
-  <*> cvSyntaxExpr f
-  <*> cvSyntaxExpr g
-cvStmtLR _ (ParStmt a b c d) = ParStmt a
-  <$> traverse cvParStmtBlock b
-  <*> cvHsExpr c
-  <*> cvSyntaxExpr d
-cvStmtLR _ (TransStmt a b c d e f g h i) = TransStmt a b
-  <$> traverse (traverse (cvStmtLR cvLHsExpr)) c
-  <*> traverse (\(x, y) -> (,) <$> convertName x <*> convertName y) d
-  <*> cvLHsExpr e
-  <*> traverse cvLHsExpr f
-  <*> cvSyntaxExpr g
-  <*> cvSyntaxExpr h
-  <*> cvHsExpr i
-cvStmtLR _ (XStmtLR a) = pure (XStmtLR a)
-
-cvParStmtBlock
-  :: ParStmtBlock GhcSe GhcSe -> Conv (ParStmtBlock GhcPs GhcPs)
-cvParStmtBlock (ParStmtBlock a b c d) = ParStmtBlock a
-  <$> traverse (traverse (cvStmtLR cvLHsExpr)) b
-  <*> convertName c
-  <*> cvSyntaxExpr d
-cvParStmtBlock (XParStmtBlock a) = pure (XParStmtBlock a)
-
-cvSyntaxExpr :: SyntaxExpr GhcSe -> Conv (SyntaxExpr GhcPs)
-cvSyntaxExpr (SyntaxExpr a b c) =
-  SyntaxExpr <$> cvHsExpr a <*> pure b <*> pure c
-
-cvHsIPBinds
-  :: HsIPBinds GhcSe -> Conv (HsIPBinds GhcPs)
-cvHsIPBinds (IPBinds a b) = IPBinds a <$> traverse (traverse cvIPBind) b
-cvHsIPBinds (XHsIPBinds a) = pure (XHsIPBinds a)
-
-cvIPBind :: IPBind GhcSe -> Conv (IPBind GhcPs)
-cvIPBind (IPBind a b c) = IPBind a <$> convertName b <*> cvLHsExpr c
-cvIPBind (XIPBind a) = pure (XIPBind a)
-
-cvHsBindLR
-  :: HsBindLR GhcSe GhcSe -> Conv (HsBindLR GhcPs GhcPs)
-cvHsBindLR (FunBind a b c d e) = FunBind a
-  <$> convertName b
-  <*> cvMatchGroup cvLHsExpr c
-  <*> pure d <*> pure e
-cvHsBindLR (PatBind a b c d ) = PatBind a
-  <$> traverse cvPat b <*> cvGRHSs cvLHsExpr c <*> pure d
-cvHsBindLR (VarBind a b c d) = VarBind a
-  <$> convertName b <*> cvLHsExpr c <*> pure d
-cvHsBindLR (PatSynBind a b) = PatSynBind a <$> cvPatSynBind b
-cvHsBindLR (AbsBinds {}) =
-  unsupported "AbsBind" "HsBindLR" (error "<not printable>")
-cvHsBindLR (XHsBindsLR a) = pure (XHsBindsLR a)
-
-cvHsWildCardBndrs
-  :: ( XHsWC GhcSe thing ~ XHsWC GhcPs thing'
-     , XXHsWildCardBndrs GhcSe thing ~ XXHsWildCardBndrs GhcPs thing'
-     )
-  => (thing -> Conv thing')
-  -> HsWildCardBndrs GhcSe thing
-  -> Conv (HsWildCardBndrs GhcPs thing')
-cvHsWildCardBndrs thingF (HsWC a b) = HsWC a <$> thingF b
-cvHsWildCardBndrs _ (XHsWildCardBndrs a) = pure (XHsWildCardBndrs a)
-
-cvLHsWcType
-  :: LHsWcType GhcSe -> Conv (LHsWcType GhcPs)
-cvLHsWcType = cvHsWildCardBndrs (traverse cvType)
-
-cvHsSigWcType
-  :: LHsSigWcType GhcSe -> Conv (LHsSigWcType GhcPs)
-cvHsSigWcType = cvHsWildCardBndrs (cvHsImplicitBndrs (traverse cvType))
-
-cvHsImplicitBndrs
-  :: ( XHsIB GhcSe thing ~ XHsIB GhcPs thing'
-     , XXHsImplicitBndrs GhcSe thing ~ XXHsImplicitBndrs GhcPs thing'
-     )
-  => (thing -> Conv thing')
-  -> HsImplicitBndrs GhcSe thing
-  -> Conv (HsImplicitBndrs GhcPs thing')
-cvHsImplicitBndrs f (HsIB a b) = HsIB a <$> f b
-cvHsImplicitBndrs _ (XHsImplicitBndrs a) = pure (XHsImplicitBndrs a)
-
-cvType :: HsType GhcSe -> Conv (HsType GhcPs)
-cvType (HsForAllTy a b c) = HsForAllTy a
-  <$> traverse (traverse cvHsTyVarBndr) b
-  <*> traverse cvType c
-cvType (HsQualTy a b c) = HsQualTy a
-  <$> traverse (traverse (traverse cvType)) b
-  <*> traverse cvType c
-cvType (HsTyVar a b c) = HsTyVar a b <$> convertName c
-cvType (HsAppTy a b c) = HsAppTy a
-  <$> traverse cvType b
-  <*> traverse cvType c
-cvType (HsFunTy a b c) = HsFunTy a
-  <$> traverse cvType b
-  <*> traverse cvType c
-cvType (HsListTy a b) = HsListTy a <$> traverse cvType b
-cvType (HsTupleTy a b c) = HsTupleTy a b <$> traverse (traverse cvType) c
-cvType (HsSumTy a b) = HsSumTy a <$> traverse (traverse cvType) b
-cvType (HsOpTy a b c d) = HsOpTy a
-  <$> traverse cvType b
-  <*> convertName c
-  <*> traverse cvType d
-cvType (HsParTy a b) = HsParTy a <$> traverse cvType b
-cvType (HsIParamTy a b c) = HsIParamTy a b <$> traverse cvType c
-cvType (HsKindSig a b c) = HsKindSig a
-  <$> traverse cvType b
-  <*> traverse cvType c
-cvType (HsBangTy a b c) = HsBangTy a b <$> traverse cvType c
-cvType (HsRecTy a b) = HsRecTy a <$> traverse (traverse cvConDeclField) b
-cvType (HsExplicitListTy a b c) = HsExplicitListTy a b
-  <$> traverse (traverse cvType) c
-cvType (HsExplicitTupleTy a b) = HsExplicitTupleTy a
-  <$> traverse (traverse cvType) b
-cvType (HsTyLit a b) = pure (HsTyLit a b)
-cvType (HsWildCardTy a) = pure (HsWildCardTy a)
-cvType (HsDocTy a b c) = HsDocTy a <$> traverse cvType b <*> pure c
-cvType (HsSpliceTy a b) = HsSpliceTy a <$> cvHsSplice b
-cvType (HsStarTy a b) = pure (HsStarTy a b)
-cvType (XHsType a) = pure (XHsType a)
-
-cvHsTyVarBndr
-  :: HsTyVarBndr GhcSe -> Conv (HsTyVarBndr GhcPs)
-cvHsTyVarBndr (UserTyVar a b) = UserTyVar a <$> convertName b
-cvHsTyVarBndr (KindedTyVar a b c) = KindedTyVar a
-  <$> convertName b
-  <*> traverse cvType c
-cvHsTyVarBndr (XTyVarBndr a) = pure (XTyVarBndr a)
-
-cvApplicativeArg
-  :: ApplicativeArg GhcSe -> Conv (ApplicativeArg GhcPs)
-cvApplicativeArg (ApplicativeArgOne a b c d) = ApplicativeArgOne a
-  <$> traverse cvPat b <*> cvLHsExpr c <*> pure d
-cvApplicativeArg (ApplicativeArgMany a b c d) = ApplicativeArgMany a
-  <$> traverse (traverse (cvStmtLR cvLHsExpr)) b <*> cvHsExpr c
-  <*> traverse cvPat d
-cvApplicativeArg (XApplicativeArg a) = pure (XApplicativeArg a)
-
-cvSig :: Sig GhcSe -> Conv (Sig GhcPs)
-cvSig (TypeSig a b c) = TypeSig a <$> convertName b <*> cvHsSigWcType c
-cvSig (PatSynSig a b c) = PatSynSig a
-  <$> convertName b <*> cvHsImplicitBndrs (traverse cvType) c
-cvSig (ClassOpSig a b c d) = ClassOpSig a b
-  <$> convertName c <*> cvHsImplicitBndrs (traverse cvType) d
-cvSig (InlineSig a b c) = InlineSig a <$> convertName b <*> pure c
-cvSig (FixSig a b) = FixSig a <$> cvFixitySig b
-cvSig (SpecSig a b c d) = SpecSig a
-  <$> convertName b
-  <*> traverse (cvHsImplicitBndrs (traverse cvType)) c
-  <*> pure d
-cvSig (SpecInstSig a b c) = SpecInstSig a b
-  <$> cvHsImplicitBndrs (traverse cvType) c
-cvSig (SCCFunSig a b c d) = SCCFunSig a b <$> convertName c <*> pure d
-cvSig (CompleteMatchSig a b c d) = CompleteMatchSig a b
-  <$> convertName c <*> convertName d
-cvSig (MinimalSig a b c) = MinimalSig a b <$> traverse (traverse convertName) c
-cvSig (IdSig {}) = unsupported "IdSig" "Sig" (error "<not printable>")
-cvSig (XSig a) = pure (XSig a)
-
-cvFixitySig :: FixitySig GhcSe -> Conv (FixitySig GhcPs)
-cvFixitySig (FixitySig a b c) = FixitySig a <$> convertName b <*> pure c
-cvFixitySig (XFixitySig a) = pure (XFixitySig a)
-
-cvPatSynBind :: PatSynBind GhcSe GhcSe -> Conv (PatSynBind GhcPs GhcPs)
-cvPatSynBind (PSB a b c d e) = PSB a
-  <$> convertName b
-  <*> cvHsPatSynDetails convertName c <*> traverse cvPat d
-  <*> cvHsPatSynDir e
-cvPatSynBind (XPatSynBind a) = pure (XPatSynBind a)
-
-cvHsPatSynDetails
-  :: (a -> Conv b)
-  -> HsPatSynDetails a
-  -> Conv (HsPatSynDetails b)
-cvHsPatSynDetails f = cvHsConDetails f (traverse (cvRecordPatSynField f))
-
-cvRecordPatSynField
-  :: (a -> Conv b)
-  -> RecordPatSynField a
-  -> Conv (RecordPatSynField b)
-cvRecordPatSynField f (RecordPatSynField a b) =
-  RecordPatSynField <$> f a <*> f b
-
-cvHsPatSynDir :: HsPatSynDir GhcSe -> Conv (HsPatSynDir GhcPs)
-cvHsPatSynDir Unidirectional = pure Unidirectional
-cvHsPatSynDir ImplicitBidirectional = pure ImplicitBidirectional
-cvHsPatSynDir (ExplicitBidirectional a) = ExplicitBidirectional
-  <$> cvMatchGroup cvLHsExpr a
diff --git a/compiler/hsSyn/HsExprBin_Conversions.hs b/compiler/hsSyn/HsExprBin_Conversions.hs
deleted file mode 100644
index df2d8f929a..0000000000
--- a/compiler/hsSyn/HsExprBin_Conversions.hs
+++ /dev/null
@@ -1,211 +0,0 @@
-{-# LANGUAGE ConstraintKinds, DeriveFunctor #-}
-{-# LANGUAGE FlexibleContexts, FlexibleInstances #-}
-{-# LANGUAGE MultiParamTypeClasses #-}
-{-# LANGUAGE TypeFamilies, TypeSynonymInstances #-}
-module HsExprBin_Conversions where
-
-import Control.Applicative
-import Control.Monad
-import Control.Monad.IO.Class
-import Data.Char (isDigit)
-import Data.List (intercalate)
-import Data.Maybe
-import Data.Traversable
-
-import DynFlags
-import FastString
-import GhcPrelude
-import HsExpr
-import Module
-import Name
-import Outputable
-import PackageConfig
-import Packages
-import RdrName
-import SeName
-import SrcLoc
-import TcRnTypes
-import IfaceType
-import ToIface (toIfaceType)
-import TyCoRep (Type(..), TyLit(..))
-
-data ConvError
-  = ConvUnsupported String String SDoc
-  -- constructor name, type name, text rendering
-  -- of the unsupported subexpression
-  | ConvFailure String
-
-data ConvResult a
-  = ConvError ConvError
-  | ConvOK a
-  deriving Functor
--- * Conversion utilities
-
-newtype Conv a = Conv { runConv :: RnM (ConvResult a) }
-
-instance Functor Conv where
-  fmap f (Conv k) = Conv (fmap (fmap f) k)
-
-instance Applicative Conv where
-  pure = Conv . return . ConvOK
-  (<*>) = ap
-
-instance Monad Conv where
-  return = pure
-
-  Conv mx >>= f = Conv $ mx >>= \cvx -> case cvx of
-    ConvOK x    -> runConv (f x)
-    ConvError e -> pure (ConvError e)
-
-unsupported :: String -- ^ constructor name
-            -> String -- ^ type name
-            -> SDoc   -- ^ textual rendering of the unsupported subexpression
-            -> Conv a
-unsupported con ty subexpr = Conv $
-  pure (ConvError $ ConvUnsupported con ty subexpr)
-
-badInput :: String -> Conv a
-badInput str = Conv $ pure (ConvError $ ConvFailure str)
-
-liftRn :: RnM a -> Conv a
-liftRn = Conv . fmap ConvOK
-
-class ConvertType t u where
-  convertType :: t -> Conv u
-
-class ConvertName a b where
-  convertName :: a -> Conv b
-
-instance ConvertName a b => ConvertName (Located a) (Located b) where
-  convertName = traverse convertName
-
-instance ConvertName a b => ConvertName [a] [b] where
-  convertName = traverse convertName
-
-instance ConvertName a b => ConvertName (Either e a) (Either e b) where
-  convertName = traverse convertName
-
-instance ConvertName a b => ConvertName (HsMatchContext a) (HsMatchContext b) where
-  convertName = traverse convertName
-
-instance ConvertName a b => ConvertName (HsStmtContext a) (HsStmtContext b) where
-  convertName = traverse convertName
-
-instance ConvertName a b => ConvertName (Maybe a) (Maybe b) where
-  convertName = traverse convertName
-
-instance ConvertType a a where
-  convertType = pure
-
-instance ConvertType Type IfaceType where
-  convertType = pure . toIfaceType
-
-instance ConvertType IfaceType Type where
-  convertType (IfaceLitTy n) = pure $ LitTy (go n)
-    where go (IfaceNumTyLit a) = NumTyLit a
-          go (IfaceStrTyLit a) = StrTyLit a
-  convertType e@(IfaceFreeTyVar {}) = unsupported "IfaceFreeTyVar" "IfaceType" (ppr e)
-  convertType e@(IfaceTyVar {}) = unsupported "IfaceTyVar" "IfaceType" (ppr e)
-  convertType e@(IfaceAppTy {}) = unsupported "IfaceAppTy" "IfaceType" (ppr e)
-  convertType e@(IfaceFunTy {}) = unsupported "IfaceFunTy" "IfaceType" (ppr e)
-  convertType e@(IfaceDFunTy {}) = unsupported "IfaceDFunTy" "IfaceType" (ppr e)
-  convertType e@(IfaceForAllTy {}) = unsupported "IfaceForAllTy" "IfaceType" (ppr e)
-  convertType e@(IfaceTyConApp {}) = unsupported "IfaceTyConApp" "IfaceType" (ppr e)
-  convertType e@(IfaceCastTy {}) = unsupported "IfaceCastTy" "IfaceType" (ppr e)
-  convertType e@(IfaceCoercionTy {}) = unsupported "IfaceCoercion" "IfaceType" (ppr e)
-  convertType e@(IfaceTupleTy {}) = unsupported "IfaceTupleTy" "IfaceType" (ppr e)
-
-
-instance ConvertName RdrName SeName where
-  convertName = pure . mkSeName
-
-instance ConvertName SeName RdrName where
-  convertName (SeName n) = case n of
-    Orig mod occn -> do
-      -- TODO: introduce some caching here, to avoid doing the
-      --       searchPackageId dance too often.
-      currentMod <- liftRn getModule
-
-      if samePackages currentMod mod
-        then let newMod = mod { moduleUnitId = moduleUnitId currentMod } in
-               pure (Orig newMod occn)
-        else do mnewmod <- liftRn (findEquivalentModule mod)
-                case mnewmod of
-                  Nothing   -> pure (Orig mod occn)
-                  Just mod' -> pure (Orig mod' occn)
-
-    _             -> pure n
-
-    where samePackages mod1 mod2 = fromMaybe False $ do -- maybe monad
-            let str1 = unitIdString (moduleUnitId mod1)
-                str2 = unitIdString (moduleUnitId mod2)
-            (pkg1, ver1, _mhash1) <- parseUnitId' str1
-            (pkg2, ver2, _mhash2) <- parseUnitId' str2
-            return (pkg1 == pkg2 && ver1 == ver2)
-
-instance ConvertName Name SeName where
-  convertName n = pure $ mkSeName (nameRdrName n)
-
-instance ConvertName SeName Name where
-  convertName (SeName n) = case isExact_maybe n of
-    Just a -> pure a
-    _      -> badInput "convertName :: SeName -> Name: non exact RdrName in SeName"
-
--- * Looking up modules/packages for Orig names
-
--- this rejects wired in packages, because we want to leave them untouched
-parseUnitId' :: String -> Maybe (String, String, Maybe String)
-parseUnitId' = parse
-
-  where
-    parse s = case splitOn '-' (reverse s) of
-      ("":_) -> Nothing
-      xs | length xs >= 1 && last xs == "" -> Nothing
-      (hash:ver:name) | isVersion ver ->
-         Just (intercalate "-" (reverse name), ver, Just hash)
-      (ver:name) | isVersion ver ->
-         Just (intercalate "-" (reverse name), ver, Nothing)
-      _ -> Nothing
-    splitOn c = go []
-      where go acc (x:xs)
-              | x == c    = acc : go "" xs
-              | otherwise = go (x:acc) xs
-            go acc [] = [acc]
-    isVersion = go False
-      -- True: waiting for digit or dot (we've seen a digit last)
-      -- False: waiting for digit (we've just seen a dot)
-      where go False (c:cs)
-              | isDigit c = go True cs
-              | otherwise = False
-            go True (c:cs)
-              | isDigit c = go True cs
-              | c == '.'  = go False cs
-              | otherwise = False
-            go b [] = b -- if we've seen a dot last (False), we fail
-                        -- otherwise, the version number can end here
-
--- | Look up the module from the same package, but built by the
---   current compiler, therefore with a slightly different hash
---   in the unit id than the input Module, which was built by some
---   non-cross-compiling GHC.
-findEquivalentModule :: Module -> RnM (Maybe Module)
-findEquivalentModule mod = do
-  liftIO $ putStrLn ("Looking for equivalent to: " ++ unitIdStr)
-  case parseUnitId' unitIdStr of
-    Nothing -> return Nothing
-    Just (pkg, ver, _mhash) -> do
-      muid <- lookFor pkg ver
-      maybe (pure Nothing) (\uid -> return $ Just (mod { moduleUnitId = uid })) muid
-
-  where unitIdStr = unitIdString (moduleUnitId mod)
-
-lookFor :: String -> String -> RnM (Maybe UnitId)
-lookFor pkg ver = do
-  dflags <- getDynFlags
-  let pkgid = mkFastString (pkg ++ "-" ++ ver)
-      pkgs = searchPackageId dflags (SourcePackageId pkgid)
-  liftIO $ putStrLn ("Looking for: " ++ pkg ++ "-" ++ ver)
-  liftIO . putStrLn . unwords $
-    [ "Found", show (length pkgs), "pkgs:" ] ++
-    [ unitIdString (packageConfigId p) | p <- pkgs ]
-  if null pkgs then pure Nothing else pure (Just $ packageConfigId (head pkgs))
diff --git a/compiler/hsSyn/HsExprBin_Instances.hs b/compiler/hsSyn/HsExprBin_Instances.hs
deleted file mode 100644
index 24abf8d69a..0000000000
--- a/compiler/hsSyn/HsExprBin_Instances.hs
+++ /dev/null
@@ -1,1665 +0,0 @@
--- too noisy during development...
-{-# OPTIONS_GHC -fno-warn-orphans #-}
-{-# LANGUAGE GeneralizedNewtypeDeriving #-}
-{-# LANGUAGE StandaloneDeriving #-}
-{-# LANGUAGE FlexibleContexts, FlexibleInstances #-}
-module HsExprBin_Instances where
-
-import Control.Applicative
-import Control.Monad
-
-import BasicTypes
-import Binary
-import CoreSyn ( Tickish(..) )
-import GhcPrelude
-import HsBinds
-import HsDecls
-import HsExpr
-import HsExtension
-import HsLit
-import HsPat
-import HsTypes
-import Name
-import Outputable
-import RdrName
-import SeName
-import SrcLoc
-import TcEvidence (HsWrapper(WpHole))
-
--- * Utilities
-
-putPanic :: String -> String -> a
-putPanic tyName conName =
-  panic ("Binary " ++ tyName ++ ".put: " ++ conName ++ " not supported")
-
-getPanic :: String -> a
-getPanic tyName =
-  panic ("Binary " ++ tyName ++ ".get: unknown (or unsupported) tag")
-
--- * Binary instances
-
-instance Binary (HsExpr GhcSe) where
-  put_ bh e = case e of
-    HsVar a b ->
-      putByte bh 0 >> put_ bh a >> put_ bh b
-    HsUnboundVar a b ->
-      putByte bh 1 >> put_ bh a >> put_ bh b
-    HsRecFld a b ->
-      putByte bh 2 >> put_ bh a >> put_ bh b
-    HsOverLabel a b c ->
-      putByte bh 3 >> put_ bh a >> put_ bh b >> put_ bh c
-    HsIPVar a b ->
-      putByte bh 4 >> put_ bh a >> put_ bh b
-    HsOverLit a b ->
-      putByte bh 5 >> put_ bh a >> put_ bh b
-    HsLit a b ->
-      putByte bh 6 >> put_ bh a >> put_ bh b
-    HsLam a b ->
-      putByte bh 7 >> put_ bh a >> put_ bh b
-    HsLamCase a b ->
-      putByte bh 8 >> put_ bh a >> put_ bh b
-    HsApp a b c ->
-      putByte bh 9 >> put_ bh a >> put_ bh b >> put_ bh c
-    HsAppType a b ->
-      putByte bh 10 >> put_ bh a >> put_ bh b
-    OpApp a b c d ->
-      putByte bh 11 >> put_ bh a >> put_ bh b >> put_ bh c
-                    >> put_ bh d
-    NegApp a b c ->
-      putByte bh 12 >> put_ bh a >> put_ bh b >> put_ bh c
-    HsPar a b ->
-      putByte bh 13 >> put_ bh a >> put_ bh b
-    SectionL a b c ->
-      putByte bh 14 >> put_ bh a >> put_ bh b >> put_ bh c
-    SectionR a b c ->
-      putByte bh 15 >> put_ bh a >> put_ bh b >> put_ bh c
-    ExplicitTuple a b c ->
-      putByte bh 16 >> put_ bh a >> put_ bh b >> put_ bh c
-    ExplicitSum a b c d ->
-      putByte bh 17 >> put_ bh a >> put_ bh b >> put_ bh c
-                    >> put_ bh d
-    HsCase a b c ->
-      putByte bh 18 >> put_ bh a >> put_ bh b >> put_ bh c
-    HsIf a b c d e ->
-      putByte bh 19 >> put_ bh a >> put_ bh b >> put_ bh c
-                    >> put_ bh d >> put_ bh e
-    HsMultiIf a b ->
-      putByte bh 20 >> put_ bh a >> put_ bh b
-    HsLet a b c ->
-      putByte bh 21 >> put_ bh a >> put_ bh b >> put_ bh c
-    HsDo a b c ->
-      putByte bh 22 >> put_ bh a >> put_ bh b >> put_ bh c
-    ExplicitList a b c ->
-      putByte bh 23 >> put_ bh a >> put_ bh b >> put_ bh c
-    RecordCon a b c ->
-      putByte bh 24 >> put_ bh a >> put_ bh b >> put_ bh c
-    RecordUpd a b c ->
-      putByte bh 25 >> put_ bh a >> put_ bh b >> put_ bh c
-    ExprWithTySig a b ->
-      putByte bh 26 >> put_ bh a >> put_ bh b
-    ArithSeq a b c ->
-      putByte bh 27 >> put_ bh a >> put_ bh b >> put_ bh c
-    EWildPat a ->
-      putByte bh 28 >> put_ bh a
-    EAsPat a b c ->
-      putByte bh 29 >> put_ bh a >> put_ bh b >> put_ bh c
-    EViewPat a b c ->
-      putByte bh 30 >> put_ bh a >> put_ bh b >> put_ bh c
-    ELazyPat a b ->
-      putByte bh 31 >> put_ bh a >> put_ bh b
-    HsStatic a b ->
-      putByte bh 32 >> put_ bh a >> put_ bh b
-    HsProc a b c ->
-      putByte bh 33 >> put_ bh a >> put_ bh b >> put_ bh c
-    HsBinTick a b c d ->
-      putByte bh 34 >> put_ bh a >> put_ bh b >> put_ bh c
-                    >> put_ bh d
-    HsTickPragma a b c d e ->
-      putByte bh 35 >> put_ bh a >> put_ bh b >> put_ bh c
-                    >> put_ bh d >> put_ bh e
-    HsSpliceE a b ->
-      putByte bh 36 >> put_ bh a >> put_ bh b
-    HsSCC a b c d ->
-      putByte bh 37 >> put_ bh a >> put_ bh b >> put_ bh c
-                    >> put_ bh d
-    HsCoreAnn a b c d ->
-      putByte bh 38 >> put_ bh a >> put_ bh b >> put_ bh c
-                    >> put_ bh d
-    HsBracket a b ->
-      putByte bh 39 >> put_ bh a >> put_ bh b
-    XExpr a ->
-      putByte bh 40 >> put_ bh a
-    HsConLikeOut {} -> putPanic "HsExpr" "HsConLikeOut"
-    HsRnBracketOut {} -> putPanic "HsExpr" "HsRnBracketOut"
-    HsTcBracketOut {} -> putPanic "HsExpr" "HsTcBracketOut"
-    HsArrApp {} -> putPanic "HsExpr" "HsArrApp"
-    HsArrForm {} -> putPanic "HsExpr" "HsArrForm"
-    HsTick {} -> putPanic "HsExpr" "HsTick"
-    HsWrap {} -> putPanic "HsExpr" "HsWrap"
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0  -> HsVar <$> get bh <*> get bh
-      1  -> HsUnboundVar <$> get bh <*> get bh
-      2  -> HsRecFld <$> get bh <*> get bh
-      3  -> HsOverLabel <$> get bh <*> get bh <*> get bh
-      4  -> HsIPVar <$> get bh <*> get bh
-      5  -> HsOverLit <$> get bh <*> get bh
-      6  -> HsLit <$> get bh <*> get bh
-      7  -> HsLam <$> get bh <*> get bh
-      8  -> HsLamCase <$> get bh <*> get bh
-      9  -> HsApp <$> get bh <*> get bh <*> get bh
-      10 -> HsAppType <$> get bh <*> get bh
-      11 -> OpApp <$> get bh <*> get bh <*> get bh <*> get bh
-      12 -> NegApp <$> get bh <*> get bh <*> get bh
-      13 -> HsPar <$> get bh <*> get bh
-      14 -> SectionL <$> get bh <*> get bh <*> get bh
-      15 -> SectionR <$> get bh <*> get bh <*> get bh
-      16 -> ExplicitTuple <$> get bh <*> get bh <*> get bh
-      17 -> ExplicitSum <$> get bh <*> get bh <*> get bh <*> get bh
-      18 -> HsCase <$> get bh <*> get bh <*> get bh
-      19 -> HsIf <$> get bh <*> get bh <*> get bh <*> get bh <*> get bh
-      20 -> HsMultiIf <$> get bh <*> get bh
-      21 -> HsLet <$> get bh <*> get bh <*> get bh
-      22 -> HsDo <$> get bh <*> get bh <*> get bh
-      23 -> ExplicitList <$> get bh <*> get bh <*> get bh
-      24 -> RecordCon <$> get bh <*> get bh <*> get bh
-      25 -> RecordUpd <$> get bh <*> get bh <*> get bh
-      26 -> ExprWithTySig <$> get bh <*> get bh
-      27 -> ArithSeq <$> get bh <*> get bh <*> get bh
-      28 -> EWildPat <$> get bh
-      29 -> EAsPat <$> get bh <*> get bh <*> get bh
-      30 -> EViewPat <$> get bh <*> get bh <*> get bh
-      31 -> ELazyPat <$> get bh <*> get bh
-      32 -> HsStatic <$> get bh <*> get bh
-      33 -> HsProc <$> get bh <*> get bh <*> get bh
-      34 -> HsBinTick <$> get bh <*> get bh <*> get bh <*> get bh
-      35 -> HsTickPragma <$> get bh <*> get bh <*> get bh
-                         <*> get bh <*> get bh
-      36 -> HsSpliceE <$> get bh <*> get bh
-      37 -> HsSCC <$> get bh <*> get bh <*> get bh <*> get bh
-      38 -> HsCoreAnn <$> get bh <*> get bh <*> get bh <*> get bh
-      39 -> HsBracket <$> get bh <*> get bh
-      40 -> XExpr <$> get bh
-      _  -> getPanic "HsExpr"
-
-instance Binary (HsBracket GhcSe) where
-  put_ bh b = case b of
-    ExpBr a b ->
-      putByte bh 0 >> put_ bh a >> put_ bh b
-    PatBr a b ->
-      putByte bh 1 >> put_ bh a >> put_ bh b
-    DecBrL a b ->
-      putByte bh 2 >> put_ bh a >> put_ bh b
-    DecBrG a b ->
-      putByte bh 3 >> put_ bh a >> put_ bh b
-    TypBr a b ->
-      putByte bh 4 >> put_ bh a >> put_ bh b
-    VarBr a b c ->
-      putByte bh 5 >> put_ bh a >> put_ bh b >> put_ bh c
-    TExpBr a b ->
-      putByte bh 6 >> put_ bh a >> put_ bh b
-    XBracket a ->
-      putByte bh 7 >> put_ bh a
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> ExpBr <$> get bh <*> get bh
-      1 -> PatBr <$> get bh <*> get bh
-      2 -> DecBrL <$> get bh <*> get bh
-      3 -> DecBrG <$> get bh <*> get bh
-      4 -> TypBr <$> get bh <*> get bh
-      5 -> VarBr <$> get bh <*> get bh <*> get bh
-      6 -> TExpBr <$> get bh <*> get bh
-      7 -> XBracket <$> get bh
-      _ -> getPanic "HsBracket"
-
-instance Binary SeName where
-  put_ bh (SeName n) = put_ bh n
-  get bh = mkSeName <$> get bh
-
-instance Binary UnboundVar where
-  put_ bh v = case v of
-    OutOfScope a b -> putByte bh 0 >> put_ bh a >> put_ bh b
-    TrueExprHole a -> putByte bh 1 >> put_ bh a
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> OutOfScope <$> get bh <*> get bh
-      1 -> TrueExprHole <$> get bh
-      _ -> getPanic "UnboundVar"
-
-instance Binary a => Binary (StmtLR GhcSe GhcSe a) where
-  put_ bh s = case s of
-    LastStmt a b c d ->
-      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
-    BindStmt a b c d e ->
-      putByte bh 1 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
-                   >> put_ bh e
-    ApplicativeStmt a b c ->
-      putByte bh 2 >> put_ bh a >> put_ bh b >> put_ bh c
-    BodyStmt a b c d ->
-      putByte bh 3 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
-    LetStmt a b ->
-      putByte bh 4 >> put_ bh a >> put_ bh b
-    ParStmt a b c d ->
-      putByte bh 5 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
-    RecStmt a b c d e f g ->
-      putByte bh 6 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
-                   >> put_ bh e >> put_ bh f >> put_ bh g
-    TransStmt a b c d e f g h i ->
-      putByte bh 7 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
-                   >> put_ bh e >> put_ bh f >> put_ bh g >> put_ bh h
-                   >> put_ bh i
-    XStmtLR a ->
-      putByte bh 8 >> put_ bh a
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> LastStmt <$> get bh <*> get bh <*> get bh <*> get bh
-      1 -> BindStmt <$> get bh <*> get bh <*> get bh <*> get bh <*> get bh
-      2 -> ApplicativeStmt <$> get bh <*> get bh <*> get bh
-      3 -> BodyStmt <$> get bh <*> get bh <*> get bh <*> get bh
-      4 -> LetStmt <$> get bh <*> get bh
-      5 -> ParStmt <$> get bh <*> get bh <*> get bh <*> get bh
-      6 -> RecStmt <$> get bh <*> get bh <*> get bh <*> get bh <*> get bh
-                   <*> get bh <*> get bh
-      7 -> TransStmt <$> get bh <*> get bh <*> get bh <*> get bh
-                     <*> get bh <*> get bh <*> get bh <*> get bh
-                     <*> get bh
-      8 -> XStmtLR <$> get bh
-      _ -> getPanic "StmtLR"
-
-instance Binary (HsGroup GhcSe) where
-  put_ bh x = case x of
-    HsGroup a b c d e f g h i j k l ->
-      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
-                   >> put_ bh e >> put_ bh f >> put_ bh g >> put_ bh h
-                   >> put_ bh i >> put_ bh j >> put_ bh k >> put_ bh l
-    XHsGroup a ->
-      putByte bh 1 >> put_ bh a
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> HsGroup <$> get bh <*> get bh <*> get bh <*> get bh
-                   <*> get bh <*> get bh <*> get bh <*> get bh
-                   <*> get bh <*> get bh <*> get bh <*> get bh
-      1 -> XHsGroup <$> get bh
-      _ -> getPanic "HsGroup"
-
-instance Binary (TyClGroup GhcSe) where
-  put_ bh g = case g of
-    TyClGroup a b c d ->
-      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
-    XTyClGroup a ->
-      putByte bh 1 >> put_ bh a
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> TyClGroup <$> get bh <*> get bh <*> get bh <*> get bh
-      1 -> XTyClGroup <$> get bh
-      _ -> getPanic "TyClGroup"
-
-instance Binary (HsCmdTop GhcSe) where
-  put_ bh c = case c of
-    HsCmdTop a b ->
-      putByte bh 0 >> put_ bh a >> put_ bh b
-    XCmdTop a ->
-      putByte bh 1 >> put_ bh a
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> HsCmdTop <$> get bh <*> get bh
-      1 -> XCmdTop <$> get bh
-      _ -> getPanic "HsCmdTop"
-
-instance Binary (HsCmd GhcSe) where
-  put_ bh c = case c of
-    HsCmdArrApp a b c d e ->
-      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
-                   >> put_ bh d >> put_ bh e
-    HsCmdArrForm a b c d e ->
-      putByte bh 1 >> put_ bh a >> put_ bh b >> put_ bh c
-                   >> put_ bh d >> put_ bh e
-    HsCmdApp a b c ->
-      putByte bh 2 >> put_ bh a >> put_ bh b >> put_ bh c
-    HsCmdLam a b ->
-      putByte bh 3 >> put_ bh a >> put_ bh b
-    HsCmdPar a b ->
-      putByte bh 4 >> put_ bh a >> put_ bh b
-    HsCmdCase a b c ->
-      putByte bh 5 >> put_ bh a >> put_ bh b >> put_ bh c
-    HsCmdIf a b c d e ->
-      putByte bh 6 >> put_ bh a >> put_ bh b >> put_ bh c
-                   >> put_ bh d >> put_ bh e
-    HsCmdLet a b c ->
-      putByte bh 7 >> put_ bh a >> put_ bh b >> put_ bh c
-    HsCmdDo a b ->
-      putByte bh 8 >> put_ bh a >> put_ bh b
-    XCmd a ->
-      putByte bh 9 >> put_ bh a
-    HsCmdWrap {} ->
-      putPanic "HsCmdWrap" "HsCmd"
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> HsCmdArrApp <$> get bh <*> get bh <*> get bh
-                       <*> get bh <*> get bh
-      1 -> HsCmdArrForm <$> get bh <*> get bh <*> get bh
-                        <*> get bh <*> get bh
-      2 -> HsCmdApp <$> get bh <*> get bh <*> get bh
-      3 -> HsCmdLam <$> get bh <*> get bh
-      4 -> HsCmdPar <$> get bh <*> get bh
-      5 -> HsCmdCase <$> get bh <*> get bh <*> get bh
-      6 -> HsCmdIf <$> get bh <*> get bh <*> get bh <*> get bh <*> get bh
-      7 -> HsCmdLet <$> get bh <*> get bh <*> get bh
-      8 -> HsCmdDo <$> get bh <*> get bh
-      9 -> XCmd <$> get bh
-      _ -> getPanic "HsCmd"
-
-instance Binary HsArrAppType where
-  put_ bh t = putByte bh $ case t of
-    HsHigherOrderApp -> 0
-    HsFirstOrderApp  -> 1
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> pure HsHigherOrderApp
-      1 -> pure HsFirstOrderApp
-      _ -> getPanic "HsArrAppType"
-
-instance Binary TransForm where
-  put_ bh f = putByte bh $ case f of
-    ThenForm  -> 0
-    GroupForm -> 1
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> pure ThenForm
-      1 -> pure GroupForm
-      _ -> getPanic "TransForm"
-
-instance Binary (ApplicativeArg GhcSe) where
-  put_ bh a = case a of
-    ApplicativeArgOne a b c d ->
-      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
-    ApplicativeArgMany a b c d ->
-      putByte bh 1 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
-    XApplicativeArg a ->
-      putByte bh 2 >> put_ bh a
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> ApplicativeArgOne <$> get bh <*> get bh <*> get bh <*> get bh
-      1 -> ApplicativeArgMany <$> get bh <*> get bh <*> get bh <*> get bh
-      2 -> XApplicativeArg <$> get bh
-      _ -> getPanic "ApplicativeArg"
-
-instance Binary (ParStmtBlock GhcSe GhcSe) where
-  put_ bh b = case b of
-    ParStmtBlock a b c d ->
-      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
-    XParStmtBlock a ->
-      putByte bh 1 >> put_ bh a
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> ParStmtBlock <$> get bh <*> get bh <*> get bh <*> get bh
-      1 -> XParStmtBlock <$> get bh
-      _ -> getPanic "ParStmtBlock"
-
-instance Binary (SyntaxExpr GhcSe) where
-  put_ bh (SyntaxExpr a [] WpHole) = put_ bh a
-  put_ _ _ = panic "Binary SyntaxExpr.put: wrappers should be empty"
-  get bh = SyntaxExpr <$> get bh <*> pure [] <*> pure WpHole
-
-instance Binary a => Binary (GRHSs GhcSe a) where
-  put_ bh g = case g of
-    GRHSs a b c -> putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
-    XGRHSs a -> putByte bh 1 >> put_ bh a
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> GRHSs <$> get bh <*> get bh <*> get bh
-      1 -> XGRHSs <$> get bh
-      _ -> getPanic "GRHSs"
-
-instance Binary a => Binary (GRHS GhcSe a) where
-  put_ bh g = case g of
-    GRHS a b c -> putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
-    XGRHS a -> putByte bh 1 >> put_ bh a
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> GRHS <$> get bh <*> get bh <*> get bh
-      1 -> XGRHS <$> get bh
-      _ -> getPanic "GRHS"
-
-instance Binary a => Binary (MatchGroup GhcSe a) where
-  put_ bh g = case g of
-    MG a b c -> putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
-    XMatchGroup a -> putByte bh 1 >> put_ bh a
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> MG <$> get bh <*> get bh <*> get bh
-      1 -> XMatchGroup <$> get bh
-      _ -> getPanic "MatchGroup"
-
-instance Binary a => Binary (Match GhcSe a) where
-  put_ bh m = case m of
-    Match a b c d ->
-      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
-    XMatch a ->
-      putByte bh 1 >> put_ bh a
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> Match <$> get bh <*> get bh <*> get bh <*> get bh
-      1 -> XMatch <$> get bh
-      _ -> getPanic "Match"
-
-instance Binary (HsMatchContext SeName) where
-  put_ bh c = case c of
-    FunRhs a b c ->
-      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
-    LambdaExpr ->
-      putByte bh 1
-    CaseAlt ->
-      putByte bh 2
-    IfAlt ->
-      putByte bh 3
-    ProcExpr ->
-      putByte bh 4
-    PatBindRhs ->
-      putByte bh 5
-    RecUpd ->
-      putByte bh 6
-    StmtCtxt a ->
-      putByte bh 7 >> put_ bh a
-    ThPatSplice ->
-      putByte bh 8
-    ThPatQuote ->
-      putByte bh 9
-    PatSyn ->
-      putByte bh 10
-    PatBindGuards ->
-      putByte bh 11
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0  -> FunRhs <$> get bh <*> get bh <*> get bh
-      1  -> pure LambdaExpr
-      2  -> pure CaseAlt
-      3  -> pure IfAlt
-      4  -> pure ProcExpr
-      5  -> pure PatBindRhs
-      6  -> pure RecUpd
-      7  -> StmtCtxt <$> get bh
-      8  -> pure ThPatSplice
-      9  -> pure ThPatQuote
-      10 -> pure PatSyn
-      11 -> pure PatBindGuards
-      _  -> getPanic "HsMatchContext"
-
-instance Binary (HsStmtContext SeName) where
-  put_ bh c = case c of
-    ListComp        -> putByte bh 0
-    MonadComp       -> putByte bh 1
-    DoExpr          -> putByte bh 3
-    MDoExpr         -> putByte bh 4
-    ArrowExpr       -> putByte bh 5
-    GhciStmtCtxt    -> putByte bh 6
-    PatGuard a      -> putByte bh 7 >> put_ bh a
-    ParStmtCtxt a   -> putByte bh 8 >> put_ bh a
-    TransStmtCtxt a -> putByte bh 9 >> put_ bh a
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> pure ListComp
-      1 -> pure MonadComp
-      3 -> pure DoExpr
-      4 -> pure MDoExpr
-      5 -> pure ArrowExpr
-      6 -> pure GhciStmtCtxt
-      7 -> PatGuard <$> get bh
-      8 -> ParStmtCtxt <$> get bh
-      9 -> TransStmtCtxt <$> get bh
-      _ -> getPanic "HsStmtContext"
-
-instance Binary (ArithSeqInfo GhcSe) where
-  put_ bh i = case i of
-    From a ->
-      putByte bh 0 >> put_ bh a
-    FromThen a b ->
-      putByte bh 1 >> put_ bh a >> put_ bh b
-    FromTo a b ->
-      putByte bh 2 >> put_ bh a >> put_ bh b
-    FromThenTo a b c ->
-      putByte bh 3 >> put_ bh a >> put_ bh b >> put_ bh c
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> From <$> get bh
-      1 -> FromThen <$> get bh <*> get bh
-      2 -> FromTo <$> get bh <*> get bh
-      3 -> FromThenTo <$> get bh <*> get bh <*> get bh
-      _ -> getPanic "ArithSeqInfo"
-
-instance Binary (HsTupArg GhcSe) where
-  put_ bh a = case a of
-    Present a b -> putByte bh 0 >> put_ bh a >> put_ bh b
-    Missing a -> putByte bh 1 >> put_ bh a
-    XTupArg a -> putByte bh 2 >> put_ bh a
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> Present <$> get bh <*> get bh
-      1 -> Missing <$> get bh
-      2 -> XTupArg <$> get bh
-      _ -> getPanic "HsTupArg"
-
-instance Binary (Pat GhcSe) where
-  put_ bh p = case p of
-    WildPat a ->
-      putByte bh 0 >> put_ bh a
-    VarPat a b ->
-      putByte bh 1 >> put_ bh a >> put_ bh b
-    LazyPat a b ->
-      putByte bh 2 >> put_ bh a >> put_ bh b
-    AsPat a b c ->
-      putByte bh 3 >> put_ bh a >> put_ bh b >> put_ bh c
-    ParPat a b ->
-      putByte bh 4 >> put_ bh a >> put_ bh b
-    BangPat a b ->
-      putByte bh 5 >> put_ bh a >> put_ bh b
-    ListPat a b ->
-      putByte bh 6 >> put_ bh a >> put_ bh b
-    TuplePat a b c ->
-      putByte bh 7 >> put_ bh a >> put_ bh b >> put_ bh c
-    SumPat a b c d ->
-      putByte bh 8 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
-    ConPatIn a b ->
-      putByte bh 9 >> put_ bh a >> put_ bh b
-    ViewPat a b c ->
-      putByte bh 10 >> put_ bh a >> put_ bh b >> put_ bh c
-    LitPat a b ->
-      putByte bh 11 >> put_ bh a >> put_ bh b
-    NPat a b c d ->
-      putByte bh 12 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
-    NPlusKPat a b c d e f ->
-      putByte bh 13 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
-                    >> put_ bh e >> put_ bh f
-    SigPat a b ->
-      putByte bh 14 >> put_ bh a >> put_ bh b
-    SplicePat a b ->
-      putByte bh 15 >> put_ bh a >> put_ bh b
-    XPat a ->
-      putByte bh 16 >> put_ bh a
-    ConPatOut {} -> putPanic "Pat" "ConPatOut"
-    CoPat {} -> putPanic "Pat" "CoPat"
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> WildPat <$> get bh
-      1 -> VarPat <$> get bh <*> get bh
-      2 -> LazyPat <$> get bh <*> get bh
-      3 -> AsPat <$> get bh <*> get bh <*> get bh
-      4 -> ParPat <$> get bh <*> get bh
-      5 -> BangPat <$> get bh <*> get bh
-      6 -> ListPat <$> get bh <*> get bh
-      7 -> TuplePat <$> get bh <*> get bh <*> get bh
-      8 -> SumPat <$> get bh <*> get bh <*> get bh <*> get bh
-      9 -> ConPatIn <$> get bh <*> get bh
-      10 -> ViewPat <$> get bh <*> get bh <*> get bh
-      11 -> LitPat <$> get bh <*> get bh
-      12 -> NPat <$> get bh <*> get bh <*> get bh <*> get bh
-      13 -> NPlusKPat <$> get bh <*> get bh <*> get bh <*> get bh
-                      <*> get bh <*> get bh
-      14 -> SigPat <$> get bh <*> get bh
-      15 -> SplicePat <$> get bh <*> get bh
-      16 -> XPat <$> get bh
-      _ -> getPanic "HsPat"
-
-instance Binary NoExt where
-  put_ _ NoExt = return ()
-  get _ = pure NoExt
-
-instance (Binary (FieldOcc a), Binary b) => Binary (HsRecFields a b) where
-  put_ bh (HsRecFields a b) = put_ bh a >> put_ bh b
-  get bh = HsRecFields <$> get bh <*> get bh
-
-instance (Binary id, Binary arg) => Binary (HsRecField' id arg) where
-  put_ bh (HsRecField a b c) = put_ bh a >> put_ bh b >> put_ bh c
-  get bh = HsRecField <$> get bh <*> get bh <*> get bh
-
-instance Binary (HsType GhcSe) where
-  put_ bh t = case t of
-    HsForAllTy a b c ->
-      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
-    HsQualTy a b c ->
-      putByte bh 1 >> put_ bh a >> put_ bh b >> put_ bh c
-    HsTyVar a b c ->
-      putByte bh 2 >> put_ bh a >> put_ bh b >> put_ bh c
-    HsAppTy a b c ->
-      putByte bh 3 >> put_ bh a >> put_ bh b >> put_ bh c
-    HsFunTy a b c ->
-      putByte bh 4 >> put_ bh a >> put_ bh b >> put_ bh c
-    HsListTy a b ->
-      putByte bh 5 >> put_ bh a >> put_ bh b
-    HsTupleTy a b c ->
-      putByte bh 6 >> put_ bh a >> put_ bh b >> put_ bh c
-    HsSumTy a b ->
-      putByte bh 7 >> put_ bh a >> put_ bh b
-    HsOpTy a b c d ->
-      putByte bh 8 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
-    HsParTy a b ->
-      putByte bh 9 >> put_ bh a >> put_ bh b
-    HsIParamTy a b c ->
-      putByte bh 10 >> put_ bh a >> put_ bh b >> put_ bh c
-    HsKindSig a b c ->
-      putByte bh 11 >> put_ bh a >> put_ bh b >> put_ bh c
-    HsBangTy a b c ->
-      putByte bh 12 >> put_ bh a >> put_ bh b >> put_ bh c
-    HsRecTy a b ->
-      putByte bh 13 >> put_ bh a >> put_ bh b
-    HsExplicitListTy a b c ->
-      putByte bh 14 >> put_ bh a >> put_ bh b >> put_ bh c
-    HsExplicitTupleTy a b ->
-      putByte bh 15 >> put_ bh a >> put_ bh b
-    HsTyLit a b ->
-      putByte bh 16 >> put_ bh a >> put_ bh b
-    HsWildCardTy a ->
-      putByte bh 17 >> put_ bh a
-    HsDocTy a b c ->
-      putByte bh 18 >> put_ bh a >> put_ bh b >> put_ bh c
-    HsSpliceTy a b ->
-      putByte bh 19 >> put_ bh a >> put_ bh b
-    HsStarTy a b ->
-      putByte bh 20 >> put_ bh a >> put_ bh b
-    XHsType _ ->
-      putPanic "XHsType" "HsType"
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> HsForAllTy <$> get bh <*> get bh <*> get bh
-      1 -> HsQualTy <$> get bh <*> get bh <*> get bh
-      2 -> HsTyVar <$> get bh <*> get bh <*> get bh
-      3 -> HsAppTy <$> get bh <*> get bh <*> get bh
-      4 -> HsFunTy <$> get bh <*> get bh <*> get bh
-      5 -> HsListTy <$> get bh <*> get bh
-      6 -> HsTupleTy <$> get bh <*> get bh <*> get bh
-      7 -> HsSumTy <$> get bh <*> get bh
-      8 -> HsOpTy <$> get bh <*> get bh <*> get bh <*> get bh
-      9 -> HsParTy <$> get bh <*> get bh
-      10 -> HsIParamTy <$> get bh <*> get bh <*> get bh
-      11 -> HsKindSig <$> get bh <*> get bh <*> get bh
-      12 -> HsBangTy <$> get bh <*> get bh <*> get bh
-      13 -> HsRecTy <$> get bh <*> get bh
-      14 -> HsExplicitListTy <$> get bh <*> get bh <*> get bh
-      15 -> HsExplicitTupleTy <$> get bh <*> get bh
-      16 -> HsTyLit <$> get bh <*> get bh
-      17 -> HsWildCardTy <$> get bh
-      18 -> HsDocTy <$> get bh <*> get bh <*> get bh
-      19 -> HsSpliceTy <$> get bh <*> get bh
-      20 -> HsStarTy <$> get bh <*> get bh
-      _  -> getPanic "HsType"
-
-instance Binary HsTyLit where
-  put_ bh l = case l of
-    HsNumTy a b -> putByte bh 0 >> put_ bh a >> put_ bh b
-    HsStrTy a b -> putByte bh 1 >> put_ bh a >> put_ bh b
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> HsNumTy <$> get bh <*> get bh
-      1 -> HsStrTy <$> get bh <*> get bh
-      _ -> getPanic "HsTyLit"
-
-instance Binary a => Binary (HsWildCardBndrs GhcSe a) where
-  put_ bh w = case w of
-    HsWC a b ->
-      putByte bh 0 >> put_ bh a >> put_ bh b
-    XHsWildCardBndrs a ->
-      putByte bh 1 >> put_ bh a
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> HsWC <$> get bh <*> get bh
-      1 -> XHsWildCardBndrs <$> get bh
-      _ -> getPanic "HsWildCardBndrs"
-
-instance Binary a => Binary (HsImplicitBndrs GhcSe a) where
-  put_ bh b = case b of
-    HsIB a b ->
-      putByte bh 0 >> put_ bh a >> put_ bh b
-    XHsImplicitBndrs a ->
-      putByte bh 1 >> put_ bh a
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> HsIB <$> get bh <*> get bh
-      1 -> XHsImplicitBndrs <$> get bh
-      _ -> getPanic "HsImplicitBndrs"
-
-instance Binary HsTupleSort where
-  put_ bh s = putByte bh (case s of
-    HsUnboxedTuple -> 0
-    HsBoxedTuple -> 1
-    HsConstraintTuple -> 2
-    HsBoxedOrConstraintTuple -> 3)
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> pure HsUnboxedTuple
-      1 -> pure HsBoxedTuple
-      2 -> pure HsConstraintTuple
-      3 -> pure HsBoxedOrConstraintTuple
-      _ -> getPanic "HsTupleSort"
-
-instance Binary (ConDeclField GhcSe) where
-  put_ bh f = case f of
-    ConDeclField a b c d ->
-      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
-    XConDeclField a ->
-      putByte bh 1 >> put_ bh a
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> ConDeclField <$> get bh <*> get bh <*> get bh <*> get bh
-      1 -> XConDeclField <$> get bh
-      _ -> getPanic "ConDeclField"
-
-instance Binary (FieldOcc GhcSe) where
-  put_ bh o = case o of
-    FieldOcc a b ->
-      putByte bh 0 >> put_ bh a >> put_ bh b
-    XFieldOcc a ->
-      putByte bh 1 >> put_ bh a
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> FieldOcc <$> get bh <*> get bh
-      1 -> XFieldOcc <$> get bh
-      _ -> getPanic "FieldOcc"
-
-instance Binary (HsTyVarBndr GhcSe) where
-  put_ bh v = case v of
-    UserTyVar a b ->
-      putByte bh 0 >> put_ bh a >> put_ bh b
-    KindedTyVar a b c ->
-      putByte bh 1 >> put_ bh a >> put_ bh b >> put_ bh c
-    XTyVarBndr a ->
-      putByte bh 2 >> put_ bh a
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> UserTyVar <$> get bh <*> get bh
-      1 -> KindedTyVar <$> get bh <*> get bh <*> get bh
-      2 -> XTyVarBndr <$> get bh
-      _ -> getPanic "HsTyVarBndr"
-
-instance (Binary a, Binary b) => Binary (HsConDetails a b) where
-  put_ bh c = case c of
-    PrefixCon a -> putByte bh 0 >> put_ bh a
-    RecCon a -> putByte bh 1 >> put_ bh a
-    InfixCon a b -> putByte bh 2 >> put_ bh a >> put_ bh b
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> PrefixCon <$> get bh
-      1 -> RecCon <$> get bh
-      2 -> InfixCon <$> get bh <*> get bh
-      _ -> getPanic "HsConDetails"
-
-instance Binary (AmbiguousFieldOcc GhcSe) where
-  put_ bh o = case o of
-    Unambiguous a b ->
-      putByte bh 0 >> put_ bh a >> put_ bh b
-    Ambiguous a b ->
-      putByte bh 1 >> put_ bh a >> put_ bh b
-    XAmbiguousFieldOcc a ->
-      putByte bh 2 >> put_ bh a
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> Unambiguous <$> get bh <*> get bh
-      1 -> Ambiguous <$> get bh <*> get bh
-      2 -> XAmbiguousFieldOcc <$> get bh
-      _ -> getPanic "AmbiguousOccField"
-
-instance Binary (LHsQTyVars GhcSe) where
-  put_ bh v = case v of
-    HsQTvs a b ->
-      putByte bh 0 >> put_ bh a >> put_ bh b
-    XLHsQTyVars a ->
-      putByte bh 1 >> put_ bh a
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> HsQTvs <$> get bh <*> get bh
-      1 -> XLHsQTyVars <$> get bh
-      _ -> getPanic "LHsQTyVars"
-
-instance Binary (Sig GhcSe) where
-  put_ bh s = case s of
-    TypeSig a b c ->
-      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
-    PatSynSig a b c ->
-      putByte bh 1 >> put_ bh a >> put_ bh b >> put_ bh c
-    ClassOpSig a b c d ->
-      putByte bh 2 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
-    IdSig a b ->
-      putByte bh 3 >> put_ bh a >> put_ bh b
-    FixSig a b ->
-      putByte bh 4 >> put_ bh a >> put_ bh b
-    InlineSig a b c ->
-      putByte bh 5 >> put_ bh a >> put_ bh b >> put_ bh c
-    SpecSig a b c d ->
-      putByte bh 6 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
-    SpecInstSig a b c ->
-      putByte bh 7 >> put_ bh a >> put_ bh b >> put_ bh c
-    SCCFunSig a b c d ->
-      putByte bh 8 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
-    CompleteMatchSig a b c d ->
-      putByte bh 9 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
-    MinimalSig a b c ->
-      putByte bh 10 >> put_ bh a >> put_ bh b >> put_ bh c
-    XSig a ->
-      putByte bh 11 >> put_ bh a
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> TypeSig <$> get bh <*> get bh <*> get bh
-      1 -> PatSynSig <$> get bh <*> get bh <*> get bh
-      2 -> ClassOpSig <$> get bh <*> get bh <*> get bh <*> get bh
-      3 -> IdSig <$> get bh <*> get bh
-      4 -> FixSig <$> get bh <*> get bh
-      5 -> InlineSig <$> get bh <*> get bh <*> get bh
-      6 -> SpecSig <$> get bh <*> get bh <*> get bh <*> get bh
-      7 -> SpecInstSig <$> get bh <*> get bh <*> get bh
-      8 -> SCCFunSig <$> get bh <*> get bh <*> get bh <*> get bh
-      9 -> CompleteMatchSig <$> get bh <*> get bh <*> get bh <*> get bh
-      10 -> MinimalSig <$> get bh <*> get bh <*> get bh
-      11 -> XSig <$> get bh
-      _ -> getPanic "Sig"
-
-instance Binary (FixitySig GhcSe) where
-  put_ bh s = case s of
-    FixitySig a b c ->
-      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
-    XFixitySig a ->
-      putByte bh 1 >> put_ bh a
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> FixitySig <$> get bh <*> get bh <*> get bh
-      1 -> XFixitySig <$> get bh
-      _ -> getPanic "FixitySig"
-
-instance Binary (HsBindLR GhcSe GhcSe) where
-  put_ bh b = case b of
-    -- TODO: we drop the "fun_co_fn" field, as it seems
-    --       to always be WpHole in the places where the binary
-    --       serialisation instances will be used.
-    -- TODO: we drop the "fun_tick" field, as it is unlikely
-    --       to be used in our immediate use cases. Let's
-    --       return to parametrising away the 'Id' in that
-    --       field's type.
-    FunBind a b c d _ -> case d of
-      WpHole ->
-        putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
-      _ ->
-        panic "Binary HsBindLR: FunBind with non-WpHole value in fun_co_fn"
-    -- TODO: same as for FunBind, we drop pat_ticks
-    PatBind a b c _ ->
-      putByte bh 1 >> put_ bh a >> put_ bh b >> put_ bh c
-    VarBind a b c d ->
-      putByte bh 2 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
-    PatSynBind a b ->
-      putByte bh 3 >> put_ bh a >> put_ bh b
-    XHsBindsLR a ->
-      putByte bh 4 >> put_ bh a
-    AbsBinds {} -> putPanic "HsBindsLR" "AbsBinds"
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> FunBind <$> get bh <*> get bh <*> get bh <*> pure WpHole <*> pure []
-      1 -> PatBind <$> get bh <*> get bh <*> get bh <*> pure ([], [])
-      2 -> VarBind <$> get bh <*> get bh <*> get bh <*> get bh
-      3 -> PatSynBind <$> get bh <*> get bh
-      4 -> XHsBindsLR <$> get bh
-      _ -> getPanic "HsBindsLR"
-
-instance Binary (HsLocalBindsLR GhcSe GhcSe) where
-  put_ bh b = case b of
-    HsValBinds a b    -> putByte bh 0 >> put_ bh a >> put_ bh b
-    EmptyLocalBinds a -> putByte bh 1 >> put_ bh a
-    XHsLocalBindsLR a -> putByte bh 2 >> put_ bh a
-    HsIPBinds {}      -> putPanic "HsLocalBindsLR" "HsIPBinds"
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> HsValBinds <$> get bh <*> get bh
-      1 -> EmptyLocalBinds <$> get bh
-      2 -> XHsLocalBindsLR <$> get bh
-      _ -> getPanic "HsLocalBindsLR"
-
-instance Binary (HsValBindsLR GhcSe GhcSe) where
-  put_ bh b = case b of
-    ValBinds a b c -> putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
-    XValBindsLR {} -> putPanic "HsValBindsLR" "ValBindsOut"
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> ValBinds <$> get bh <*> get bh <*> get bh
-      _ -> getPanic "HsValBindsLR"
-
-instance Binary (PatSynBind GhcSe GhcSe) where
-  put_ bh b = case b of
-    PSB a b c d e ->
-      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
-                   >> put_ bh e
-    XPatSynBind a ->
-      putByte bh 1 >> put_ bh a
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> PSB <$> get bh <*> get bh <*> get bh <*> get bh <*> get bh
-      1 -> XPatSynBind <$> get bh
-      _ -> getPanic "PatSynBind"
-
-instance Binary (HsPatSynDir GhcSe) where
-  put_ bh d = case d of
-    Unidirectional -> putByte bh 0
-    ImplicitBidirectional -> putByte bh 1
-    ExplicitBidirectional a -> putByte bh 2 >> put_ bh a
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> pure Unidirectional
-      1 -> pure ImplicitBidirectional
-      2 -> ExplicitBidirectional <$> get bh
-      _ -> getPanic "HsPatSynDir"
-
-instance Binary a => Binary (RecordPatSynField a) where
-  put_ bh (RecordPatSynField a b) = put_ bh a >> put_ bh b
-  get bh = RecordPatSynField <$> get bh <*> get bh
-
-instance Binary (IPBind GhcSe) where
-  put_ bh i = case i of
-    IPBind a b c -> putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
-    XIPBind a -> putByte bh 1 >> put_ bh a
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> IPBind <$> get bh <*> get bh <*> get bh
-      1 -> XIPBind <$> get bh
-      _ -> getPanic "IPBind"
-
--- * HsDecls
-
-instance Binary (HsDecl GhcSe) where
-  put_ bh d = case d of
-    TyClD a b      -> putByte bh 0 >> put_ bh a >> put_ bh b
-    InstD a b      -> putByte bh 1 >> put_ bh a >> put_ bh b
-    DerivD a b     -> putByte bh 2 >> put_ bh a >> put_ bh b
-    ValD a b       -> putByte bh 3 >> put_ bh a >> put_ bh b
-    SigD a b       -> putByte bh 4 >> put_ bh a >> put_ bh b
-    DefD a b       -> putByte bh 5 >> put_ bh a >> put_ bh b
-    ForD a b       -> putByte bh 6 >> put_ bh a >> put_ bh b
-    WarningD a b   -> putByte bh 7 >> put_ bh a >> put_ bh b
-    RoleAnnotD a b -> putByte bh 8 >> put_ bh a >> put_ bh b
-    RuleD a b      -> putByte bh 9 >> put_ bh a >> put_ bh b
-    AnnD a b       -> putByte bh 10 >> put_ bh a >> put_ bh b
-    SpliceD a b    -> putByte bh 11 >> put_ bh a >> put_ bh b
-    DocD a b       -> putByte bh 12 >> put_ bh a >> put_ bh b
-    XHsDecl a      -> putByte bh 13 >> put_ bh a
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> TyClD <$> get bh <*> get bh
-      1 -> InstD <$> get bh <*> get bh
-      2 -> DerivD <$> get bh <*> get bh
-      3 -> ValD <$> get bh <*> get bh
-      4 -> SigD <$> get bh <*> get bh
-      5 -> DefD <$> get bh <*> get bh
-      6 -> ForD <$> get bh <*> get bh
-      7 -> WarningD <$> get bh <*> get bh
-      8 -> RoleAnnotD <$> get bh <*> get bh
-      9 -> RuleD <$> get bh <*> get bh
-      10 -> AnnD <$> get bh <*> get bh
-      11 -> SpliceD <$> get bh <*> get bh
-      12 -> DocD <$> get bh <*> get bh
-      13 -> XHsDecl <$> get bh
-      _ -> getPanic "HsDecl"
-
-instance Binary (ForeignDecl GhcSe) where
-  put_ bh d = case d of
-    ForeignImport a b c d ->
-      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
-                   >> put_ bh d
-    ForeignExport a b c d ->
-      putByte bh 1 >> put_ bh a >> put_ bh b >> put_ bh c
-                   >> put_ bh d
-    XForeignDecl a ->
-      putByte bh 2 >> put_ bh a
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> ForeignImport <$> get bh <*> get bh <*> get bh <*> get bh
-      1 -> ForeignExport <$> get bh <*> get bh <*> get bh <*> get bh
-      2 -> XForeignDecl <$> get bh
-      _ -> getPanic "ForeignDecl"
-
-instance Binary (DefaultDecl GhcSe) where
-  put_ bh d = case d of
-    DefaultDecl a b -> putByte bh 0 >> put_ bh a >> put_ bh b
-    XDefaultDecl a -> putByte bh 1 >> put_ bh a
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> DefaultDecl <$> get bh <*> get bh
-      1 -> XDefaultDecl <$> get bh
-      _ -> getPanic "DefaultDecl"
-
-instance Binary (TyClDecl GhcSe) where
-  put_ bh d = case d of
-    FamDecl a b ->
-      putByte bh 0 >> put_ bh a >> put_ bh b
-    SynDecl a b c d e ->
-      putByte bh 1 >> put_ bh a >> put_ bh b >> put_ bh c
-                   >> put_ bh d >> put_ bh e
-    DataDecl a b c d e ->
-      putByte bh 2 >> put_ bh a >> put_ bh b >> put_ bh c
-                   >> put_ bh d >> put_ bh e
-    ClassDecl a b c d e f g h i j k ->
-      putByte bh 3 >> put_ bh a >> put_ bh b >> put_ bh c
-                   >> put_ bh d >> put_ bh e >> put_ bh f
-                   >> put_ bh g >> put_ bh h >> put_ bh i
-                   >> put_ bh j >> put_ bh k
-    XTyClDecl a ->
-      putByte bh 4 >> put_ bh a
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> FamDecl <$> get bh <*> get bh
-      1 -> SynDecl <$> get bh <*> get bh <*> get bh <*> get bh <*> get bh
-      2 -> DataDecl <$> get bh <*> get bh <*> get bh <*> get bh <*> get bh
-      3 -> ClassDecl <$> get bh <*> get bh <*> get bh <*> get bh <*> get bh
-                     <*> get bh <*> get bh <*> get bh <*> get bh <*> get bh
-                     <*> get bh
-      4 -> XTyClDecl <$> get bh
-      _ -> getPanic "TyClDecl"
-
-instance Binary DocDecl where
-  put_ bh d = case d of
-    DocCommentNext a    -> putByte bh 0 >> put_ bh a
-    DocCommentPrev a    -> putByte bh 1 >> put_ bh a
-    DocCommentNamed a b -> putByte bh 2 >> put_ bh a >> put_ bh b
-    DocGroup a b        -> putByte bh 3 >> put_ bh a >> put_ bh b
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> DocCommentNext <$> get bh
-      1 -> DocCommentPrev <$> get bh
-      2 -> DocCommentNamed <$> get bh <*> get bh
-      3 -> DocGroup <$> get bh <*> get bh
-      _ -> getPanic "DocDecl"
-
-instance Binary (WarnDecls GhcSe) where
-  put_ bh d = case d of
-    Warnings a b c -> putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
-    XWarnDecls a   -> putByte bh 1 >> put_ bh a
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> Warnings <$> get bh <*> get bh <*> get bh
-      1 -> XWarnDecls <$> get bh
-      _ -> getPanic "WarnDecls"
-
-instance Binary (WarnDecl GhcSe) where
-  put_ bh d = case d of
-    Warning a b c -> putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
-    XWarnDecl a   -> putByte bh 1 >> put_ bh a
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> Warning <$> get bh <*> get bh <*> get bh
-      1 -> XWarnDecl <$> get bh
-      _ -> getPanic "WarnDecl"
-
-instance Binary (RoleAnnotDecl GhcSe) where
-  put_ bh d = case d of
-    RoleAnnotDecl a b c -> putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
-    XRoleAnnotDecl a    -> putByte bh 1 >> put_ bh a
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> RoleAnnotDecl <$> get bh <*> get bh <*> get bh
-      1 -> XRoleAnnotDecl <$> get bh
-      _ -> getPanic "RoleAnnotDecl"
-
-instance Binary (RuleDecls GhcSe) where
-  put_ bh d = case d of
-    HsRules a b c -> putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
-    XRuleDecls a  -> putByte bh 1 >> put_ bh a
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> HsRules <$> get bh <*> get bh <*> get bh
-      1 -> XRuleDecls <$> get bh
-      _ -> getPanic "RuleDecls"
-
-instance Binary (RuleDecl GhcSe) where
-  put_ bh decl = case decl of
-    HsRule a b c d e f ->
-      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
-                   >> put_ bh e >> put_ bh f
-    XRuleDecl a ->
-      putByte bh 1 >> put_ bh a
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> HsRule <$> get bh <*> get bh <*> get bh <*> get bh
-                  <*> get bh <*> get bh
-      1 -> XRuleDecl <$> get bh
-      _ -> getPanic "RuleDecl"
-
-instance Binary (AnnDecl GhcSe) where
-  put_ bh decl = case decl of
-    HsAnnotation a b c d ->
-      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
-    XAnnDecl a ->
-      putByte bh 1 >> put_ bh a
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> HsAnnotation <$> get bh <*> get bh <*> get bh <*> get bh
-      1 -> XAnnDecl <$> get bh
-      _ -> getPanic "AnnDecl"
-
-instance Binary (SpliceDecl GhcSe) where
-  put_ bh d = case d of
-    SpliceDecl a b c -> putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
-    XSpliceDecl a    -> putByte bh 1 >> put_ bh a
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> SpliceDecl <$> get bh <*> get bh <*> get bh
-      1 -> XSpliceDecl <$> get bh
-      _ -> getPanic "SpliceDecl"
-
-instance Binary a => Binary (Tickish a) where
-  put_ bh t = case t of
-    ProfNote a b c ->
-      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
-    HpcTick a b ->
-      putByte bh 1 >> put_ bh a >> put_ bh b
-    Breakpoint a b ->
-      putByte bh 2 >> put_ bh a >> put_ bh b
-    SourceNote a b ->
-      putByte bh 3 >> put_ bh a >> put_ bh b
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> ProfNote <$> get bh <*> get bh <*> get bh
-      1 -> HpcTick <$> get bh <*> get bh
-      2 -> Breakpoint <$> get bh <*> get bh
-      3 -> SourceNote <$> get bh <*> get bh
-      _ -> getPanic "Tickish"
-
-instance Binary SpliceExplicitFlag where
-  put_ bh f = putByte bh $ case f of
-    ExplicitSplice -> 0
-    ImplicitSplice -> 1
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> pure ExplicitSplice
-      1 -> pure ImplicitSplice
-      _ -> getPanic "SpliceExplicitFlag"
-
-instance Binary SpliceDecoration where
-  put_ bh d = putByte bh $ case d of
-    HasParens -> 0
-    HasDollar -> 1
-    NoParens  -> 2
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> pure HasParens
-      1 -> pure HasDollar
-      2 -> pure NoParens
-      _ -> getPanic "SpliceDecoration"
-
-instance Binary (HsSplice GhcSe) where
-  put_ bh s = case s of
-    HsTypedSplice a b c d ->
-      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
-    HsUntypedSplice a b c d ->
-      putByte bh 1 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
-    HsQuasiQuote a b c d e ->
-      putByte bh 2 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
-                   >> put_ bh e
-    XSplice a ->
-      putByte bh 3 >> put_ bh a
-    HsSpliced {} -> putPanic "HsSplice" "HsSpliced"
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> HsTypedSplice <$> get bh <*> get bh <*> get bh <*> get bh
-      1 -> HsUntypedSplice <$> get bh <*> get bh <*> get bh <*> get bh
-      2 -> HsQuasiQuote <$> get bh <*> get bh <*> get bh <*> get bh
-                        <*> get bh
-      3 -> XSplice <$> get bh
-      _ -> getPanic "HsSplice"
-
-instance Binary (AnnProvenance SeName) where
-  put_ bh p = case p of
-    ValueAnnProvenance a -> putByte bh 0 >> put_ bh a
-    TypeAnnProvenance a -> putByte bh 1 >> put_ bh a
-    ModuleAnnProvenance -> putByte bh 2
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> ValueAnnProvenance <$> get bh
-      1 -> TypeAnnProvenance <$> get bh
-      2 -> pure ModuleAnnProvenance
-      _ -> getPanic "AnnProvenance"
-
-instance Binary ForeignImport where
-  put_ bh (CImport a b c d e) =
-    put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
-              >> put_ bh e
-  get bh = CImport <$> get bh <*> get bh <*> get bh
-                   <*> get bh <*> get bh
-
-instance Binary CImportSpec where
-  put_ bh s = case s of
-    CLabel a -> putByte bh 0 >> put_ bh a
-    CFunction a -> putByte bh 1 >> put_ bh a
-    CWrapper -> putByte bh 2
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> CLabel <$> get bh
-      1 -> CFunction <$> get bh
-      2 -> pure CWrapper
-      _ -> getPanic "CImportSpec"
-
-instance Binary ForeignExport where
-  put_ bh (CExport a b) = put_ bh a >> put_ bh b
-  get bh = CExport <$> get bh <*> get bh
-
-instance Binary (RuleBndr GhcSe) where
-  put_ bh b = case b of
-    RuleBndr a b ->
-      putByte bh 0 >> put_ bh a >> put_ bh b
-    RuleBndrSig a b c ->
-      putByte bh 1 >> put_ bh a >> put_ bh b >> put_ bh c
-    XRuleBndr a ->
-      putByte bh 2 >> put_ bh a
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> RuleBndr <$> get bh <*> get bh
-      1 -> RuleBndrSig <$> get bh <*> get bh <*> get bh
-      2 -> XRuleBndr <$> get bh
-      _ -> getPanic "RuleBndr"
-
-instance (Binary a, Binary b) => Binary (FamEqn GhcSe a b) where
-  put_ bh e = case e of
-    FamEqn a b c d e ->
-      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
-                   >> put_ bh e
-    XFamEqn a ->
-      putByte bh 1 >> put_ bh a
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> FamEqn <$> get bh <*> get bh <*> get bh <*> get bh
-                  <*> get bh
-      1 -> XFamEqn <$> get bh
-      _ -> getPanic "FamEqn"
-
-instance Binary (HsDataDefn GhcSe) where
-  put_ bh d = case d of
-    HsDataDefn a b c d e f g ->
-      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
-                   >> put_ bh e >> put_ bh f >> put_ bh g
-    XHsDataDefn a ->
-      putByte bh 1 >> put_ bh a
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> HsDataDefn <$> get bh <*> get bh <*> get bh <*> get bh
-                      <*> get bh <*> get bh <*> get bh
-      1 -> XHsDataDefn <$> get bh
-      _ -> getPanic "HsDataDefn"
-
-instance Binary NewOrData where
-  put_ bh a = putByte bh (case a of
-    NewType  -> 0
-    DataType -> 1)
-  get bh = getByte bh >>= \b -> case b of
-    0 -> pure NewType
-    1 -> pure DataType
-    _ -> getPanic "NewOrData"
-
-instance Binary (HsDerivingClause GhcSe) where
-  put_ bh c = case c of
-    HsDerivingClause a b c ->
-      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
-    XHsDerivingClause a ->
-      putByte bh 1 >> put_ bh a
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> HsDerivingClause <$> get bh <*> get bh <*> get bh
-      1 -> XHsDerivingClause <$> get bh
-      _ -> getPanic "HsDerivingClause"
-
-instance Binary (ConDecl GhcSe) where
-  put_ bh d = case d of
-    ConDeclGADT a b c d e f g h ->
-      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
-                   >> put_ bh e >> put_ bh f >> put_ bh g >> put_ bh h
-    ConDeclH98 a b c d e f g ->
-      putByte bh 1 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
-                   >> put_ bh e >> put_ bh f >> put_ bh g
-    XConDecl a ->
-      putByte bh 2 >> put_ bh a
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> ConDeclGADT <$> get bh <*> get bh <*> get bh <*> get bh
-                       <*> get bh <*> get bh <*> get bh <*> get bh
-      1 -> ConDeclH98 <$> get bh <*> get bh <*> get bh <*> get bh
-                      <*> get bh <*> get bh <*> get bh
-      2 -> XConDecl <$> get bh
-      _ -> getPanic "ConDecl"
-
-
-instance Binary (FamilyDecl GhcSe) where
-  put_ bh d = case d of
-    FamilyDecl a b c d e f g ->
-      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
-                   >> put_ bh e >> put_ bh f >> put_ bh g
-    XFamilyDecl a ->
-      putByte bh 1 >> put_ bh a
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> FamilyDecl <$> get bh <*> get bh <*> get bh <*> get bh
-                      <*> get bh <*> get bh <*> get bh
-      1 -> XFamilyDecl <$> get bh
-      _ -> getPanic "FamilyDecl"
-
-instance Binary (InjectivityAnn GhcSe) where
-  put_ bh a = case a of
-    InjectivityAnn a b -> put_ bh a >> put_ bh b
-  get bh = InjectivityAnn <$> get bh <*> get bh
-
-instance Binary (FamilyInfo GhcSe) where
-  put_ bh i = case i of
-    DataFamily ->
-      putByte bh 0
-    OpenTypeFamily ->
-      putByte bh 1
-    ClosedTypeFamily a ->
-      putByte bh 2 >> put_ bh a
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> pure DataFamily
-      1 -> pure OpenTypeFamily
-      2 -> ClosedTypeFamily <$> get bh
-      _ -> getPanic "FamilyInfo"
-
-instance Binary (FamilyResultSig GhcSe) where
-  put_ bh s = case s of
-    NoSig a ->
-      putByte bh 0 >> put_ bh a
-    KindSig a b ->
-      putByte bh 1 >> put_ bh a >> put_ bh b
-    TyVarSig a b ->
-      putByte bh 2 >> put_ bh a >> put_ bh b
-    XFamilyResultSig a ->
-      putByte bh 3 >> put_ bh a
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> NoSig <$> get bh
-      1 -> KindSig <$> get bh <*> get bh
-      2 -> TyVarSig <$> get bh <*> get bh
-      3 -> XFamilyResultSig <$> get bh
-      _ -> getPanic "FamilyResultSig"
-
-instance Binary (InstDecl GhcSe) where
-  put_ bh d = case d of
-    ClsInstD a b ->
-      putByte bh 0 >> put_ bh a >> put_ bh b
-    DataFamInstD a b ->
-      putByte bh 1 >> put_ bh a >> put_ bh b
-    TyFamInstD a b ->
-      putByte bh 2 >> put_ bh a >> put_ bh b
-    XInstDecl a ->
-      putByte bh 3 >> put_ bh a
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> ClsInstD <$> get bh <*> get bh
-      1 -> DataFamInstD <$> get bh <*> get bh
-      2 -> TyFamInstD <$> get bh <*> get bh
-      3 -> XInstDecl <$> get bh
-      _ -> getPanic "InstDecl"
-
-instance Binary (ClsInstDecl GhcSe) where
-  put_ bh d = case d of
-    ClsInstDecl a b c d e f g ->
-      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
-                   >> put_ bh e >> put_ bh f >> put_ bh g
-    XClsInstDecl a ->
-      putByte bh 1 >> put_ bh a
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> ClsInstDecl <$> get bh <*> get bh <*> get bh <*> get bh
-                       <*> get bh <*> get bh <*> get bh
-      1 -> XClsInstDecl <$> get bh
-      _ -> getPanic "ClsInstDecl"
-
-instance Binary (DataFamInstDecl GhcSe) where
-  put_ bh (DataFamInstDecl a) = put_ bh a
-  get bh = DataFamInstDecl <$> get bh
-
-instance Binary (TyFamInstDecl GhcSe) where
-  put_ bh (TyFamInstDecl a) = put_ bh a
-  get bh = TyFamInstDecl <$> get bh
-
-instance Binary (DerivDecl GhcSe) where
-  put_ bh d = case d of
-    DerivDecl a b c d ->
-      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
-    XDerivDecl a ->
-      putByte bh 1 >> put_ bh a
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> DerivDecl <$> get bh <*> get bh <*> get bh <*> get bh
-      1 -> XDerivDecl <$> get bh
-      _ -> getPanic "DerivDecl"
-
-instance Binary (DerivStrategy GhcSe) where
-  put_ bh s = case s of
-    StockStrategy    -> putByte bh 0
-    AnyclassStrategy -> putByte bh 1
-    NewtypeStrategy  -> putByte bh 2
-    ViaStrategy a    -> putByte bh 3 >> put_ bh a
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> pure StockStrategy
-      1 -> pure AnyclassStrategy
-      2 -> pure NewtypeStrategy
-      3 -> ViaStrategy <$> get bh
-      _ -> getPanic "DerivStrategy"
-
-instance Binary HsSrcBang where
-  put_ bh (HsSrcBang a b c) =
-    put_ bh a >> put_ bh b >> put_ bh c
-  get bh = HsSrcBang <$> get bh <*> get bh <*> get bh
-
-instance Binary RdrName where
-  put_ bh n = case n of
-    Unqual a -> putByte bh 0 >> put_ bh a
-    Qual a b -> putByte bh 1 >> put_ bh a >> put_ bh b
-    Orig a b -> putByte bh 2 >> put_ bh a >> put_ bh b
-    Exact a
-      | isExternalName a -> putByte bh 3 >> put_ bh a
-      | otherwise -> putByte bh (if isSystemName a then 4 else 5)
-          >> put_ bh (nameUnique a) >> put_ bh (nameOccName a)
-          >> put_ bh (nameSrcSpan a)
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> Unqual <$> get bh
-      1 -> Qual <$> get bh <*> get bh
-      2 -> Orig <$> get bh <*> get bh
-      3 -> Exact <$> get bh
-      4 -> fmap Exact (mkSystemNameAt <$> get bh <*> get bh <*> get bh)
-      5 -> fmap Exact (mkInternalName <$> get bh <*> get bh <*> get bh)
-      _ -> getPanic "RdrName"
-
--- * HsLit
-
-instance Binary (HsLit GhcSe) where
-  put_ bh lit
-    = case lit of
-        HsChar a b       -> putByte bh 0  >> put_ bh a >> put_ bh b
-        HsCharPrim a b   -> putByte bh 1  >> put_ bh a >> put_ bh b
-        HsString a b     -> putByte bh 2  >> put_ bh a >> put_ bh b
-        HsStringPrim a b -> putByte bh 3  >> put_ bh a >> put_ bh b
-        HsInt a b        -> putByte bh 4  >> put_ bh a >> put_ bh b
-        HsIntPrim a b    -> putByte bh 5  >> put_ bh a >> put_ bh b
-        HsWordPrim a b   -> putByte bh 6  >> put_ bh a >> put_ bh b
-        HsInt64Prim a b  -> putByte bh 7  >> put_ bh a >> put_ bh b
-        HsWord64Prim a b -> putByte bh 8  >> put_ bh a >> put_ bh b
-        HsInteger a b c  -> putByte bh 9  >> put_ bh a >> put_ bh b >> put_ bh c
-        HsRat a b c      -> putByte bh 10 >> put_ bh a >> put_ bh b >> put_ bh c
-        HsFloatPrim a b  -> putByte bh 11 >> put_ bh a >> put_ bh b
-        HsDoublePrim a b -> putByte bh 12 >> put_ bh a >> put_ bh b
-        XLit a           -> putByte bh 13 >> put_ bh a
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0  -> HsChar       <$> get bh <*> get bh
-      1  -> HsCharPrim   <$> get bh <*> get bh
-      2  -> HsString     <$> get bh <*> get bh
-      3  -> HsStringPrim <$> get bh <*> get bh
-      4  -> HsInt        <$> get bh <*> get bh
-      5  -> HsIntPrim    <$> get bh <*> get bh
-      6  -> HsWordPrim   <$> get bh <*> get bh
-      7  -> HsInt64Prim  <$> get bh <*> get bh
-      8  -> HsWord64Prim <$> get bh <*> get bh
-      9  -> HsInteger    <$> get bh <*> get bh <*> get bh
-      10 -> HsRat        <$> get bh <*> get bh <*> get bh
-      11 -> HsFloatPrim  <$> get bh <*> get bh
-      12 -> HsDoublePrim <$> get bh <*> get bh
-      13 -> XLit         <$> get bh
-      _ -> getPanic "HsLit"
-
-instance Binary (HsOverLit GhcSe) where
-  put_ bh lit = case lit of
-    OverLit a b c -> putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
-    XOverLit a    -> putByte bh 1 >> put_ bh a
-
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> OverLit <$> get bh <*> get bh <*> get bh
-      1 -> XOverLit <$> get bh
-      _ -> getPanic "HsOverLit"
-
-instance Binary Promoted where
-  get bh = getByte bh >>= \tag -> case tag of
-    0 -> pure Promoted
-    1 -> pure NotPromoted
-    _ -> getPanic "Promoted"
-
-  put_ bh p = putByte bh $ case p of
-    Promoted -> 0
-    NotPromoted -> 1
-
-instance Binary RealSrcLoc where
-  put_ bh l = do
-    put_ bh (srcLocFile l)
-    put_ bh (srcLocLine l)
-    put_ bh (srcLocCol l)
-
-  get bh = mkRealSrcLoc <$> get bh <*> get bh <*> get bh
-
-instance Binary RealSrcSpan where
-  put_ bh s = put_ bh (realSrcSpanStart s) >> put_ bh (realSrcSpanEnd s)
-
-  get bh = do
-    loc1 <- get bh
-    loc2 <- get bh
-    return (mkRealSrcSpan loc1 loc2)
-
-instance Binary OverLitVal where
-  put_ bh v
-    = case v of
-        HsIntegral a   -> putByte bh 0 >> put_ bh a
-        HsFractional a -> putByte bh 1 >> put_ bh a
-        HsIsString a b -> putByte bh 2 >> put_ bh a >> put_ bh b
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> HsIntegral <$> get bh
-      1 -> HsFractional <$> get bh
-      2 -> HsIsString <$> get bh <*> get bh
-      _ -> getPanic "OverLitVal"
diff --git a/compiler/hsSyn/HsExtension.hs b/compiler/hsSyn/HsExtension.hs
index a488da00a7..a7c467dce4 100644
--- a/compiler/hsSyn/HsExtension.hs
+++ b/compiler/hsSyn/HsExtension.hs
@@ -23,15 +23,10 @@ import Data.Data hiding ( Fixity )
 import PlaceHolder
 import Name
 import RdrName
-import SeName
 import Var
-import IfaceType  ( IfaceType )
 import Outputable
 import SrcLoc (Located)
 
-import Data.Kind
-import qualified Type
-
 {-
 Note [Trees that grow]
 ~~~~~~~~~~~~~~~~~~~~~~
@@ -73,22 +68,20 @@ data GhcPass (c :: Pass)
 deriving instance Eq (GhcPass c)
 deriving instance Typeable c => Data (GhcPass c)
 
-data Pass = Parsed | Renamed | Typechecked | Serialisable
+data Pass = Parsed | Renamed | Typechecked
          deriving (Data)
 
 -- Type synonyms as a shorthand for tagging
-type GhcPs   = GhcPass 'Parsed       -- Old 'RdrName' type param
-type GhcRn   = GhcPass 'Renamed      -- Old 'Name' type param
-type GhcTc   = GhcPass 'Typechecked  -- Old 'Id' type para,
-type GhcSe   = GhcPass 'Serialisable -- New pass, with serialisable AST representations
-type GhcTcId = GhcTc                 -- Old 'TcId' type param
+type GhcPs   = GhcPass 'Parsed      -- Old 'RdrName' type param
+type GhcRn   = GhcPass 'Renamed     -- Old 'Name' type param
+type GhcTc   = GhcPass 'Typechecked -- Old 'Id' type para,
+type GhcTcId = GhcTc                -- Old 'TcId' type param
 
 -- | Maps the "normal" id type for a given pass
 type family IdP p
 type instance IdP GhcPs = RdrName
 type instance IdP GhcRn = Name
 type instance IdP GhcTc = Id
-type instance IdP GhcSe = SeName
 
 type LIdP p = Located (IdP p)
 
@@ -1112,34 +1105,4 @@ type OutputableBndrId id =
   ( OutputableBndr (NameOrRdrName (IdP id))
   , OutputableBndr (IdP id)
   , OutputableX id
-  , OutputableBndr (RdrOrSeName id)
-  , OutputableBndr (IdSigId id)
-  , VarType (IdSigId id)
   )
-
-class VarType a where
-  getVarType :: a -> Maybe Type.Type
-
-instance VarType Var where
-  getVarType = Just . varType
-
-instance VarType SeName where
-  getVarType _ = Nothing
-
-type family IdSigId pass where
-  IdSigId GhcSe       = SeName
-  IdSigId (GhcPass _) = Id
-
-type family LitType x where
-  LitType (GhcPass 'Serialisable) = IfaceType
-  LitType                       a = Type.Type
-
-type family DoName pass where
-  DoName GhcSe = SeName
-  DoName (GhcPass _) = Name
-
-type family RdrOrSeName pass
-type instance RdrOrSeName GhcSe = SeName
-type instance RdrOrSeName GhcRn = RdrName
-type instance RdrOrSeName GhcTc = RdrName
-type instance RdrOrSeName GhcPs = RdrName
diff --git a/compiler/hsSyn/HsImpExp.hs b/compiler/hsSyn/HsImpExp.hs
index 9da47f62f1..39bd9b7e18 100644
--- a/compiler/hsSyn/HsImpExp.hs
+++ b/compiler/hsSyn/HsImpExp.hs
@@ -12,7 +12,6 @@ HsImpExp: Abstract syntax: imports, exports, interfaces
 {-# LANGUAGE TypeFamilies #-}
 {-# LANGUAGE UndecidableInstances #-} -- Note [Pass sensitive types]
                                       -- in module PlaceHolder
-{-# LANGUAGE TypeFamilies #-}
 
 module HsImpExp where
 
diff --git a/compiler/hsSyn/HsLit.hs b/compiler/hsSyn/HsLit.hs
index 9546b0de30..d1411bd750 100644
--- a/compiler/hsSyn/HsLit.hs
+++ b/compiler/hsSyn/HsLit.hs
@@ -13,7 +13,7 @@
                                       -- in module PlaceHolder
 {-# LANGUAGE ConstraintKinds #-}
 {-# LANGUAGE TypeFamilies #-}
-{-# LANGUAGE DataKinds #-}
+
 module HsLit where
 
 #include "HsVersions.h"
@@ -63,11 +63,11 @@ data HsLit x
       -- ^ literal @Int64#@
   | HsWord64Prim (XHsWord64Prim x) {- SourceText -} Integer
       -- ^ literal @Word64#@
-  | HsInteger (XHsInteger x) {- SourceText -} Integer (LitType x)
+  | HsInteger (XHsInteger x) {- SourceText -} Integer Type
       -- ^ Genuinely an integer; arises only
       -- from TRANSLATION (overloaded
       -- literals are done with HsOverLit)
-  | HsRat (XHsRat x)  FractionalLit (LitType x)
+  | HsRat (XHsRat x)  FractionalLit Type
       -- ^ Genuinely a rational; arises only from
       -- TRANSLATION (overloaded literals are
       -- done with HsOverLit)
@@ -128,7 +128,6 @@ data OverLitTc
 type instance XOverLit GhcPs = NoExt
 type instance XOverLit GhcRn = Bool            -- Note [ol_rebindable]
 type instance XOverLit GhcTc = OverLitTc
-type instance XOverLit GhcSe = NoExt
 
 type instance XXOverLit (GhcPass _) = NoExt
 
@@ -152,7 +151,7 @@ overLitType XOverLit{} = panic "overLitType"
 
 -- | Convert a literal from one index type to another, updating the annotations
 -- according to the relevant 'Convertable' instance
-convertLit :: (ConvertIdX a b, LitType a ~ LitType b) => HsLit a -> HsLit b
+convertLit :: (ConvertIdX a b) => HsLit a -> HsLit b
 convertLit (HsChar a x)       = (HsChar (convert a) x)
 convertLit (HsCharPrim a x)   = (HsCharPrim (convert a) x)
 convertLit (HsString a x)     = (HsString (convert a) x)
diff --git a/compiler/hsSyn/HsPat.hs b/compiler/hsSyn/HsPat.hs
index aa7e9989a2..6f65487411 100644
--- a/compiler/hsSyn/HsPat.hs
+++ b/compiler/hsSyn/HsPat.hs
@@ -282,7 +282,6 @@ data ListPatTc
 type instance XWildPat GhcPs = NoExt
 type instance XWildPat GhcRn = NoExt
 type instance XWildPat GhcTc = Type
-type instance XWildPat GhcSe = NoExt
 
 type instance XVarPat  (GhcPass _) = NoExt
 type instance XLazyPat (GhcPass _) = NoExt
@@ -296,22 +295,18 @@ type instance XBangPat (GhcPass _) = NoExt
 type instance XListPat GhcPs = NoExt
 type instance XListPat GhcRn = Maybe (SyntaxExpr GhcRn)
 type instance XListPat GhcTc = ListPatTc
-type instance XListPat GhcSe = NoExt
 
 type instance XTuplePat GhcPs = NoExt
 type instance XTuplePat GhcRn = NoExt
 type instance XTuplePat GhcTc = [Type]
-type instance XTuplePat GhcSe = NoExt
 
 type instance XSumPat GhcPs = NoExt
 type instance XSumPat GhcRn = NoExt
 type instance XSumPat GhcTc = [Type]
-type instance XSumPat GhcSe = NoExt
 
 type instance XViewPat GhcPs = NoExt
 type instance XViewPat GhcRn = NoExt
 type instance XViewPat GhcTc = Type
-type instance XViewPat GhcSe = NoExt
 
 type instance XSplicePat (GhcPass _) = NoExt
 type instance XLitPat    (GhcPass _) = NoExt
@@ -319,17 +314,14 @@ type instance XLitPat    (GhcPass _) = NoExt
 type instance XNPat GhcPs = NoExt
 type instance XNPat GhcRn = NoExt
 type instance XNPat GhcTc = Type
-type instance XNPat GhcSe = NoExt
 
 type instance XNPlusKPat GhcPs = NoExt
 type instance XNPlusKPat GhcRn = NoExt
 type instance XNPlusKPat GhcTc = Type
-type instance XNPlusKPat GhcSe = NoExt
 
 type instance XSigPat GhcPs = (LHsSigWcType GhcPs)
 type instance XSigPat GhcRn = (LHsSigWcType GhcRn)
 type instance XSigPat GhcTc = Type
-type instance XSigPat GhcSe = (LHsSigWcType GhcSe)
 
 type instance XCoPat  (GhcPass _) = NoExt
 type instance XXPat   (GhcPass _) = NoExt
@@ -465,9 +457,7 @@ hsRecFieldSel = fmap extFieldOcc . hsRecFieldLbl
 hsRecFieldId :: HsRecField GhcTc arg -> Located Id
 hsRecFieldId = hsRecFieldSel
 
-hsRecUpdFieldRdr
-  :: RdrOrSeName (GhcPass p) ~ RdrName
-  => HsRecUpdField (GhcPass p) -> Located RdrName
+hsRecUpdFieldRdr :: HsRecUpdField (GhcPass p) -> Located RdrName
 hsRecUpdFieldRdr = fmap rdrNameAmbiguousFieldOcc . hsRecFieldLbl
 
 hsRecUpdFieldId :: HsRecField' (AmbiguousFieldOcc GhcTc) arg -> Located Id
@@ -567,7 +557,7 @@ pprConArgs (InfixCon p1 p2) = sep [ pprParendLPat appPrec p1
                                   , pprParendLPat appPrec p2 ]
 pprConArgs (RecCon rpats)   = ppr rpats
 
-instance (Outputable arg, Outputable (RdrOrSeName p))
+instance (Outputable arg)
       => Outputable (HsRecFields p arg) where
   ppr (HsRecFields { rec_flds = flds, rec_dotdot = Nothing })
         = braces (fsep (punctuate comma (map ppr flds)))
diff --git a/compiler/hsSyn/HsPat.hs-boot b/compiler/hsSyn/HsPat.hs-boot
index d56a992207..b7efb1c28c 100644
--- a/compiler/hsSyn/HsPat.hs-boot
+++ b/compiler/hsSyn/HsPat.hs-boot
@@ -4,7 +4,7 @@
                                       -- in module PlaceHolder
 {-# LANGUAGE ConstraintKinds #-}
 {-# LANGUAGE RoleAnnotations #-}
-{-# LANGUAGE TypeFamilies #-} -- needed to use OutputableBndrId
+{-# LANGUAGE TypeFamilies #-}
 
 module HsPat where
 import SrcLoc( Located )
diff --git a/compiler/hsSyn/HsTypes.hs b/compiler/hsSyn/HsTypes.hs
index 2366df1d28..3512bf7a7c 100644
--- a/compiler/hsSyn/HsTypes.hs
+++ b/compiler/hsSyn/HsTypes.hs
@@ -9,7 +9,6 @@ HsTypes: Abstract syntax: user-defined types
 {-# LANGUAGE DeriveDataTypeable #-}
 {-# LANGUAGE FlexibleContexts #-}
 {-# LANGUAGE StandaloneDeriving #-}
-{-# LANGUAGE TypeFamilies #-}
 {-# LANGUAGE TypeSynonymInstances #-}
 {-# LANGUAGE UndecidableInstances #-} -- Note [Pass sensitive types]
                                       -- in module PlaceHolder
@@ -39,7 +38,7 @@ module HsTypes (
 
         HsConDetails(..),
 
-        FieldOcc(..), LFieldOcc, mkFieldOcc, fieldOccRdrName,
+        FieldOcc(..), LFieldOcc, mkFieldOcc,
         AmbiguousFieldOcc(..), mkAmbiguousFieldOcc,
         rdrNameAmbiguousFieldOcc, selectorAmbiguousFieldOcc,
         unambiguousFieldOcc, ambiguousFieldOcc,
@@ -86,7 +85,6 @@ import TysPrim( funTyConName )
 import Type
 import HsDoc
 import BasicTypes
-import Binary
 import SrcLoc
 import Outputable
 import FastString
@@ -279,7 +277,6 @@ data HsQTvsRn
 type instance XHsQTvs       GhcPs = NoExt
 type instance XHsQTvs       GhcRn = HsQTvsRn
 type instance XHsQTvs       GhcTc = HsQTvsRn
-type instance XHsQTvs       GhcSe = NoExt
 
 type instance XXLHsQTyVars  (GhcPass _) = NoExt
 
@@ -319,7 +316,6 @@ data HsIBRn
 type instance XHsIB              GhcPs _ = NoExt
 type instance XHsIB              GhcRn _ = HsIBRn
 type instance XHsIB              GhcTc _ = HsIBRn
-type instance XHsIB              GhcSe _ = NoExt
 
 type instance XXHsImplicitBndrs  (GhcPass _) _ = NoExt
 
@@ -341,7 +337,6 @@ data HsWildCardBndrs pass thing
 type instance XHsWC              GhcPs b = NoExt
 type instance XHsWC              GhcRn b = [Name]
 type instance XHsWC              GhcTc b = [Name]
-type instance XHsWC              GhcSe b = NoExt
 
 type instance XXHsWildCardBndrs  (GhcPass _) b = NoExt
 
@@ -420,10 +415,6 @@ newtype HsIPName = HsIPName FastString
 hsIPNameFS :: HsIPName -> FastString
 hsIPNameFS (HsIPName n) = n
 
-instance Binary HsIPName where
-  put_ bh (HsIPName s) = put_ bh s
-  get bh = HsIPName <$> get bh
-
 instance Outputable HsIPName where
     ppr (HsIPName n) = char '?' <> ftext n -- Ordinary implicit parameters
 
@@ -668,7 +659,6 @@ type instance XKindSig         (GhcPass _) = NoExt
 type instance XSpliceTy        GhcPs = NoExt
 type instance XSpliceTy        GhcRn = NoExt
 type instance XSpliceTy        GhcTc = Kind
-type instance XSpliceTy        GhcSe = NoExt
 
 type instance XDocTy           (GhcPass _) = NoExt
 type instance XBangTy          (GhcPass _) = NoExt
@@ -677,19 +667,16 @@ type instance XRecTy           (GhcPass _) = NoExt
 type instance XExplicitListTy  GhcPs = NoExt
 type instance XExplicitListTy  GhcRn = NoExt
 type instance XExplicitListTy  GhcTc = Kind
-type instance XExplicitListTy  GhcSe = NoExt
 
 type instance XExplicitTupleTy GhcPs = NoExt
 type instance XExplicitTupleTy GhcRn = NoExt
 type instance XExplicitTupleTy GhcTc = [Kind]
-type instance XExplicitTupleTy GhcSe = NoExt
 
 type instance XTyLit           (GhcPass _) = NoExt
 
 type instance XWildCardTy      GhcPs = NoExt
 type instance XWildCardTy      GhcRn = HsWildCardInfo
 type instance XWildCardTy      GhcTc = HsWildCardInfo
-type instance XWildCardTy      GhcSe = NoExt
 
 type instance XXType         (GhcPass _) = NewHsTypeX
 
@@ -1150,32 +1137,27 @@ type LFieldOcc pass = Located (FieldOcc pass)
 -- both the 'RdrName' the user originally wrote, and after the
 -- renamer, the selector function.
 data FieldOcc pass = FieldOcc { extFieldOcc     :: XCFieldOcc pass
-                              , rdrNameFieldOcc :: Located (RdrOrSeName pass)
+                              , rdrNameFieldOcc :: Located RdrName
                                  -- ^ See Note [Located RdrNames] in HsExpr
                               }
 
   | XFieldOcc
       (XXFieldOcc pass)
-deriving instance (p ~ GhcPass pass, Eq (XCFieldOcc p), Eq (RdrOrSeName p))
-               => Eq  (FieldOcc p)
-deriving instance (p ~ GhcPass pass, Ord (XCFieldOcc p), Ord (RdrOrSeName p))
-               => Ord (FieldOcc p)
+deriving instance (p ~ GhcPass pass, Eq (XCFieldOcc p)) => Eq  (FieldOcc p)
+deriving instance (p ~ GhcPass pass, Ord (XCFieldOcc p)) => Ord (FieldOcc p)
 
 type instance XCFieldOcc GhcPs = NoExt
 type instance XCFieldOcc GhcRn = Name
 type instance XCFieldOcc GhcTc = Id
-type instance XCFieldOcc GhcSe = NoExt
 
 type instance XXFieldOcc (GhcPass _) = NoExt
 
-instance Outputable (RdrOrSeName pass) => Outputable (FieldOcc pass) where
+instance Outputable (FieldOcc pass) where
   ppr = ppr . rdrNameFieldOcc
 
 mkFieldOcc :: Located RdrName -> FieldOcc GhcPs
 mkFieldOcc rdr = FieldOcc noExt rdr
 
-fieldOccRdrName :: RdrOrSeName pass ~ RdrName => FieldOcc pass -> Located RdrName
-fieldOccRdrName = rdrNameFieldOcc
 
 -- | Ambiguous Field Occurrence
 --
@@ -1190,36 +1172,31 @@ fieldOccRdrName = rdrNameFieldOcc
 -- Note [Disambiguating record fields] in TcExpr.
 -- See Note [Located RdrNames] in HsExpr
 data AmbiguousFieldOcc pass
-  = Unambiguous (XUnambiguous pass) (Located (RdrOrSeName pass))
-  | Ambiguous   (XAmbiguous pass)   (Located (RdrOrSeName pass))
+  = Unambiguous (XUnambiguous pass) (Located RdrName)
+  | Ambiguous   (XAmbiguous pass)   (Located RdrName)
   | XAmbiguousFieldOcc (XXAmbiguousFieldOcc pass)
 
 type instance XUnambiguous GhcPs = NoExt
 type instance XUnambiguous GhcRn = Name
 type instance XUnambiguous GhcTc = Id
-type instance XUnambiguous GhcSe = NoExt
 
 type instance XAmbiguous GhcPs = NoExt
 type instance XAmbiguous GhcRn = NoExt
 type instance XAmbiguous GhcTc = Id
-type instance XAmbiguous GhcSe = NoExt
 
 type instance XXAmbiguousFieldOcc (GhcPass _) = NoExt
 
-instance (p ~ GhcPass pass, Outputable (RdrOrSeName p))
-      => Outputable (AmbiguousFieldOcc p) where
+instance p ~ GhcPass pass => Outputable (AmbiguousFieldOcc p) where
   ppr = ppr . rdrNameAmbiguousFieldOcc
 
-instance (p ~ GhcPass pass, OutputableBndr (RdrOrSeName p))
-      => OutputableBndr (AmbiguousFieldOcc p) where
+instance p ~ GhcPass pass => OutputableBndr (AmbiguousFieldOcc p) where
   pprInfixOcc  = pprInfixOcc . rdrNameAmbiguousFieldOcc
   pprPrefixOcc = pprPrefixOcc . rdrNameAmbiguousFieldOcc
 
 mkAmbiguousFieldOcc :: Located RdrName -> AmbiguousFieldOcc GhcPs
 mkAmbiguousFieldOcc rdr = Unambiguous noExt rdr
 
-rdrNameAmbiguousFieldOcc
-  :: AmbiguousFieldOcc (GhcPass p) -> RdrOrSeName (GhcPass p)
+rdrNameAmbiguousFieldOcc :: AmbiguousFieldOcc (GhcPass p) -> RdrName
 rdrNameAmbiguousFieldOcc (Unambiguous _ (L _ rdr)) = rdr
 rdrNameAmbiguousFieldOcc (Ambiguous   _ (L _ rdr)) = rdr
 rdrNameAmbiguousFieldOcc (XAmbiguousFieldOcc _)
diff --git a/compiler/hsSyn/HsUtils.hs b/compiler/hsSyn/HsUtils.hs
index be0a5281ab..eba21cf1e2 100644
--- a/compiler/hsSyn/HsUtils.hs
+++ b/compiler/hsSyn/HsUtils.hs
@@ -1133,9 +1133,8 @@ hsTyClForeignBinders tycl_decls foreign_decls
     getSelectorNames (ns, fs) = map unLoc ns ++ map (extFieldOcc . unLoc) fs
 
 -------------------
-hsLTyClDeclBinders
-  :: RdrOrSeName pass ~ RdrName
-  => Located (TyClDecl pass) -> ([Located (IdP pass)], [LFieldOcc pass])
+hsLTyClDeclBinders :: Located (TyClDecl pass)
+                   -> ([Located (IdP pass)], [LFieldOcc pass])
 -- ^ Returns all the /binding/ names of the decl.  The first one is
 -- guaranteed to be the name of the decl. The first component
 -- represents all binding names except record fields; the second
@@ -1189,8 +1188,7 @@ getPatSynBinds binds
           , L _ (PatSynBind _ psb) <- bagToList lbinds ]
 
 -------------------
-hsLInstDeclBinders :: RdrOrSeName (GhcPass p) ~ RdrName
-                   => LInstDecl (GhcPass p)
+hsLInstDeclBinders :: LInstDecl (GhcPass p)
                    -> ([Located (IdP (GhcPass p))], [LFieldOcc (GhcPass p)])
 hsLInstDeclBinders (L _ (ClsInstD { cid_inst = ClsInstDecl { cid_datafam_insts = dfis } }))
   = foldMap (hsDataFamInstBinders . unLoc) dfis
@@ -1204,9 +1202,8 @@ hsLInstDeclBinders (L _ (XInstDecl _))
 
 -------------------
 -- the SrcLoc returned are for the whole declarations, not just the names
-hsDataFamInstBinders
-  :: RdrOrSeName pass ~ RdrName
-  => DataFamInstDecl pass -> ([Located (IdP pass)], [LFieldOcc pass])
+hsDataFamInstBinders :: DataFamInstDecl pass
+                     -> ([Located (IdP pass)], [LFieldOcc pass])
 hsDataFamInstBinders (DataFamInstDecl { dfid_eqn = HsIB { hsib_body =
                        FamEqn { feqn_rhs = defn }}})
   = hsDataDefnBinders defn
@@ -1219,9 +1216,7 @@ hsDataFamInstBinders (DataFamInstDecl (XHsImplicitBndrs _))
 
 -------------------
 -- the SrcLoc returned are for the whole declarations, not just the names
-hsDataDefnBinders
-  :: RdrOrSeName pass ~ RdrName
-  => HsDataDefn pass -> ([Located (IdP pass)], [LFieldOcc pass])
+hsDataDefnBinders :: HsDataDefn pass -> ([Located (IdP pass)], [LFieldOcc pass])
 hsDataDefnBinders (HsDataDefn { dd_cons = cons })
   = hsConDeclsBinders cons
   -- See Note [Binders in family instances]
@@ -1231,9 +1226,7 @@ hsDataDefnBinders (XHsDataDefn _) = panic "hsDataDefnBinders"
 type Seen pass = [LFieldOcc pass] -> [LFieldOcc pass]
                  -- Filters out ones that have already been seen
 
-hsConDeclsBinders
-  :: forall pass. RdrOrSeName pass ~ RdrName
-  => [LConDecl pass] -> ([Located (IdP pass)], [LFieldOcc pass])
+hsConDeclsBinders :: [LConDecl pass] -> ([Located (IdP pass)], [LFieldOcc pass])
    -- See hsLTyClDeclBinders for what this does
    -- The function is boringly complicated because of the records
    -- And since we only have equality, we have to be a little careful
diff --git a/compiler/hsSyn/PlaceHolder.hs b/compiler/hsSyn/PlaceHolder.hs
index e05dfc3a33..244243a82f 100644
--- a/compiler/hsSyn/PlaceHolder.hs
+++ b/compiler/hsSyn/PlaceHolder.hs
@@ -9,7 +9,6 @@ module PlaceHolder where
 import Name
 import NameSet
 import RdrName
-import SeName
 import Var
 
 
@@ -69,4 +68,3 @@ type family NameOrRdrName id where
   NameOrRdrName Id      = Name
   NameOrRdrName Name    = Name
   NameOrRdrName RdrName = RdrName
-  NameOrRdrName SeName  = SeName
diff --git a/compiler/hsSyn/SeName.hs b/compiler/hsSyn/SeName.hs
deleted file mode 100644
index f8bca59243..0000000000
--- a/compiler/hsSyn/SeName.hs
+++ /dev/null
@@ -1,13 +0,0 @@
-{-# LANGUAGE GeneralizedNewtypeDeriving #-}
-module SeName (SeName(..), mkSeName) where
-
-import Outputable
-import RdrName
-
--- TODO: make this smarter, so as to check whether
--- the name is local or not.
-newtype SeName = SeName RdrName
-  deriving (Outputable, OutputableBndr)
-
-mkSeName :: RdrName -> SeName
-mkSeName = SeName
diff --git a/compiler/iface/IfaceEnv.hs b/compiler/iface/IfaceEnv.hs
index 2d6047d7cc..00bcaa77f1 100644
--- a/compiler/iface/IfaceEnv.hs
+++ b/compiler/iface/IfaceEnv.hs
@@ -16,7 +16,7 @@ module IfaceEnv (
         ifaceExportNames,
 
         -- Name-cache stuff
-        allocateGlobalBinder, updNameCacheTc, updNameCacheIO,
+        allocateGlobalBinder, updNameCacheTc,
         mkNameCacheUpdater, NameCacheUpdater(..),
    ) where
 
diff --git a/compiler/iface/IfaceType.hs b/compiler/iface/IfaceType.hs
index 15a19b117f..5a7f761d32 100644
--- a/compiler/iface/IfaceType.hs
+++ b/compiler/iface/IfaceType.hs
@@ -139,7 +139,7 @@ type IfaceContext = [IfacePredType]
 data IfaceTyLit
   = IfaceNumTyLit Integer
   | IfaceStrTyLit FastString
-  deriving Eq
+  deriving (Eq)
 
 type IfaceTyConBinder = TyVarBndr IfaceTvBndr TyConBndrVis
 type IfaceForAllBndr  = TyVarBndr IfaceTvBndr ArgFlag
@@ -170,7 +170,7 @@ instance Monoid IfaceTcArgs where
 -- properly.
 data IfaceTyCon = IfaceTyCon { ifaceTyConName :: IfExtName
                              , ifaceTyConInfo :: IfaceTyConInfo }
-    deriving Eq
+    deriving (Eq)
 
 -- | Is a TyCon a promoted data constructor or just a normal type constructor?
 data IsPromoted = IsNotPromoted | IsPromoted
@@ -194,7 +194,7 @@ data IfaceTyConSort = IfaceNormalTyCon          -- ^ a regular tycon
                       -- that is actually being applied to two types
                       -- of the same kind.  This affects pretty-printing
                       -- only: see Note [Equality predicates in IfaceType]
-                    deriving Eq
+                    deriving (Eq)
 
 {- Note [Free tyvars in IfaceType]
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@@ -278,7 +278,7 @@ data IfaceTyConInfo   -- Used to guide pretty-printing
                       -- and to disambiguate D from 'D (they share a name)
   = IfaceTyConInfo { ifaceTyConIsPromoted :: IsPromoted
                    , ifaceTyConSort       :: IfaceTyConSort }
-    deriving Eq
+    deriving (Eq)
 
 data IfaceCoercion
   = IfaceReflCo       Role IfaceType
@@ -1650,7 +1650,6 @@ instance Binary IfaceUnivCoProv where
            _ -> panic ("get IfaceUnivCoProv " ++ show tag)
 
 
-{-
 instance Binary (DefMethSpec IfaceType) where
     put_ bh VanillaDM     = putByte bh 0
     put_ bh (GenericDM t) = putByte bh 1 >> put_ bh t
@@ -1659,4 +1658,3 @@ instance Binary (DefMethSpec IfaceType) where
             case h of
               0 -> return VanillaDM
               _ -> do { t <- get bh; return (GenericDM t) }
--}
diff --git a/compiler/main/DynFlags.hs b/compiler/main/DynFlags.hs
index 5f217a6a8f..539132653e 100644
--- a/compiler/main/DynFlags.hs
+++ b/compiler/main/DynFlags.hs
@@ -916,8 +916,6 @@ data DynFlags = DynFlags {
   hiDir                 :: Maybe String,
   stubDir               :: Maybe String,
   dumpDir               :: Maybe String,
-  saveSplicesDir        :: Maybe String,
-  loadSplicesDir        :: Maybe String,
 
   objectSuf             :: String,
   hcSuf                 :: String,
@@ -1799,8 +1797,6 @@ defaultDynFlags mySettings (myLlvmTargets, myLlvmPasses) =
         hiDir                   = Nothing,
         stubDir                 = Nothing,
         dumpDir                 = Nothing,
-        saveSplicesDir          = Nothing,
-        loadSplicesDir          = Nothing,
 
         objectSuf               = phaseInputExt StopLn,
         hcSuf                   = phaseInputExt HCc,
@@ -2375,7 +2371,6 @@ getVerbFlags dflags
   | otherwise             = []
 
 setObjectDir, setHiDir, setStubDir, setDumpDir, setOutputDir,
-         setSaveSplicesDir, setLoadSplicesDir,
          setDynObjectSuf, setDynHiSuf,
          setDylibInstallName,
          setObjectSuf, setHiSuf, setHcSuf, parseDynLibLoaderMode,
@@ -2395,8 +2390,6 @@ setStubDir    f d = d { stubDir    = Just f
   -- builds).
 setDumpDir    f d = d { dumpDir    = Just f}
 setOutputDir  f = setObjectDir f . setHiDir f . setStubDir f . setDumpDir f
-setSaveSplicesDir f d = d { saveSplicesDir = Just f}
-setLoadSplicesDir f d = d { loadSplicesDir = Just f}
 setDylibInstallName  f d = d { dylibInstallName = Just f}
 
 setObjectSuf    f d = d { objectSuf    = f}
@@ -2955,8 +2948,6 @@ dynamic_flags_deps = [
   , make_ord_flag defGhcFlag "tmpdir"            (hasArg setTmpDir)
   , make_ord_flag defGhcFlag "stubdir"           (hasArg setStubDir)
   , make_ord_flag defGhcFlag "dumpdir"           (hasArg setDumpDir)
-  , make_ord_flag defGhcFlag "save-splices"      (hasArg setSaveSplicesDir)
-  , make_ord_flag defGhcFlag "load-splices"      (hasArg setLoadSplicesDir)
   , make_ord_flag defGhcFlag "outputdir"         (hasArg setOutputDir)
   , make_ord_flag defGhcFlag "ddump-file-prefix"
         (hasArg (setDumpPrefixForce . Just))
diff --git a/compiler/prelude/PrimOp.hs-boot b/compiler/prelude/PrimOp.hs-boot
index 6d759bb961..f10ef44972 100644
--- a/compiler/prelude/PrimOp.hs-boot
+++ b/compiler/prelude/PrimOp.hs-boot
@@ -1,7 +1,5 @@
 module PrimOp where
 
-import GhcPrelude (Int)
+import GhcPrelude ()
 
 data PrimOp
-primOpTag :: PrimOp -> Int
-allThePrimOps :: [PrimOp]
diff --git a/compiler/rename/RnPat.hs b/compiler/rename/RnPat.hs
index 63c471d3ef..6195309cab 100644
--- a/compiler/rename/RnPat.hs
+++ b/compiler/rename/RnPat.hs
@@ -743,7 +743,7 @@ rnHsRecUpdFields flds
 getFieldIds :: [LHsRecField GhcRn arg] -> [Name]
 getFieldIds flds = map (unLoc . hsRecFieldSel . unLoc) flds
 
-getFieldLbls :: RdrOrSeName id ~ RdrName => [LHsRecField id arg] -> [RdrName]
+getFieldLbls :: [LHsRecField id arg] -> [RdrName]
 getFieldLbls flds
   = map (unLoc . rdrNameFieldOcc . unLoc . hsRecFieldLbl . unLoc) flds
 
diff --git a/compiler/typecheck/Inst.hs b/compiler/typecheck/Inst.hs
index 91d88087f8..f8f3bbe191 100644
--- a/compiler/typecheck/Inst.hs
+++ b/compiler/typecheck/Inst.hs
@@ -7,7 +7,7 @@ The @Inst@ type: dictionaries or method instances
 -}
 
 {-# LANGUAGE CPP, MultiWayIf, TupleSections #-}
-{-# LANGUAGE FlexibleContexts, TypeFamilies #-}
+{-# LANGUAGE FlexibleContexts #-}
 
 module Inst (
        deeplySkolemise,
diff --git a/compiler/typecheck/TcEnv.hs b/compiler/typecheck/TcEnv.hs
index 00dcf26f09..b42557259e 100644
--- a/compiler/typecheck/TcEnv.hs
+++ b/compiler/typecheck/TcEnv.hs
@@ -1,6 +1,6 @@
 -- (c) The University of Glasgow 2006
 {-# LANGUAGE CPP, FlexibleInstances #-}
-{-# LANGUAGE FlexibleContexts, GADTs #-}
+{-# LANGUAGE FlexibleContexts #-}
 {-# OPTIONS_GHC -fno-warn-orphans #-}  -- instance MonadThings is necessarily an
                                        -- orphan
 {-# LANGUAGE UndecidableInstances #-} -- Note [Pass sensitive types]
diff --git a/compiler/typecheck/TcHsSyn.hs b/compiler/typecheck/TcHsSyn.hs
index 1cca6f5589..986047bded 100644
--- a/compiler/typecheck/TcHsSyn.hs
+++ b/compiler/typecheck/TcHsSyn.hs
@@ -114,7 +114,7 @@ hsPatType (NPlusKPat ty _ _ _ _ _)      = ty
 hsPatType (CoPat _ _ _ ty)              = ty
 hsPatType p                             = pprPanic "hsPatType" (ppr p)
 
-hsLitType :: LitType (GhcPass p) ~ TcType => HsLit (GhcPass p) -> TcType
+hsLitType :: HsLit (GhcPass p) -> TcType
 hsLitType (HsChar _ _)       = charTy
 hsLitType (HsCharPrim _ _)   = charPrimTy
 hsLitType (HsString _ _)     = stringTy
diff --git a/compiler/typecheck/TcRnDriver.hs b/compiler/typecheck/TcRnDriver.hs
index 5a048d0c4b..2f81e07990 100644
--- a/compiler/typecheck/TcRnDriver.hs
+++ b/compiler/typecheck/TcRnDriver.hs
@@ -47,7 +47,7 @@ module TcRnDriver (
 
 import GhcPrelude
 
-import {-# SOURCE #-} TcSplice( finishTH, writeHsSpliceData )
+import {-# SOURCE #-} TcSplice ( finishTH )
 import RnSplice ( rnTopSpliceDecls, traceSplice, SpliceInfo(..) )
 import IfaceEnv( externaliseName )
 import TcHsType
@@ -114,7 +114,6 @@ import Avail
 import TyCon
 import SrcLoc
 import HscTypes
-import HsExprBin
 import ListSetOps
 import Outputable
 import ConLike
@@ -138,8 +137,6 @@ import qualified Data.Set as S
 
 import Control.DeepSeq
 import Control.Monad
-import System.Directory
-import System.FilePath (takeDirectory)
 
 #include "HsVersions.h"
 
@@ -424,17 +421,6 @@ tcRnSrcDecls explicit_mod_hdr decls
         -- Finalizers must run after constraints are simplified, or some types
         -- might not be complete when using reify (see #12777).
       ; (tcg_env, tcl_env) <- setGblEnv tcg_env run_th_modfinalizers
-
-      ; dynflags <- getDynFlags
-      ; whenSet (saveSplicesDir dynflags)
-          (\splicesDir -> do
-              moduleSplicesPath <- getModuleSplicesPath splicesDir <$> getModule
-              hs_splice_data <- readTcRef (tcg_hs_splice_data tcg_env)
-              liftIO $ createDirectoryIfMissing True (takeDirectory moduleSplicesPath)
-              writeHsSpliceData moduleSplicesPath hs_splice_data
-          )
-          (pure ())
-
       ; setEnvs (tcg_env, tcl_env) $ do {
 
       ; finishTH
diff --git a/compiler/typecheck/TcRnMonad.hs b/compiler/typecheck/TcRnMonad.hs
index 83449f1631..e0989ae331 100644
--- a/compiler/typecheck/TcRnMonad.hs
+++ b/compiler/typecheck/TcRnMonad.hs
@@ -145,7 +145,6 @@ import IOEnv            -- Re-export all
 import TcEvidence
 
 import HsSyn hiding (LIE)
-import HsExprBin
 import HscTypes
 import Module
 import RdrName
@@ -183,7 +182,7 @@ import Control.Monad
 import Data.Set ( Set )
 import qualified Data.Set as Set
 
-import {-# SOURCE #-} TcSplice ( readHsSpliceData, runRemoteModFinalizers )
+import {-# SOURCE #-} TcSplice ( runRemoteModFinalizers )
 import {-# SOURCE #-} TcEnv    ( tcInitTidyEnv )
 
 import qualified Data.Map as Map
@@ -229,16 +228,9 @@ initTc hsc_env hsc_src keep_rn_syntax mod loc do_this
         th_coreplugins_var <- newIORef [] ;
         th_state_var         <- newIORef Map.empty ;
         th_remote_state_var  <- newIORef Nothing ;
-        dflags <- pure (hsc_dflags hsc_env) ;
-        hs_splice_data <- newIORef =<< whenSet (loadSplicesDir dflags)
-          (\splicesDir -> do
-              if moduleUnitId mod == interactiveUnitId
-                then return emptyHsSpliceData
-                else do let moduleSplicesPath = getModuleSplicesPath splicesDir mod
-                        readHsSpliceData hsc_env moduleSplicesPath
-          )
-          (pure emptyHsSpliceData) ;
         let {
+             dflags = hsc_dflags hsc_env ;
+
              maybe_rn_syntax :: forall a. a -> Maybe a ;
              maybe_rn_syntax empty_val
                 | dopt Opt_D_dump_rn_ast dflags = Just empty_val
@@ -318,8 +310,7 @@ initTc hsc_env hsc_src keep_rn_syntax mod loc do_this
                 tcg_top_loc        = loc,
                 tcg_static_wc      = static_wc_var,
                 tcg_complete_matches = [],
-                tcg_cc_st          = cc_st_var,
-                tcg_hs_splice_data = hs_splice_data
+                tcg_cc_st          = cc_st_var
              } ;
         } ;
 
diff --git a/compiler/typecheck/TcRnTypes.hs b/compiler/typecheck/TcRnTypes.hs
index 08ed9f151d..2a4b808f54 100644
--- a/compiler/typecheck/TcRnTypes.hs
+++ b/compiler/typecheck/TcRnTypes.hs
@@ -160,7 +160,6 @@ import TyCoRep  ( CoercionHole(..), coHoleCoVar )
 import Coercion ( Coercion, mkHoleCo )
 import ConLike  ( ConLike(..) )
 import DataCon  ( DataCon, dataConUserType, dataConOrigArgTys )
-import {-# SOURCE #-} HsExprBin
 import PatSyn   ( PatSyn, pprPatSynType )
 import Id       ( idType, idName )
 import FieldLabel ( FieldLabel )
@@ -690,19 +689,7 @@ data TcGblEnv
         tcg_complete_matches :: [CompleteMatch],
 
         -- ^ Tracking indices for cost centre annotations
-        tcg_cc_st   :: TcRef CostCentreState,
-        -- ^ Splice evaluation results
-        --
-        -- When @-save-splices@ is passed, we will
-        -- record splice results in this field and write
-        -- them all to an .hs-splice file when we are done
-        -- processing the module.
-        --
-        -- When @-load-splices@ is passed, we will read
-        -- the .hs-splice file before we start processing a
-        -- module (when it exists) and store all its contents
-        -- in this field.
-        tcg_hs_splice_data :: TcRef HsSpliceData
+        tcg_cc_st   :: TcRef CostCentreState
     }
 
 -- NB: topModIdentity, not topModSemantic!
diff --git a/compiler/typecheck/TcSplice.hs b/compiler/typecheck/TcSplice.hs
index c6dd542937..737ddccfbd 100644
--- a/compiler/typecheck/TcSplice.hs
+++ b/compiler/typecheck/TcSplice.hs
@@ -26,7 +26,6 @@ module TcSplice(
      runMetaE, runMetaP, runMetaT, runMetaD, runQuasi,
      tcTopSpliceExpr, lookupThName_maybe,
      defaultRunMeta, runMeta', runRemoteModFinalizers,
-     readHsSpliceData, writeHsSpliceData,
      finishTH
       ) where
 
@@ -35,7 +34,6 @@ module TcSplice(
 import GhcPrelude
 
 import HsSyn
-import HsExprBin
 import Annotations
 import Finder
 import Name
@@ -112,9 +110,6 @@ import Maybes( MaybeErr(..) )
 import DynFlags
 import Panic
 import Lexeme
-import BinIface ( getWithUserData, putWithUserData )
-import IfaceEnv ( NameCacheUpdater(..) )
-import qualified Binary as Bin
 import qualified EnumSet
 import Plugins
 import Bag
@@ -137,7 +132,6 @@ import Data.Typeable ( typeOf, Typeable, TypeRep, typeRep )
 import Data.Data (Data)
 import Data.Proxy    ( Proxy (..) )
 import GHC.Exts         ( unsafeCoerce# )
-import System.Directory ( doesFileExist )
 
 {-
 ************************************************************************
@@ -678,26 +672,12 @@ runQResult show_th f runQ expr_span hval
 
 
 -----------------
-
 runMeta :: (MetaHook TcM -> LHsExpr GhcTc -> TcM hs_syn)
-        -> (LHsExpr GhcTc -> TcM hs_syn)
-           -- ^ function to load the result of the given expression from
-           --   an .hs-splice file's data
-        -> (LHsExpr GhcTc -> hs_syn -> TcM ())
-           -- ^ function to "save" the result (hs_syn) of evaluating the given
-           --   LHsExpr
         -> LHsExpr GhcTc
         -> TcM hs_syn
-runMeta unwrap loadSpliceFun saveSpliceFun e
-  = do { dflags <- getDynFlags
-       ; whenSet (loadSplicesDir dflags)
-           (\_ -> loadSpliceFun e)
-           (do { h <- getHooked runMetaHook defaultRunMeta
-               ; res <- unwrap h e
-               ; whenSet (saveSplicesDir dflags)
-                   (\_ -> saveSpliceFun e res)
-                   (return ())
-               ; return res }) }
+runMeta unwrap e
+  = do { h <- getHooked runMetaHook defaultRunMeta
+       ; unwrap h e }
 
 defaultRunMeta :: MetaHook TcM
 defaultRunMeta (MetaE r)
@@ -714,110 +694,29 @@ defaultRunMeta (MetaAW r)
     -- the toAnnotationWrapper function that we slap around the user's code
 
 ----------------
-
-readHsSpliceData :: HscEnv -> FilePath -> IO HsSpliceData
-readHsSpliceData hsc_env hsSpliceFile = do
-  let ncu = NCU (updNameCache hsc_env)
-  exists <- doesFileExist hsSpliceFile
-  if exists
-    then do bh <- Bin.readBinMem hsSpliceFile
-            getWithUserData ncu bh
-    else pure emptyHsSpliceData
-
-writeHsSpliceData :: FilePath -> HsSpliceData -> TcM ()
-writeHsSpliceData hsSpliceFile hsSpliceData =
-  when (nonEmptyHsSpliceData hsSpliceData) $ do
-    dflags <- getDynFlags
-    liftIO $ do
-      bh <- Bin.openBinMem (100 * 1024)
-      --  ^^^ FIXME: how should we compute an approximation of size?
-      putWithUserData (debugTraceMsg dflags 3) bh hsSpliceData
-      Bin.writeBinMem bh hsSpliceFile
-
--- | Update the splice data from the TcGblEnv using the given
---   function. Used when -save-splices is passed, to record
---   the splice results as we evaluate them and dump them
---   to an .hs-splice file.
-modifyHsSpliceData :: (HsSpliceData -> HsSpliceData) -> TcM ()
-modifyHsSpliceData f = do
-  spliceDataRef <- tcg_hs_splice_data <$> getGblEnv
-  updTcRef spliceDataRef f
-
--- | Record the result (second argument) of evaluating the expression splice
---   represented by the first argument.
-addSpliceExprResult :: LHsExpr GhcTc -> LHsExpr GhcPs -> TcM ()
-addSpliceExprResult th@(L l _) resultE = do
-  serialExpr <- handleUnsupported (fmap ppr th) (Just $ ppr resultE)
-            =<< exprPS2SE resultE
-  modifyHsSpliceData $ recordSpliceResult l (SRExpr serialExpr)
-
--- | Record the result (second argument) of evaluating the declaration splice
---   represented by the first argument.
-addSpliceDeclsResult :: LHsExpr GhcTc -> [LHsDecl GhcPs] -> TcM ()
-addSpliceDeclsResult th@(L l _) resultDs = do
-  serialDecls <- traverse
-     (declPS2SE >=> handleUnsupported (fmap ppr th) (Just $ ppr resultDs))
-     resultDs
-  modifyHsSpliceData $ recordSpliceResult l (SRDecls serialDecls)
-
--- | Look up the result of evaluating the splice represented by the first
---   argument in an .hs-splice file, using the given function to extract
---   the result in question (when found).
-getSpliceResult :: LHsExpr GhcTc -> (SpliceResult -> TcM a) -> TcM a
-getSpliceResult (L l _) f = do
-  gblEnv <- getGblEnv
-  hs_splice_data <- readTcRef (tcg_hs_splice_data gblEnv)
-  case lookupSpliceResult l hs_splice_data of
-    Nothing -> panic ("Could not find splice result for source span " ++ show l)
-    Just r  -> f r
-
--- | Look up the result of evaluating an expression splice.
-getSpliceExprResult :: LHsExpr GhcTc -> TcM (LHsExpr GhcPs)
-getSpliceExprResult spliceE = getSpliceResult spliceE $ \res -> case res of
-    SRExpr e  -> exprSE2PS e >>= handleUnsupported (fmap ppr spliceE) Nothing
-    SRDecls _ -> panic ("Expected an expression splice but found a declaration one")
-
--- | Look up the result of evaluating a declaration splice.
-getSpliceDeclsResult :: LHsExpr GhcTc -> TcM [LHsDecl GhcPs]
-getSpliceDeclsResult spliceE = getSpliceResult spliceE $ \res -> case res of
-    SRExpr _   -> panic ("Expected a declaration splice result but found an expression one")
-    SRDecls ds -> traverse
-      (declSE2PS >=> handleUnsupported (fmap ppr spliceE) Nothing)
-      ds
-
 runMetaAW :: LHsExpr GhcTc         -- Of type AnnotationWrapper
           -> TcM Serialized
 runMetaAW = runMeta metaRequestAW
-  -- We cannot process annotations as they use the same
-  -- mechanism as TH. Instead, we ignore them when
-  -- doing a -save-splices pass, and we pretend we
-  -- read {-# ANN () #-} when doing a -load-splices pass.
-  (\_ -> pure $ toSerialized serializeWithData ())
-  (\_ _ -> pure ())
 
 runMetaE :: LHsExpr GhcTc          -- Of type (Q Exp)
          -> TcM (LHsExpr GhcPs)
-runMetaE = runMeta metaRequestE getSpliceExprResult addSpliceExprResult
+runMetaE = runMeta metaRequestE
 
 runMetaP :: LHsExpr GhcTc          -- Of type (Q Pat)
          -> TcM (LPat GhcPs)
 runMetaP = runMeta metaRequestP
-  (panic "runMetaP doesn't support splice caching (read)")
-  (panic "runMetaP doesn't support splice caching (write)")
 
 runMetaT :: LHsExpr GhcTc          -- Of type (Q Type)
          -> TcM (LHsType GhcPs)
 runMetaT = runMeta metaRequestT
-  (panic "runMetaT doesn't support splice caching (read)")
-  (panic "runMetaT doesn't support splice caching (write)")
 
 runMetaD :: LHsExpr GhcTc          -- Of type Q [Dec]
          -> TcM [LHsDecl GhcPs]
-runMetaD = runMeta metaRequestD getSpliceDeclsResult addSpliceDeclsResult
+runMetaD = runMeta metaRequestD
 
 ---------------
 runMeta' :: Bool                 -- Whether code should be printed in the exception message
-         -> (hs_syn -> SDoc)     -- how to print the code
+         -> (hs_syn -> SDoc)                                    -- how to print the code
          -> (SrcSpan -> ForeignHValue -> TcM (Either MsgDoc hs_syn))        -- How to run x
          -> LHsExpr GhcTc        -- Of type x; typically x = Q TH.Exp, or
                                  --    something like that
@@ -828,7 +727,7 @@ runMeta' show_code ppr_hs run_and_convert expr
                             -- we catch all kinds of splices and annotations.
 
         -- Check that we've had no errors of any sort so far.
-        -- For example, if we found an error in an earlier defn f, but
+        -- For example, if we found an error in an earlier defn f, but
         -- recovered giving it type f :: forall a.a, it'd be very dodgy
         -- to carry ont.  Mind you, the staging restrictions mean we won't
         -- actually run f, but it still seems wrong. And, more concretely,
diff --git a/compiler/typecheck/TcSplice.hs-boot b/compiler/typecheck/TcSplice.hs-boot
index 277dc95c8d..be2c67d887 100644
--- a/compiler/typecheck/TcSplice.hs-boot
+++ b/compiler/typecheck/TcSplice.hs-boot
@@ -10,8 +10,6 @@ import TcRnTypes( TcM , SpliceType )
 import TcType   ( ExpRhoType )
 import Annotations ( Annotation, CoreAnnTarget )
 import HsExtension ( GhcTcId, GhcRn, GhcPs )
-import HscTypes    ( HscEnv )
-import HsExprBin   ( HsSpliceData )
 
 import HsSyn      ( HsSplice, HsBracket, HsExpr, LHsExpr, LHsType, LPat,
                     LHsDecl, ThModFinalizers )
@@ -44,6 +42,3 @@ lookupThName_maybe :: TH.Name -> TcM (Maybe Name)
 runQuasi :: TH.Q a -> TcM a
 runRemoteModFinalizers :: ThModFinalizers -> TcM ()
 finishTH :: TcM ()
-
-readHsSpliceData :: HscEnv -> FilePath -> IO HsSpliceData
-writeHsSpliceData :: FilePath -> HsSpliceData -> TcM ()
\ No newline at end of file
diff --git a/compiler/typecheck/TcType.hs-boot b/compiler/typecheck/TcType.hs-boot
index 1b014c2d2a..2bc14735f1 100644
--- a/compiler/typecheck/TcType.hs-boot
+++ b/compiler/typecheck/TcType.hs-boot
@@ -4,6 +4,5 @@ import Outputable( SDoc )
 data MetaDetails
 
 data TcTyVarDetails
-
 pprTcTyVarDetails :: TcTyVarDetails -> SDoc
 vanillaSkolemTv :: TcTyVarDetails
diff --git a/compiler/types/CoAxiom.hs b/compiler/types/CoAxiom.hs
index c8334ddd42..63c21627c8 100644
--- a/compiler/types/CoAxiom.hs
+++ b/compiler/types/CoAxiom.hs
@@ -39,9 +39,9 @@ import Name
 import Unique
 import Var
 import Util
+import Binary
 import Pair
 import BasicTypes
-import Binary
 import Data.Typeable ( Typeable )
 import SrcLoc
 import qualified Data.Data as Data
@@ -440,16 +440,15 @@ instance Outputable Role where
   ppr = ftext . fsFromRole
 
 instance Binary Role where
-  put_ bh r = putByte bh $ case r of
-    Nominal          -> 0
-    Representational -> 1
-    Phantom          -> 2
-  get bh = do
-    tag <- getByte bh
-    pure $ case tag of
-      0 -> Nominal
-      1 -> Representational
-      _ -> Phantom
+  put_ bh Nominal          = putByte bh 1
+  put_ bh Representational = putByte bh 2
+  put_ bh Phantom          = putByte bh 3
+
+  get bh = do tag <- getByte bh
+              case tag of 1 -> return Nominal
+                          2 -> return Representational
+                          3 -> return Phantom
+                          _ -> panic ("get Role " ++ show tag)
 
 {-
 ************************************************************************
@@ -502,6 +501,7 @@ instance Ord CoAxiomRule where
 instance Outputable CoAxiomRule where
   ppr = ppr . coaxrName
 
+
 -- Type checking of built-in families
 data BuiltInSynFamily = BuiltInSynFamily
   { sfMatchFam      :: [Type] -> Maybe (CoAxiomRule, [Type], Type)
diff --git a/compiler/types/TyCon.hs b/compiler/types/TyCon.hs
index 786e77ef63..82c9082ac1 100644
--- a/compiler/types/TyCon.hs
+++ b/compiler/types/TyCon.hs
@@ -584,6 +584,7 @@ instance Binary TyConBndrVis where
                   0 -> return AnonTCB
                   _ -> do { vis <- get bh; return (NamedTCB vis) } }
 
+
 {- *********************************************************************
 *                                                                      *
                The TyCon type
diff --git a/compiler/utils/Binary.hs b/compiler/utils/Binary.hs
index a84624d24c..447317ca47 100644
--- a/compiler/utils/Binary.hs
+++ b/compiler/utils/Binary.hs
@@ -63,16 +63,12 @@ module Binary
 import GhcPrelude
 
 import {-# SOURCE #-} Name (Name)
-import Bag
 import FastString
 import Panic
-import Unique
 import UniqFM
-import UniqSet
 import FastMutInt
 import Fingerprint
 import BasicTypes
-import {-# SOURCE #-} PrimOp
 import SrcLoc
 
 import Foreign
@@ -80,17 +76,14 @@ import Data.Array
 import Data.ByteString (ByteString)
 import qualified Data.ByteString.Internal as BS
 import qualified Data.ByteString.Unsafe   as BS
-import qualified Data.IntMap              as IM
 import Data.IORef
 import Data.Char                ( ord, chr )
-import Data.List                ( find )
 import Data.Time
 import Type.Reflection
 import Type.Reflection.Unsafe
 import Data.Kind (Type)
 import GHC.Exts (TYPE, RuntimeRep(..), VecCount(..), VecElem(..))
-import Data.Typeable            ( )
-import Control.Monad            ( when, replicateM )
+import Control.Monad            ( when )
 import System.IO as IO
 import System.IO.Unsafe         ( unsafeInterleaveIO )
 import System.IO.Error          ( mkIOError, eofErrorType )
@@ -387,8 +380,8 @@ instance Binary () where
     get  _    = return ()
 
 instance Binary Bool where
-    put_ bh b = putByte bh (if b then 1 else 0)
-    get  bh   = do x <- getByte bh; return $! if x == 0 then False else True
+    put_ bh b = putByte bh (fromIntegral (fromEnum b))
+    get  bh   = do x <- getWord8 bh; return $! (toEnum (fromIntegral x))
 
 instance Binary Char where
     put_  bh c = put_ bh (fromIntegral (ord c) :: Word32)
@@ -1180,121 +1173,3 @@ instance Binary SourceText where
         s <- get bh
         return (SourceText s)
       _ -> panic $ "Binary SourceText:" ++ show h
-
-instance Binary IntegralLit where
-  put_ bh (IL a b c) = put_ bh a >> put_ bh b >> put_ bh c
-  get bh = IL <$> get bh <*> get bh <*> get bh
-
-instance Binary FractionalLit where
-  put_ bh (FL a b c) = put_ bh a >> put_ bh b >> put_ bh c
-  get bh = FL <$> get bh <*> get bh <*> get bh
-
-instance Binary Boxity where
-  put_ bh b = case b of
-    Boxed   -> putByte bh 0
-    Unboxed -> putByte bh 1
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> pure Boxed
-      _ -> pure Unboxed
-
-instance Binary Unique where
-  put_ bh u = put_ bh (getKey u)
-  get bh = mkUniqueGrimily <$> get bh
-
-instance Binary ty => Binary (DefMethSpec ty) where
-  put_ bh s
-    = case s of
-        VanillaDM   -> putByte bh 0
-        GenericDM t -> putByte bh 1 >> put_ bh t
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> pure VanillaDM
-      _ -> GenericDM <$> get bh
-
-instance Binary a => Binary (IM.IntMap a) where
-  put_ bh m = put_ bh (IM.toAscList m)
-  get bh = IM.fromAscList <$> get bh
-
-instance Binary PrimOp where
-  put_ bh primop = put_ bh (primOpTag primop)
-  -- FIXME: inefficient.
-  get bh = do
-    tag <- getTag
-    case find (\p -> primOpTag p == tag) allThePrimOps of
-      Nothing -> error "Binary PrimOp.get: unknown primop tag"
-      Just p  -> pure p
-
-    where getTag :: IO Int
-          getTag = get bh
-
-instance Binary OccInfo where
-  put_ bh i
-    = case i of
-        ManyOccs a          -> putByte bh 0 >> put_ bh a
-        IAmDead             -> putByte bh 1
-        OneOcc a b c d      -> putByte bh 2 >> put_ bh a >> put_ bh b
-                                            >> put_ bh c >> put_ bh d
-        IAmALoopBreaker a b -> putByte bh 3 >> put_ bh a >> put_ bh b
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> ManyOccs <$> get bh
-      1 -> pure IAmDead
-      2 -> OneOcc <$> get bh <*> get bh <*> get bh <*> get bh
-      _ -> IAmALoopBreaker <$> get bh <*> get bh
-
-instance Binary TailCallInfo where
-  put_ bh i
-    = case i of
-        AlwaysTailCalled a -> putByte bh 0 >> put_ bh a
-        NoTailCallInfo     -> putByte bh 1
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> AlwaysTailCalled <$> get bh
-      _ -> pure NoTailCallInfo
-
-instance Binary OneShotInfo where
-  put_ bh i
-    = case i of
-        NoOneShotInfo -> putByte bh 0
-        OneShotLam    -> putByte bh 1
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> pure NoOneShotInfo
-      _ -> pure OneShotLam
-
-instance Binary LexicalFixity where
-  put_ bh f = case f of
-    Prefix -> putByte bh 0
-    Infix  -> putByte bh 1
-  get bh = do
-    tag <- getByte bh
-    case tag of
-      0 -> pure Prefix
-      _ -> pure Infix
-
-instance Binary ele => Binary (UniqFM ele) where
-  put_ bh ufm = put_ bh (ufmToIntMap ufm)
-  get bh = intMapToUFM <$> get bh
-
-instance Binary a => Binary (UniqSet a) where
-  put_ bh s = put_ bh (getUniqSet s)
-  get bh = unsafeUFMToUniqSet <$> get bh
-
-instance Binary a => Binary (Bag a) where
-  put_ bh b = put_ bh (bagToList b)
-  get bh = listToBag <$> get bh
-
-instance Binary Origin where
-  put_ bh o = putByte bh $ case o of
-    FromSource -> 0
-    Generated  -> 1
-  get bh = getByte bh >>= \n -> case n of
-    0 -> pure FromSource
-    1 -> pure Generated
-    _ -> panic "Binary Origin.get: unknown tag"
diff --git a/compiler/utils/UniqDFM.hs b/compiler/utils/UniqDFM.hs
index 90389da0d1..715600ddb8 100644
--- a/compiler/utils/UniqDFM.hs
+++ b/compiler/utils/UniqDFM.hs
@@ -62,7 +62,6 @@ module UniqDFM (
 import GhcPrelude
 
 import Unique           ( Uniquable(..), Unique, getKey )
-import Binary
 import Outputable
 
 import qualified Data.IntMap as M
@@ -129,10 +128,6 @@ instance Eq val => Eq (TaggedVal val) where
 instance Functor TaggedVal where
   fmap f (TaggedVal val i) = TaggedVal (f val) i
 
-instance Binary val => Binary (TaggedVal val) where
-  put_ bh (TaggedVal a b) = put_ bh a >> put_ bh b
-  get bh = TaggedVal <$> get bh <*> get bh
-
 -- | Type of unique deterministic finite maps
 data UniqDFM ele =
   UDFM
@@ -144,10 +139,6 @@ data UniqDFM ele =
                                 -- time. See Note [Overflow on plusUDFM]
   deriving (Data, Functor)
 
-instance Binary ele => Binary (UniqDFM ele) where
-  put_ bh (UDFM a b) = put_ bh a >> put_ bh b
-  get bh = UDFM <$> get bh <*> get bh
-
 emptyUDFM :: UniqDFM elt
 emptyUDFM = UDFM M.empty 0
 
diff --git a/compiler/utils/UniqFM.hs b/compiler/utils/UniqFM.hs
index 7a7c40ecfc..a80880f4e5 100644
--- a/compiler/utils/UniqFM.hs
+++ b/compiler/utils/UniqFM.hs
@@ -66,7 +66,7 @@ module UniqFM (
         lookupWithDefaultUFM, lookupWithDefaultUFM_Directly,
         nonDetEltsUFM, eltsUFM, nonDetKeysUFM,
         ufmToSet_Directly,
-        nonDetUFMToList, ufmToIntMap, intMapToUFM,
+        nonDetUFMToList, ufmToIntMap,
         pprUniqFM, pprUFM, pprUFMWithKeys, pluralUFM
     ) where
 
@@ -338,10 +338,7 @@ nonDetUFMToList (UFM m) = map (\(k, v) -> (getUnique k, v)) $ M.toList m
 ufmToIntMap :: UniqFM elt -> M.IntMap elt
 ufmToIntMap (UFM m) = m
 
-intMapToUFM :: M.IntMap elt -> UniqFM elt
-intMapToUFM = UFM
-
--- Determines whether two 'UniqFM's contain the same keys.
+-- Determines whether two 'UniqFm's contain the same keys.
 equalKeysUFM :: UniqFM a -> UniqFM b -> Bool
 equalKeysUFM (UFM m1) (UFM m2) = liftEq (\_ _ -> True) m1 m2
 
