diff --git a/compiler/basicTypes/DataCon.hs b/compiler/basicTypes/DataCon.hs
index a6d05936c1..2c8bc00af2 100644
--- a/compiler/basicTypes/DataCon.hs
+++ b/compiler/basicTypes/DataCon.hs
@@ -812,6 +812,7 @@ instance Binary SrcUnpackedness where
            1 -> return SrcUnpack
            _ -> return NoSrcUnpack
 
+
 -- | Compare strictness annotations
 eqHsBang :: HsImplBang -> HsImplBang -> Bool
 eqHsBang HsLazy               HsLazy              = True
diff --git a/compiler/basicTypes/IdInfo.hs b/compiler/basicTypes/IdInfo.hs
index 07f8814767..10497fbba0 100644
--- a/compiler/basicTypes/IdInfo.hs
+++ b/compiler/basicTypes/IdInfo.hs
@@ -18,7 +18,7 @@ module IdInfo (
         RecSelParent(..),
 
         -- * The IdInfo type
-        IdInfo,         -- Abstract
+        IdInfo,
         vanillaIdInfo, noCafIdInfo,
 
         -- ** The OneShotInfo type
diff --git a/compiler/basicTypes/IdInfo.hs-boot b/compiler/basicTypes/IdInfo.hs-boot
index cacfe6af2e..229ff9abb0 100644
--- a/compiler/basicTypes/IdInfo.hs-boot
+++ b/compiler/basicTypes/IdInfo.hs-boot
@@ -1,6 +1,7 @@
 module IdInfo where
 import GhcPrelude
 import Outputable
+
 data IdInfo
 data IdDetails
 
@@ -8,4 +9,3 @@ vanillaIdInfo :: IdInfo
 coVarDetails :: IdDetails
 isCoVarDetails :: IdDetails -> Bool
 pprIdDetails :: IdDetails -> SDoc
-
diff --git a/compiler/basicTypes/OccName.hs b/compiler/basicTypes/OccName.hs
index f6a66fd635..854873011d 100644
--- a/compiler/basicTypes/OccName.hs
+++ b/compiler/basicTypes/OccName.hs
@@ -399,6 +399,10 @@ instance Uniquable OccName where
 newtype OccEnv a = A (UniqFM a)
   deriving Data
 
+instance Binary a => Binary (OccEnv a) where
+  put_ bh (A a) = put_ bh a
+  get bh = A <$> get bh
+
 emptyOccEnv :: OccEnv a
 unitOccEnv  :: OccName -> a -> OccEnv a
 extendOccEnv :: OccEnv a -> OccName -> a -> OccEnv a
diff --git a/compiler/basicTypes/PatSyn.hs b/compiler/basicTypes/PatSyn.hs
index 5a74a5b68a..fa5e475487 100644
--- a/compiler/basicTypes/PatSyn.hs
+++ b/compiler/basicTypes/PatSyn.hs
@@ -32,6 +32,7 @@ import Outputable
 import Unique
 import Util
 import BasicTypes
+import Binary
 import Var
 import FieldLabel
 
@@ -328,6 +329,10 @@ instance Data.Data PatSyn where
     gunfold _ _  = error "gunfold"
     dataTypeOf _ = mkNoRepType "PatSyn"
 
+instance Binary PatSyn where
+  put = error "Binary PatSyn: not implemented yet"
+  get = error "Binary PatSyn: not implemented yet"
+
 {-
 ************************************************************************
 *                                                                      *
diff --git a/compiler/basicTypes/RdrName.hs b/compiler/basicTypes/RdrName.hs
index 84ece4e9ff..45f2f00b13 100644
--- a/compiler/basicTypes/RdrName.hs
+++ b/compiler/basicTypes/RdrName.hs
@@ -72,6 +72,7 @@ import GhcPrelude
 import Module
 import Name
 import Avail
+import Binary
 import NameSet
 import Maybes
 import SrcLoc
@@ -467,6 +468,10 @@ data GlobalRdrElt
          -- INVARIANT: either gre_lcl = True or gre_imp is non-empty
          -- See Note [GlobalRdrElt provenance]
 
+instance Binary GlobalRdrElt where
+  put_ bh (GRE a b c d) = put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+  get bh = GRE <$> get bh <*> get bh <*> get bh <*> get bh
+
 -- | The children of a Name are the things that are abbreviated by the ".."
 --   notation in export lists.  See Note [Parents]
 data Parent = NoParent
@@ -475,6 +480,18 @@ data Parent = NoParent
               -- ^ See Note [Parents for record fields]
             deriving (Eq, Data, Typeable)
 
+instance Binary Parent where
+  put_ bh p = case p of
+    NoParent      -> putByte bh 0
+    ParentIs p    -> putByte bh 1 >> put_ bh p
+    FldParent a b -> putByte bh 2 >> put_ bh a >> put_ bh b
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure NoParent
+      1 -> ParentIs <$> get bh
+      _ -> FldParent <$> get bh <*> get bh
+
 instance Outputable Parent where
    ppr NoParent        = empty
    ppr (ParentIs n)    = text "parent:" <> ppr n
@@ -1135,6 +1152,10 @@ data ImportSpec = ImpSpec { is_decl :: ImpDeclSpec,
                             is_item :: ImpItemSpec }
                 deriving( Eq, Ord, Data )
 
+instance Binary ImportSpec where
+  put_ bh (ImpSpec a b) = put_ bh a >> put_ bh b
+  get bh = ImpSpec <$> get bh <*> get bh
+
 -- | Import Declaration Specification
 --
 -- Describes a particular import declaration and is
@@ -1152,6 +1173,11 @@ data ImpDeclSpec
         is_dloc     :: SrcSpan     -- ^ The location of the entire import declaration
     } deriving Data
 
+instance Binary ImpDeclSpec where
+  put_ bh (ImpDeclSpec a b c d) =
+    put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+  get bh = ImpDeclSpec <$> get bh <*> get bh <*> get bh <*> get bh
+
 -- | Import Item Specification
 --
 -- Describes import info a particular Name
@@ -1173,6 +1199,16 @@ data ImpItemSpec
         -- only @T@ is named explicitly.
   deriving Data
 
+instance Binary ImpItemSpec where
+  put_ bh s = case s of
+    ImpAll      -> putByte bh 0
+    ImpSome a b -> putByte bh 1 >> put_ bh a >> put_ bh b
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure ImpAll
+      _ -> ImpSome <$> get bh <*> get bh
+
 instance Eq ImpDeclSpec where
   p1 == p2 = case p1 `compare` p2 of EQ -> True; _ -> False
 
diff --git a/compiler/ghc.cabal.in b/compiler/ghc.cabal.in
index 9205648846..04e46f961d 100644
--- a/compiler/ghc.cabal.in
+++ b/compiler/ghc.cabal.in
@@ -210,6 +210,7 @@ Library
         NameSet
         OccName
         RdrName
+        SeName
         NameCache
         SrcLoc
         UniqSupply
@@ -316,6 +317,9 @@ Library
         HsDecls
         HsDoc
         HsExpr
+        HsExprBin
+        HsExprBin_Conversions
+        HsExprBin_Instances
         HsImpExp
         HsLit
         PlaceHolder
diff --git a/compiler/hsSyn/HsBinds.hs b/compiler/hsSyn/HsBinds.hs
index a9be2c1341..a346667b2b 100644
--- a/compiler/hsSyn/HsBinds.hs
+++ b/compiler/hsSyn/HsBinds.hs
@@ -12,6 +12,7 @@ Datatype for: @BindGroup@, @Bind@, @Sig@, @Bind@.
 {-# LANGUAGE FlexibleContexts #-}
 {-# LANGUAGE UndecidableInstances #-} -- Note [Pass sensitive types]
                                       -- in module PlaceHolder
+{-# LANGUAGE TypeFamilies #-}
 {-# LANGUAGE ConstraintKinds #-}
 {-# LANGUAGE BangPatterns #-}
 
@@ -324,7 +325,8 @@ data PatSynBind idL idR
                                                -- ^ Formal parameter names
           psb_def  :: LPat idR,                -- ^ Right-hand side
           psb_dir  :: HsPatSynDir idR          -- ^ Directionality
-  }
+        }
+
 deriving instance (DataId idL, DataId idR) => Data (PatSynBind idL idR)
 
 {-
@@ -779,7 +781,6 @@ deriving instance (DataId name) => Data (IPBind name)
 
 instance (SourceTextX p, OutputableBndrId p) => Outputable (HsIPBinds p) where
   ppr (IPBinds bs ds) = pprDeeperList vcat (map ppr bs)
-                        $$ whenPprDebug (ppr ds)
 
 instance (SourceTextX p, OutputableBndrId p ) => Outputable (IPBind p) where
   ppr (IPBind lr rhs) = name <+> equals <+> pprExpr (unLoc rhs)
@@ -854,7 +855,7 @@ data Sig pass
         -- the desired Id itself, replete with its name, type
         -- and IdDetails.  Otherwise it's just like a type
         -- signature: there should be an accompanying binding
-  | IdSig Id
+  | IdSig (IdSigId pass)
 
         -- | An ordinary fixity declaration
         --
@@ -1063,7 +1064,9 @@ ppr_sig (TypeSig vars ty)    = pprVarSig (map unLoc vars) (ppr ty)
 ppr_sig (ClassOpSig is_deflt vars ty)
   | is_deflt                 = text "default" <+> pprVarSig (map unLoc vars) (ppr ty)
   | otherwise                = pprVarSig (map unLoc vars) (ppr ty)
-ppr_sig (IdSig id)           = pprVarSig [id] (ppr (varType id))
+ppr_sig (IdSig id)           = case getVarType id of
+  Nothing -> ppr id
+  Just t  -> pprVarSig [id] (ppr t)
 ppr_sig (FixSig fix_sig)     = ppr fix_sig
 ppr_sig (SpecSig var ty inl@(InlinePragma { inl_inline = spec }))
   = pragSrcBrackets (inl_src inl) pragmaSrc (pprSpec (unLoc var)
diff --git a/compiler/hsSyn/HsDecls.hs b/compiler/hsSyn/HsDecls.hs
index 55d43fd058..dca809f7d1 100644
--- a/compiler/hsSyn/HsDecls.hs
+++ b/compiler/hsSyn/HsDecls.hs
@@ -11,6 +11,7 @@
                                       -- in module PlaceHolder
 {-# LANGUAGE ConstraintKinds #-}
 {-# LANGUAGE FlexibleInstances #-}
+{-# LANGUAGE TypeFamilies #-}
 
 -- | Abstract syntax of global declarations.
 --
@@ -540,7 +541,6 @@ data TyClDecl pass
 
 deriving instance (DataId id) => Data (TyClDecl id)
 
-
 -- Simple classifiers for TyClDecl
 -- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 
@@ -644,7 +644,6 @@ hsDeclHasCusk (ClassDecl { tcdTyVars = tyvars }) = hsTvbAllKinded tyvars
 
 instance (SourceTextX pass, OutputableBndrId pass)
        => Outputable (TyClDecl pass) where
-
     ppr (FamDecl { tcdFam = decl }) = ppr decl
     ppr (SynDecl { tcdLName = ltycon, tcdTyVars = tyvars, tcdFixity = fixity
                  , tcdRhs = rhs })
@@ -714,7 +713,6 @@ pprTyClDeclFlavour (FamDecl { tcdFam = FamilyDecl { fdInfo = info }})
 pprTyClDeclFlavour (DataDecl { tcdDataDefn = HsDataDefn { dd_ND = nd } })
   = ppr nd
 
-
 {- Note [Complete user-supplied kind signatures]
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 We kind-check declarations differently if they have a complete, user-supplied
diff --git a/compiler/hsSyn/HsExpr.hs b/compiler/hsSyn/HsExpr.hs
index 333ca32d72..87a43797e6 100644
--- a/compiler/hsSyn/HsExpr.hs
+++ b/compiler/hsSyn/HsExpr.hs
@@ -10,7 +10,8 @@
                                       -- in module PlaceHolder
 {-# LANGUAGE ConstraintKinds #-}
 {-# LANGUAGE ExistentialQuantification #-}
-{-# LANGUAGE DeriveFunctor #-}
+{-# LANGUAGE DeriveFunctor, DeriveFoldable, DeriveTraversable #-}
+{-# LANGUAGE TypeFamilies #-}
 
 -- | Abstract Haskell syntax for expressions.
 module HsExpr where
@@ -34,7 +35,7 @@ import CoreSyn
 import DynFlags ( gopt, GeneralFlag(Opt_PrintExplicitCoercions) )
 import Name
 import NameSet
-import RdrName  ( GlobalRdrEnv )
+import RdrName  ( GlobalRdrEnv, RdrName )
 import BasicTypes
 import ConLike
 import SrcLoc
@@ -434,7 +435,7 @@ data HsExpr p
   --             'ApiAnnotation.AnnClose'
 
   -- For details on above see note [Api annotations] in ApiAnnotation
-  | HsDo        (HsStmtContext Name)     -- The parameterisation is unimportant
+  | HsDo        (HsStmtContext (DoName p))     -- The parameterisation is unimportant
                                          -- because in this context we never use
                                          -- the PatGuard or ParStmt variant
                 (Located [ExprLStmt p]) -- "do":one or more stmts
@@ -482,7 +483,6 @@ data HsExpr p
   --
   --  - 'ApiAnnotation.AnnKeywordId' : 'ApiAnnotation.AnnOpen' @'{'@,
   --         'ApiAnnotation.AnnDotdot','ApiAnnotation.AnnClose' @'}'@
-
   -- For details on above see note [Api annotations] in ApiAnnotation
   | RecordUpd
       { rupd_expr :: LHsExpr p
@@ -833,7 +833,8 @@ pprBinds b = pprDeeper (ppr b)
 ppr_lexpr :: (SourceTextX p, OutputableBndrId p) => LHsExpr p -> SDoc
 ppr_lexpr e = ppr_expr (unLoc e)
 
-ppr_expr :: forall p. (SourceTextX p, OutputableBndrId p) => HsExpr p -> SDoc
+ppr_expr :: forall p. (SourceTextX p, OutputableBndrId p)
+         => HsExpr p -> SDoc
 ppr_expr (HsVar (L _ v))  = pprPrefixOcc v
 ppr_expr (HsUnboundVar uv)= pprPrefixOcc (unboundVarOcc uv)
 ppr_expr (HsConLikeOut c) = pprPrefixOcc c
@@ -859,6 +860,7 @@ ppr_expr (OpApp e1 op _ e2)
   = pp_prefixly
 
   where
+    should_print_infix :: HsExpr p -> Maybe SDoc
     should_print_infix (HsVar (L _ v)) = Just (pprInfixOcc v)
     should_print_infix (HsConLikeOut c)= Just (pprInfixOcc (conLikeName c))
     should_print_infix (HsRecFld f)    = Just (pprInfixOcc f)
@@ -891,6 +893,7 @@ ppr_expr (SectionL expr op)
 
     pp_prefixly = hang (hsep [text " \\ x_ ->", ppr op])
                        4 (hsep [pp_expr, text "x_ )"])
+    pp_infixly :: OutputableBndr a => a -> SDoc
     pp_infixly v = (sep [pp_expr, pprInfixOcc v])
 
 ppr_expr (SectionR op expr)
@@ -905,6 +908,7 @@ ppr_expr (SectionR op expr)
 
     pp_prefixly = hang (hsep [text "( \\ x_ ->", ppr op, text "x_"])
                        4 (pp_expr <> rparen)
+    pp_infixly :: OutputableBndr a => a -> SDoc
     pp_infixly v = sep [pprInfixOcc v, pp_expr]
 
 ppr_expr (ExplicitTuple exprs boxity)
@@ -1992,7 +1996,7 @@ pprStmt (RecStmt { recS_stmts = segment, recS_rec_ids = rec_ids
          , whenPprDebug (vcat [ text "rec_ids=" <> ppr rec_ids
                             , text "later_ids=" <> ppr later_ids])]
 
-pprStmt (ApplicativeStmt args mb_join _)
+pprStmt (ApplicativeStmt args mb_join c)
   = getPprStyle $ \style ->
       if userStyle style
          then pp_for_user
@@ -2010,6 +2014,7 @@ pprStmt (ApplicativeStmt args mb_join _)
    flattenStmt (L _ (ApplicativeStmt args _ _)) = concatMap flattenArg args
    flattenStmt stmt = [ppr stmt]
 
+   flattenArg :: forall a r. (a, ApplicativeArg idL r) -> [SDoc]
    flattenArg (_, ApplicativeArgOne pat expr isBody)
      | isBody =  -- See Note [Applicative BodyStmt]
      [ppr (BodyStmt expr noSyntaxExpr noSyntaxExpr (panic "pprStmt")
@@ -2421,7 +2426,7 @@ data HsMatchContext id -- Not an extensible tag
   | ThPatSplice            -- ^A Template Haskell pattern splice
   | ThPatQuote             -- ^A Template Haskell pattern quotation [p| (a,b) |]
   | PatSyn                 -- ^A pattern synonym declaration
-  deriving Functor
+  deriving (Functor, Foldable, Traversable)
 deriving instance (Data id) => Data (HsMatchContext id)
 
 instance OutputableBndr id => Outputable (HsMatchContext id) where
@@ -2437,6 +2442,7 @@ instance OutputableBndr id => Outputable (HsMatchContext id) where
   ppr ThPatQuote            = text "ThPatQuote"
   ppr PatSyn                = text "PatSyn"
 
+
 isPatSynCtxt :: HsMatchContext id -> Bool
 isPatSynCtxt ctxt =
   case ctxt of
@@ -2458,7 +2464,7 @@ data HsStmtContext id
   | PatGuard (HsMatchContext id)     -- ^Pattern guard for specified thing
   | ParStmtCtxt (HsStmtContext id)   -- ^A branch of a parallel stmt
   | TransStmtCtxt (HsStmtContext id) -- ^A branch of a transform stmt
-  deriving Functor
+  deriving (Functor, Foldable, Traversable)
 deriving instance (Data id) => Data (HsStmtContext id)
 
 isListCompExpr :: HsStmtContext id -> Bool
diff --git a/compiler/hsSyn/HsExpr.hs-boot b/compiler/hsSyn/HsExpr.hs-boot
index bac8a5a183..2ef8dbc9a5 100644
--- a/compiler/hsSyn/HsExpr.hs-boot
+++ b/compiler/hsSyn/HsExpr.hs-boot
@@ -5,6 +5,7 @@
 {-# LANGUAGE ConstraintKinds #-}
 {-# LANGUAGE RoleAnnotations #-}
 {-# LANGUAGE ExistentialQuantification #-}
+{-# LANGUAGE TypeFamilies #-} -- needed to use OutputableBndrId
 
 module HsExpr where
 
diff --git a/compiler/hsSyn/HsExprBin.hs b/compiler/hsSyn/HsExprBin.hs
new file mode 100644
index 0000000000..1bf4b052f9
--- /dev/null
+++ b/compiler/hsSyn/HsExprBin.hs
@@ -0,0 +1,118 @@
+module HsExprBin
+  ( getModuleSplicesPath
+  , whenSet
+  , HsSpliceData(..)
+  , nonEmptyHsSpliceData
+  , emptyHsSpliceData
+  , SpliceResult(..)
+  , recordSpliceResult
+  , lookupSpliceResult
+  , exprSE2PS
+  , declSE2PS
+  , exprPS2SE
+  , declPS2SE
+  , handleUnsupported
+  ) where
+
+import Binary
+import GhcPrelude
+import HsDecls
+import HsExpr
+-- split into several modules because it was otherwise taking
+-- too long and too much memory to compile.
+import HsExprBin_Conversions
+import HsExprBin_Instances ()
+import HsExtension
+import Module
+import Outputable
+import SrcLoc
+import TcRnTypes
+
+import qualified Data.Map.Strict as Map
+import System.FilePath
+
+-- * .hs-splice file contents
+
+getModuleSplicesPath :: FilePath -> Module -> FilePath
+getModuleSplicesPath splicesDir m = splicesDir
+  </> toPath (moduleNameString (moduleName m)) <.> "hs-splice"
+
+  where toPath = map (\c -> if c == '.' then '/' else c)
+
+whenSet :: Monad m => Maybe a -> (a -> m b) -> m b -> m b
+whenSet m j n = maybe n j m
+
+newtype HsSpliceData = HsSpliceData { hsSpliceMap :: Map.Map SrcSpan SpliceResult }
+
+emptyHsSpliceData :: HsSpliceData
+emptyHsSpliceData = HsSpliceData Map.empty
+
+nonEmptyHsSpliceData :: HsSpliceData -> Bool
+nonEmptyHsSpliceData = not . Map.null . hsSpliceMap
+
+data SpliceResult
+  = SRExpr  (LHsExpr GhcSe)
+  | SRDecls [LHsDecl GhcSe] -- TODO: change to HsGroup ?
+  -- TODO: add patterns and types?
+
+instance Binary SpliceResult where
+  put_ bh r = case r of
+    SRExpr e -> putByte bh 0 >> put_ bh e
+    SRDecls ds -> putByte bh 1 >> put_ bh ds
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> SRExpr <$> get bh
+      1 -> SRDecls <$> get bh
+      _ -> panic "Binary SpliceResult: unknown tag"
+
+instance Binary HsSpliceData where
+  put_ bh (HsSpliceData m) = put_ bh (Map.toList m)
+  get bh = (\l -> HsSpliceData (Map.fromList l)) <$> get bh
+
+recordSpliceResult :: SrcSpan -> SpliceResult -> HsSpliceData -> HsSpliceData
+recordSpliceResult loc res (HsSpliceData m) = HsSpliceData (Map.insert loc res m)
+
+lookupSpliceResult :: SrcSpan -> HsSpliceData -> Maybe SpliceResult
+lookupSpliceResult loc (HsSpliceData m) = Map.lookup loc m
+
+-- * High-level conversion interface
+
+-- * Converting Se -> Ps
+
+exprSE2PS :: LHsExpr GhcSe -> RnM (ConvResult (LHsExpr GhcPs))
+exprSE2PS = runConv . cvLHsExpr
+
+declSE2PS :: LHsDecl GhcSe -> RnM (ConvResult (LHsDecl GhcPs))
+declSE2PS = runConv . cvLHsDecl
+
+-- * Converting Ps -> Se
+
+exprPS2SE :: LHsExpr GhcPs -> RnM (ConvResult (LHsExpr GhcSe))
+exprPS2SE = runConv . cvLHsExpr
+
+declPS2SE :: LHsDecl GhcPs -> RnM (ConvResult (LHsDecl GhcSe))
+declPS2SE = runConv . cvLHsDecl
+
+-- * Error reporting
+
+-- | Panics with a nice error when we encounter an unsupported
+--   construct, or returns the actual result if the conversion
+--   succeeded.
+handleUnsupported
+  :: Located SDoc -- ^ TH expression that got evaluated
+  -> Maybe SDoc -- ^ code resulting from the evaluation of the 1st arg
+  -> ConvResult a -- ^ result of the conversion
+  -> RnM a
+handleUnsupported (L loc thDoc) resDoc convRes = case convRes of
+  ConvOK a -> pure a
+  ConvError (ConvUnsupported conName tyName subexprDoc) ->
+    pprPanic "HsExprBin.handleUnsupported" . vcat $
+      [ text "GHC encountered a Haskell construct not supported by -{load, save}-splices:"
+      , nest 4 $ subexprDoc <> text (" - constructor " ++ conName ++ " of type " ++ tyName)
+      , text "while evaluating the following expression from "  <> ppr loc <> text ":"
+      , nest 4 $ thDoc
+      ] ++
+      maybe [] (\d -> [text "which resulted in:" , nest 4 d]) resDoc
+
+  ConvError (ConvFailure errorStr) -> panic errorStr
diff --git a/compiler/hsSyn/HsExprBin.hs-boot b/compiler/hsSyn/HsExprBin.hs-boot
new file mode 100644
index 0000000000..964847e097
--- /dev/null
+++ b/compiler/hsSyn/HsExprBin.hs-boot
@@ -0,0 +1,4 @@
+module HsExprBin where
+
+data HsSpliceData
+emptyHsSpliceData :: HsSpliceData
\ No newline at end of file
diff --git a/compiler/hsSyn/HsExprBin_Conversions.hs b/compiler/hsSyn/HsExprBin_Conversions.hs
new file mode 100644
index 0000000000..d54bd2a7d3
--- /dev/null
+++ b/compiler/hsSyn/HsExprBin_Conversions.hs
@@ -0,0 +1,977 @@
+{-# LANGUAGE ConstraintKinds, DeriveFunctor #-}
+{-# LANGUAGE FlexibleContexts, FlexibleInstances #-}
+{-# LANGUAGE MultiParamTypeClasses #-}
+{-# LANGUAGE TypeFamilies, TypeSynonymInstances #-}
+module HsExprBin_Conversions where
+
+import Control.Applicative
+import Control.Monad
+import Control.Monad.IO.Class
+import Data.Char (isDigit)
+import Data.List (intercalate)
+import Data.Maybe
+import Data.Traversable
+
+import Bag (mapBagM)
+import BasicTypes (Fixity)
+import Class
+import ConLike
+import CoreSyn ( Tickish(..) )
+import DynFlags
+import FastString
+import GhcPrelude
+import HsBinds
+import HsDecls
+import HsExpr
+import HsExtension
+import HsLit
+import HsPat
+import HsTypes
+import Module
+import Name
+import Outputable
+import PackageConfig
+import Packages
+import PlaceHolder
+import RdrName
+import SeName
+import SrcLoc
+import TcRnTypes
+import IfaceType
+import ToIface (toIfaceType)
+import TcEvidence (HsWrapper)
+import TyCoRep (Type(..), TyLit(..), Kind, Coercion)
+
+import qualified NameSet as NameSet
+
+data ConvError
+  = ConvUnsupported String String SDoc
+  -- constructor name, type name, text rendering
+  -- of the unsupported subexpression
+  | ConvFailure String
+
+data ConvResult a
+  = ConvError ConvError
+  | ConvOK a
+  deriving Functor
+-- * Conversion utilities
+
+newtype Conv a = Conv { runConv :: RnM (ConvResult a) }
+
+instance Functor Conv where
+  fmap f (Conv k) = Conv (fmap (fmap f) k)
+
+instance Applicative Conv where
+  pure = Conv . return . ConvOK
+  (<*>) = ap
+
+instance Monad Conv where
+  return = pure
+
+  Conv mx >>= f = Conv $ mx >>= \cvx -> case cvx of
+    ConvOK x    -> runConv (f x)
+    ConvError e -> pure (ConvError e)
+
+unsupported :: String -- ^ constructor name
+            -> String -- ^ type name
+            -> SDoc   -- ^ textual rendering of the unsupported subexpression
+            -> Conv a
+unsupported con ty subexpr = Conv $
+  pure (ConvError $ ConvUnsupported con ty subexpr)
+
+badInput :: String -> Conv a
+badInput str = Conv $ pure (ConvError $ ConvFailure str)
+
+liftRn :: RnM a -> Conv a
+liftRn = Conv . fmap ConvOK
+
+class ConvertType t u where
+  convertType :: t -> Conv u
+
+class ConvertName a b where
+  convertName :: a -> Conv b
+
+instance ConvertName a b => ConvertName [a] [b] where
+  convertName = traverse convertName
+
+instance ConvertName a b => ConvertName (Either e a) (Either e b) where
+  convertName = traverse convertName
+
+instance ConvertName a b => ConvertName (HsMatchContext a) (HsMatchContext b) where
+  convertName = traverse convertName
+
+instance ConvertName a b => ConvertName (HsStmtContext a) (HsStmtContext b) where
+  convertName = traverse convertName
+
+instance ConvertName a b => ConvertName (Maybe a) (Maybe b) where
+  convertName = traverse convertName
+
+instance ConvertType Type IfaceType where
+  convertType = pure . toIfaceType
+
+instance ConvertType IfaceType Type where
+  convertType (IfaceLitTy n) = pure $ LitTy (go n)
+    where go (IfaceNumTyLit a) = NumTyLit a
+          go (IfaceStrTyLit a) = StrTyLit a
+  convertType e@(IfaceFreeTyVar {}) = unsupported "IfaceFreeTyVar" "IfaceType" (ppr e)
+  convertType e@(IfaceTyVar {}) = unsupported "IfaceTyVar" "IfaceType" (ppr e)
+  convertType e@(IfaceAppTy {}) = unsupported "IfaceAppTy" "IfaceType" (ppr e)
+  convertType e@(IfaceFunTy {}) = unsupported "IfaceFunTy" "IfaceType" (ppr e)
+  convertType e@(IfaceDFunTy {}) = unsupported "IfaceDFunTy" "IfaceType" (ppr e)
+  convertType e@(IfaceForAllTy {}) = unsupported "IfaceForAllTy" "IfaceType" (ppr e)
+  convertType e@(IfaceTyConApp {}) = unsupported "IfaceTyConApp" "IfaceType" (ppr e)
+  convertType e@(IfaceCastTy {}) = unsupported "IfaceCastTy" "IfaceType" (ppr e)
+  convertType e@(IfaceCoercionTy {}) = unsupported "IfaceCoercion" "IfaceType" (ppr e)
+  convertType e@(IfaceTupleTy {}) = unsupported "IfaceTupleTy" "IfaceType" (ppr e)
+
+
+instance ConvertName RdrName SeName where
+  convertName = pure . mkSeName
+
+instance ConvertName SeName RdrName where
+  convertName (SeName n) = case n of
+    Orig mod occn -> do
+      -- TODO: introduce some caching here, to avoid doing the
+      --       searchPackageId dance too often.
+
+      {- liftIO . putStrLn $
+        "/!!!\\ Processing name: module=" ++ moduleNameString (moduleName mod) ++
+        ", occname = " ++ occNameString occn -}
+      currentMod <- liftRn getModule
+      {- liftIO . putStrLn $
+        "Current module (" ++ moduleNameString (moduleName currentMod) ++ ") is in: " ++
+        unitIdString (moduleUnitId currentMod) -}
+
+      if samePackages currentMod mod
+        then let newMod = mod { moduleUnitId = moduleUnitId currentMod } in
+               -- liftIO $ putStrLn ("using the current module's unit id for name coming from: " ++ moduleNameString (moduleName mod)) >>
+               pure (Orig newMod occn)
+        else do mnewmod <- liftRn (findEquivalentModule mod)
+                case mnewmod of
+                  Nothing   -> {- liftIO (putStrLn "keeping old name")
+                            >> -} pure (Orig mod occn)
+                  Just mod' -> {- liftIO (putStrLn "using new unitid!")
+                            >> -} pure (Orig mod' occn)
+
+    _             -> pure n
+
+    where samePackages mod1 mod2 = fromMaybe False $ do -- maybe monad
+            let str1 = unitIdString (moduleUnitId mod1)
+                str2 = unitIdString (moduleUnitId mod2)
+            (pkg1, ver1, _mhash1) <- parseUnitId' str1
+            (pkg2, ver2, _mhash2) <- parseUnitId' str2
+            return (pkg1 == pkg2 && ver1 == ver2)
+
+instance ConvertName Name SeName where
+  convertName n = pure $ mkSeName (nameRdrName n)
+
+instance ConvertName SeName Name where
+  convertName (SeName n) = case isExact_maybe n of
+    Just a -> pure a
+    _      -> badInput "convertName :: SeName -> Name: non exact RdrName in SeName"
+
+instance ConvertName a b => ConvertName (Located a) (Located b) where
+  convertName = traverse convertName
+
+type TypeConstraints p q =
+  ( ConvertType (LitType p) (LitType q)
+  , ConvertName (IdP p) (IdP q)
+  , ConvertName (DoName p) (DoName q)
+  , ConvertName (NameOrRdrName (IdP p)) (NameOrRdrName (IdP q))
+  , ConvertName (RdrOrSeName p) (RdrOrSeName q)
+  , PostRn p NameSet.NameSet ~ PostRn q NameSet.NameSet
+  , PostRn p (Located Name) ~ PostRn q (Located Name)
+  , PostRn p [Name] ~ PostRn q [Name]
+  , PostRn p Bool ~ PostRn q Bool
+  , PostRn p (IdP p) ~ PostRn q (IdP q)
+  , PostRn q Fixity ~ PostRn p Fixity
+  , PostTc p Kind ~ PostTc q Kind
+  , PostTc p (IdP p) ~ PostTc q (IdP q)
+  , PostTc p [Type] ~ PostTc q [Type]
+  , PostTc p HsWrapper ~ PostTc q HsWrapper
+  , PostTc p ConLike ~ PostTc q ConLike
+  , PostTc p [ConLike] ~ PostTc q [ConLike]
+  , PostTc q Coercion ~ PostTc p Coercion
+  , ConvertIdX p q
+  , OutputableBndrId p
+  , SourceTextX p
+  )
+
+-- * Actual conversion implementation
+
+-- declarations
+
+cvLHsDecl :: TypeConstraints p q => LHsDecl p -> Conv (LHsDecl q)
+cvLHsDecl = traverse cvHsDecl
+
+cvHsDecl :: TypeConstraints p q => HsDecl p -> Conv (HsDecl q)
+cvHsDecl (TyClD a) = TyClD <$> cvTyClDecl a
+cvHsDecl (InstD a) = InstD <$> cvInstDecl a
+cvHsDecl (DerivD a) = DerivD <$> cvDerivDecl a
+cvHsDecl (ValD a) = ValD <$> cvHsBindLR a
+cvHsDecl (SigD a) = SigD <$> cvSig a
+cvHsDecl (DefD a) = DefD <$> cvDefaultDecl a
+cvHsDecl (ForD a) = ForD <$> cvForeignDecl a
+cvHsDecl (WarningD a) = WarningD <$> cvWarningDecls a
+cvHsDecl (RoleAnnotD a) = RoleAnnotD <$> cvRoleAnnotDecl a
+cvHsDecl (AnnD a) = AnnD <$> cvAnnDecl a
+cvHsDecl (RuleD a) = RuleD <$> cvRuleDecls a
+cvHsDecl (SpliceD a) = SpliceD <$> cvSpliceDecl a
+cvHsDecl (DocD a) = pure (DocD a)
+cvHsDecl (VectD a) = VectD <$> cvVectDecl a
+
+cvAnnDecl :: TypeConstraints p q => AnnDecl p -> Conv (AnnDecl q)
+cvAnnDecl (HsAnnotation a b c) = HsAnnotation a <$> cvAnnProvenance b <*> cvLHsExpr c
+
+cvInstDecl :: TypeConstraints p q => InstDecl p -> Conv (InstDecl q)
+cvInstDecl (ClsInstD a) = ClsInstD <$> cvClsInstDecl a
+cvInstDecl (DataFamInstD a) = DataFamInstD <$> cvDataFamInstDecl a
+cvInstDecl (TyFamInstD a) = TyFamInstD <$> cvTyFamInstDecl a
+
+cvClsInstDecl :: TypeConstraints p q => ClsInstDecl p -> Conv (ClsInstDecl q)
+cvClsInstDecl (ClsInstDecl a b c d e f ) =
+  ClsInstDecl
+    <$> cvHsImplicitBndrs (traverse cvType) a
+    <*> mapBagM (traverse cvHsBindLR) b
+    <*> traverse (traverse cvSig) c
+    <*> traverse (traverse cvTyFamInstDecl) d
+    <*> traverse (traverse cvDataFamInstDecl) e
+    <*> pure f
+
+cvDerivDecl :: TypeConstraints p q => DerivDecl p -> Conv (DerivDecl q)
+cvDerivDecl (DerivDecl a b c) =
+  DerivDecl <$> cvHsImplicitBndrs (traverse cvType) a <*> pure b <*> pure c
+
+cvTyClDecl :: TypeConstraints p q => TyClDecl p -> Conv (TyClDecl q)
+cvTyClDecl (FamDecl a) = FamDecl <$> cvFamilyDecl a
+cvTyClDecl (SynDecl a b c d e) =
+  SynDecl
+    <$> convertName a
+    <*> cvLHsQTyVars b <*> pure c
+    <*> traverse cvType d <*> pure e
+cvTyClDecl (DataDecl a b c d e f) =
+  DataDecl
+    <$> convertName a
+    <*> cvLHsQTyVars b <*> pure c
+    <*> cvHsDataDefn d <*> pure e <*> pure f
+cvTyClDecl (ClassDecl a b c d e f g h i j k) =
+  ClassDecl
+    <$> traverse (traverse (traverse cvType)) a
+    <*> convertName b
+    <*> cvLHsQTyVars c
+    <*> pure d
+    <*> traverse (traverse cvFunDep) e
+    <*> traverse (traverse cvSig) f
+    <*> mapBagM (traverse cvHsBindLR) g
+    <*> traverse (traverse cvFamilyDecl) h
+    <*> traverse (traverse $ cvFamEqn cvLHsQTyVars (traverse cvType)) i
+    <*> pure j <*> pure k
+
+cvRoleAnnotDecl
+  :: TypeConstraints p q => RoleAnnotDecl p -> Conv (RoleAnnotDecl q)
+cvRoleAnnotDecl (RoleAnnotDecl a b) = RoleAnnotDecl <$> convertName a <*> pure b
+
+cvRuleDecls :: TypeConstraints p q => RuleDecls p -> Conv (RuleDecls q)
+cvRuleDecls (HsRules a b) = HsRules a <$> traverse (traverse cvRuleDecl) b
+
+cvRuleDecl :: TypeConstraints p q => RuleDecl p -> Conv (RuleDecl q)
+cvRuleDecl (HsRule a b c d e f g) =
+  HsRule a b <$> traverse (traverse cvRuleBndr) c <*> cvLHsExpr d
+             <*> pure e <*> cvLHsExpr f <*> pure g
+
+cvSpliceDecl :: TypeConstraints p q => SpliceDecl p -> Conv (SpliceDecl q)
+cvSpliceDecl (SpliceDecl a b) = SpliceDecl <$> traverse cvHsSplice a <*> pure b
+
+cvHsSplice :: TypeConstraints p q => HsSplice p -> Conv (HsSplice q)
+cvHsSplice (HsTypedSplice a b c) = HsTypedSplice a <$> convertName b <*> cvLHsExpr c
+cvHsSplice (HsUntypedSplice a b c) = HsUntypedSplice a <$> convertName b <*> cvLHsExpr c
+cvHsSplice (HsQuasiQuote a b c d) = HsQuasiQuote <$> convertName a <*> convertName b <*> pure c <*> pure d
+cvHsSplice e@(HsSpliced {}) = unsupported "HsSpliced" "HsSplice" (ppr e)
+
+cvRuleBndr :: TypeConstraints p q => RuleBndr p -> Conv (RuleBndr q)
+cvRuleBndr (RuleBndr a) = RuleBndr <$> convertName a
+cvRuleBndr (RuleBndrSig a b) = RuleBndrSig <$> convertName a <*> cvHsSigWcType b
+
+cvFamEqn
+  :: TypeConstraints p q
+  => (a -> Conv c)
+  -> (b -> Conv d)
+  -> FamEqn p a b
+  -> Conv (FamEqn q c d)
+cvFamEqn goPats goRhs (FamEqn a b c d) =
+  FamEqn <$> convertName a <*> goPats b <*> pure c <*> goRhs d
+
+cvFamilyDecl :: TypeConstraints p q => FamilyDecl p -> Conv (FamilyDecl q)
+cvFamilyDecl (FamilyDecl a b c d e f) =
+  FamilyDecl
+    <$> cvFamilyInfo a <*> convertName b
+    <*> cvLHsQTyVars c <*> pure d
+    <*> traverse cvFamilyResultSig e
+    <*> traverse (traverse cvInjectivityAnn) f
+
+cvAnnProvenance :: ConvertName a b => AnnProvenance a -> Conv (AnnProvenance b)
+cvAnnProvenance (ValueAnnProvenance a) = ValueAnnProvenance <$> convertName a
+cvAnnProvenance (TypeAnnProvenance a) = TypeAnnProvenance <$> convertName a
+cvAnnProvenance ModuleAnnProvenance = pure ModuleAnnProvenance
+
+cvInjectivityAnn
+  :: TypeConstraints p q => InjectivityAnn p -> Conv (InjectivityAnn q)
+cvInjectivityAnn (InjectivityAnn a b) =
+  InjectivityAnn <$> convertName a <*> convertName b
+
+cvFamilyResultSig
+  :: TypeConstraints p q => FamilyResultSig p -> Conv (FamilyResultSig q)
+cvFamilyResultSig NoSig = pure NoSig
+cvFamilyResultSig (KindSig a) = KindSig <$> traverse cvType a
+cvFamilyResultSig (TyVarSig a) = TyVarSig <$> traverse cvHsTyVarBndr a
+
+cvFamilyInfo :: TypeConstraints p q => FamilyInfo p -> Conv (FamilyInfo q)
+cvFamilyInfo DataFamily = pure DataFamily
+cvFamilyInfo OpenTypeFamily = pure OpenTypeFamily
+cvFamilyInfo (ClosedTypeFamily a) =
+  ClosedTypeFamily <$> traverse (traverse (traverse (cvFamInstEqn (traverse cvType)))) a
+
+cvFamInstEqn
+  :: TypeConstraints p q
+  => (a -> Conv b)
+  -> FamInstEqn p a
+  -> Conv (FamInstEqn q b)
+cvFamInstEqn f = cvHsImplicitBndrs (cvFamEqn (traverse (traverse cvType)) f)
+
+cvFunDep :: ConvertName a b => FunDep a -> Conv (FunDep b)
+cvFunDep (xs, ys) = (,) <$> convertName xs <*> convertName ys
+
+cvLHsQTyVars :: TypeConstraints p q => LHsQTyVars p -> Conv (LHsQTyVars q)
+cvLHsQTyVars (HsQTvs a b c) = HsQTvs a <$> traverse (traverse cvHsTyVarBndr) b <*> pure c
+
+cvForeignDecl :: TypeConstraints p q => ForeignDecl p -> Conv (ForeignDecl q)
+cvForeignDecl (ForeignImport a b c d) =
+  ForeignImport
+    <$> convertName a
+    <*> cvHsImplicitBndrs (traverse cvType) b
+    <*> pure c <*> pure d
+cvForeignDecl (ForeignExport a b c d) =
+  ForeignExport
+    <$> convertName a
+    <*> cvHsImplicitBndrs (traverse cvType) b
+    <*> pure c <*> pure d
+
+cvDefaultDecl :: TypeConstraints p q => DefaultDecl p -> Conv (DefaultDecl q)
+cvDefaultDecl (DefaultDecl a) = DefaultDecl <$> traverse (traverse cvType) a
+
+cvTyFamInstDecl
+  :: TypeConstraints p q => TyFamInstDecl p -> Conv (TyFamInstDecl q)
+cvTyFamInstDecl (TyFamInstDecl d) =
+  TyFamInstDecl <$> cvFamInstEqn (traverse cvType) d
+
+cvDataFamInstDecl
+  :: TypeConstraints p q => DataFamInstDecl p -> Conv (DataFamInstDecl q)
+cvDataFamInstDecl (DataFamInstDecl d) =
+  DataFamInstDecl <$> cvFamInstEqn cvHsDataDefn d
+
+cvHsDataDefn :: TypeConstraints p q => HsDataDefn p -> Conv (HsDataDefn q)
+cvHsDataDefn (HsDataDefn a b c d e f) =
+  HsDataDefn a
+    <$> traverse (traverse (traverse cvType)) b <*> pure c
+    <*> traverse (traverse cvType) d
+    <*> traverse (traverse cvConDecl) e <*> cvHsDeriving f
+
+cvConDecl :: TypeConstraints p q => ConDecl p -> Conv (ConDecl q)
+cvConDecl (ConDeclGADT a b c) =
+  ConDeclGADT
+    <$> convertName a
+    <*> cvHsImplicitBndrs (traverse cvType) b
+    <*> pure c
+cvConDecl (ConDeclH98 a b c d e) =
+  ConDeclH98
+    <$> convertName a
+    <*> traverse cvLHsQTyVars b
+    <*> traverse (traverse (traverse (traverse cvType))) c
+    <*> cvHsConDeclDetails d
+    <*> pure e
+
+cvHsDeriving :: TypeConstraints p q => HsDeriving p -> Conv (HsDeriving q)
+cvHsDeriving = traverse (traverse (traverse cvHsDerivingClause))
+
+cvHsDerivingClause
+  :: TypeConstraints p q => HsDerivingClause p -> Conv (HsDerivingClause q)
+cvHsDerivingClause (HsDerivingClause a b) =
+  HsDerivingClause a
+    <$> traverse (traverse (cvHsImplicitBndrs (traverse cvType))) b
+
+cvHsConDeclDetails
+  :: TypeConstraints p q => HsConDeclDetails p -> Conv (HsConDeclDetails q)
+cvHsConDeclDetails =
+  cvHsConDetails (traverse cvType)
+                 (traverse (traverse (traverse cvConDeclField)))
+
+cvHsConDetails
+  :: (a -> Conv c) -> (b -> Conv d) -> HsConDetails a b -> Conv (HsConDetails c d)
+cvHsConDetails f _  (PrefixCon a) = PrefixCon <$> traverse f a
+cvHsConDetails _ g     (RecCon a) = RecCon    <$> g a
+cvHsConDetails f _ (InfixCon a b) = InfixCon  <$> f a <*> f b
+
+cvConDeclField :: TypeConstraints p q => ConDeclField p -> Conv (ConDeclField q)
+cvConDeclField (ConDeclField a b c) =
+  ConDeclField <$> traverse (traverse cvFieldOcc) a <*> traverse cvType b
+               <*> pure c
+
+cvWarningDecls :: TypeConstraints p q => WarnDecls p -> Conv (WarnDecls q)
+cvWarningDecls (Warnings a b) =
+  Warnings a <$> traverse (traverse cvWarningDecl) b
+
+cvWarningDecl :: TypeConstraints p q => WarnDecl p -> Conv (WarnDecl q)
+cvWarningDecl (Warning a b) = Warning <$> convertName a <*> pure b
+
+-- expressions
+
+cvLHsExpr
+  :: TypeConstraints p q => LHsExpr p -> Conv (LHsExpr q)
+cvLHsExpr = traverse cvHsExpr
+
+cvHsExpr
+  :: TypeConstraints p q => HsExpr p -> Conv (HsExpr q)
+cvHsExpr e = case e of
+  HsVar a -> HsVar <$> convertName a
+  HsUnboundVar a -> pure (HsUnboundVar a)
+  HsConLikeOut a -> pure (HsConLikeOut a)
+  HsRecFld a -> HsRecFld <$> cvAFieldOcc a
+  HsOverLabel a b -> HsOverLabel <$> convertName a <*> pure b
+  HsIPVar a -> pure (HsIPVar a)
+  HsOverLit a -> HsOverLit <$> cvOverLit a
+  HsLit a -> HsLit <$> cvLit a
+  HsLam a -> HsLam <$> cvMatchGroup cvLHsExpr a
+  HsLamCase a -> HsLamCase <$> cvMatchGroup cvLHsExpr a
+  HsApp a b -> HsApp <$> cvLHsExpr a <*> cvLHsExpr b
+  HsAppType a b -> HsAppType <$> cvLHsExpr a <*> cvLHsWcType b
+  OpApp a b c d -> OpApp <$> cvLHsExpr a <*> cvLHsExpr b
+                         <*> pure c <*> cvLHsExpr d
+  NegApp a b -> NegApp <$> cvLHsExpr a <*> cvSyntaxExpr b
+  HsPar a -> HsPar <$> cvLHsExpr a
+  SectionL a b -> SectionL <$> cvLHsExpr a <*> cvLHsExpr b
+  SectionR a b -> SectionR <$> cvLHsExpr a <*> cvLHsExpr b
+  ExplicitTuple a b -> ExplicitTuple <$> traverse (traverse cvHsTupArg) a <*> pure b
+  ExplicitSum a b c d -> ExplicitSum a b <$> cvLHsExpr c <*> pure d
+  ExplicitList a b c -> ExplicitList a <$> traverse cvSyntaxExpr b <*> traverse cvLHsExpr c
+  HsCase a b -> HsCase <$> cvLHsExpr a <*> cvMatchGroup cvLHsExpr b
+  HsIf a b c d -> HsIf <$> traverse cvSyntaxExpr a
+                       <*> cvLHsExpr b <*> cvLHsExpr c <*> cvLHsExpr d
+  HsMultiIf a b -> HsMultiIf a <$> traverse (traverse (cvGRHS cvLHsExpr)) b
+  HsLet a b -> HsLet <$> traverse cvHsLocalBinds a <*> cvLHsExpr b
+  HsDo a b c -> HsDo
+    <$> convertName a <*> traverse (traverse (traverse (cvStmtLR cvLHsExpr))) b
+    <*> pure c
+  RecordCon a b c d -> RecordCon
+    <$> convertName a <*> pure b <*> pure c <*> cvRecordBinds d
+  RecordUpd a b c d e f -> RecordUpd
+    <$> cvLHsExpr a
+    <*> traverse (traverse cvHsRecUpdField) b
+    <*> pure c <*> pure d <*> pure e <*> pure f
+  ExprWithTySig a b -> ExprWithTySig <$> cvLHsExpr a <*> cvHsSigWcType b
+  ArithSeq a b c -> ArithSeq a <$> traverse cvSyntaxExpr b <*> cvArithSeqInfo c
+  HsSCC a b c -> HsSCC a b <$> cvLHsExpr c
+  HsCoreAnn a b c -> HsCoreAnn a b <$> cvLHsExpr c
+  HsStatic a b -> HsStatic a <$> cvLHsExpr b
+  EWildPat -> pure EWildPat
+  EAsPat a b -> EAsPat <$> convertName a <*> cvLHsExpr b
+  EViewPat a b -> EViewPat <$> cvLHsExpr a <*> cvLHsExpr b
+  ELazyPat a -> ELazyPat <$> cvLHsExpr a
+  HsProc a b -> HsProc <$> traverse cvPat a <*> traverse cvHsCmdTop b
+  HsBinTick a b c -> HsBinTick a b <$> cvLHsExpr c
+  HsTickPragma a b c d -> HsTickPragma a b c <$> cvLHsExpr d
+  HsSpliceE a -> HsSpliceE <$> cvHsSplice a
+  HsBracket a -> HsBracket <$> cvHsBracket a
+  HsTick a b -> HsTick <$> cvTickish a <*> cvLHsExpr b
+  e@(ExplicitPArr {}) -> unsupported "ExplicitPArr" "HsExpr" (ppr e)
+  e@(PArrSeq {})      -> unsupported "PArrSeq" "HsExpr" (ppr e)
+  e@(HsArrApp {})     -> unsupported "HsArrApp" "HsExpr" (ppr e)
+  e@(HsArrForm {})    -> unsupported "HsArrForm" "HsExpr" (ppr e)
+  e@(HsAppTypeOut {}) -> unsupported "HsAppTypeOut" "HsExpr" (ppr e)
+  e@(ExprWithTySigOut {}) -> unsupported "ExprWithTySigOut" "HsExpr" (ppr e)
+  e@(HsWrap {}) -> unsupported "HsWrap" "HsExpr" (ppr e)
+  e@(HsRnBracketOut {}) -> unsupported "HsRnBracketOut" "HsExpr" (ppr e)
+  e@(HsTcBracketOut {}) -> unsupported "HsTcBracketOut" "HsExpr" (ppr e)
+
+cvHsBracket :: TypeConstraints p q => HsBracket p -> Conv (HsBracket q)
+cvHsBracket (ExpBr a) = ExpBr <$> cvLHsExpr a
+cvHsBracket (PatBr a) = PatBr <$> traverse cvPat a
+cvHsBracket (DecBrL a) = DecBrL <$> traverse (traverse cvHsDecl) a
+cvHsBracket (DecBrG a) = DecBrG <$> cvHsGroup a
+cvHsBracket (TypBr a) = TypBr <$> traverse cvType a
+cvHsBracket (VarBr a b) = VarBr a <$> convertName b
+cvHsBracket (TExpBr a) = TExpBr <$> cvLHsExpr a
+
+cvTickish :: ConvertName a b => Tickish a -> Conv (Tickish b)
+cvTickish (ProfNote a b c) = pure (ProfNote a b c)
+cvTickish (HpcTick a b) = pure (HpcTick a b)
+cvTickish (Breakpoint a b) = Breakpoint a <$> convertName b
+cvTickish (SourceNote a b) = pure (SourceNote a b)
+
+cvHsGroup :: TypeConstraints p q => HsGroup p -> Conv (HsGroup q)
+cvHsGroup (HsGroup a b c d e f g h i j k l) = HsGroup
+  <$> cvHsValBindsLR a <*> traverse (traverse cvSpliceDecl) b
+  <*> traverse cvTyClGroup c
+  <*> traverse (traverse cvDerivDecl) d
+  <*> traverse (traverse cvFixitySig) e
+  <*> traverse (traverse cvDefaultDecl) f
+  <*> traverse (traverse cvForeignDecl) g
+  <*> traverse (traverse cvWarningDecls) h
+  <*> traverse (traverse cvAnnDecl) i
+  <*> traverse (traverse cvRuleDecls) j
+  <*> traverse (traverse cvVectDecl) k
+  <*> pure l
+
+cvVectDecl :: TypeConstraints p q => VectDecl p -> Conv (VectDecl q)
+cvVectDecl (HsVect a b c) = HsVect a <$> convertName b <*> cvLHsExpr c
+cvVectDecl (HsNoVect a b) = HsNoVect a <$> convertName b
+cvVectDecl (HsVectTypeIn a b c d) = HsVectTypeIn a b
+  <$> convertName c <*> traverse convertName d
+cvVectDecl (HsVectClassIn a b) = HsVectClassIn a <$> convertName b
+cvVectDecl (HsVectInstIn a) = HsVectInstIn
+  <$> cvHsImplicitBndrs (traverse cvType) a
+cvVectDecl e@(HsVectTypeOut {}) = unsupported "HsVectTypeOut" "VectDecl" (ppr e)
+cvVectDecl e@(HsVectClassOut {}) = unsupported "HsVectClassOut" "VectDecl" (ppr e)
+cvVectDecl e@(HsVectInstOut {}) = unsupported "HsVectInstOut" "VectDecl" (ppr e)
+
+
+cvTyClGroup :: TypeConstraints p q => TyClGroup p -> Conv (TyClGroup q)
+cvTyClGroup (TyClGroup a b c) = TyClGroup
+  <$> traverse (traverse cvTyClDecl) a
+  <*> traverse (traverse cvRoleAnnotDecl) b
+  <*> traverse (traverse cvInstDecl) c
+
+cvHsCmdTop :: TypeConstraints p q => HsCmdTop p -> Conv (HsCmdTop q)
+cvHsCmdTop (HsCmdTop a b c d) = HsCmdTop
+  <$> traverse cvHsCmd a <*> pure b <*> pure c
+  <*> traverse (traverse cvHsExpr) d
+
+cvHsCmd :: TypeConstraints p q => HsCmd p -> Conv (HsCmd q)
+cvHsCmd (HsCmdArrApp a b c d e) = HsCmdArrApp
+  <$> cvLHsExpr a <*> cvLHsExpr b <*> pure c <*> pure d <*> pure e
+cvHsCmd (HsCmdArrForm a b c d) = HsCmdArrForm
+  <$> cvLHsExpr a <*> pure b <*> pure c
+  <*> traverse (traverse cvHsCmdTop) d
+cvHsCmd (HsCmdApp a b) = HsCmdApp <$> traverse cvHsCmd a <*> cvLHsExpr b
+cvHsCmd (HsCmdLam a) = HsCmdLam <$> cvMatchGroup (traverse cvHsCmd) a
+cvHsCmd (HsCmdPar a) = HsCmdPar <$> traverse cvHsCmd a
+cvHsCmd (HsCmdCase a b) = HsCmdCase
+  <$> cvLHsExpr a <*> cvMatchGroup (traverse cvHsCmd) b
+cvHsCmd (HsCmdIf a b c d) = HsCmdIf
+  <$> traverse cvSyntaxExpr a
+  <*> cvLHsExpr b
+  <*> traverse cvHsCmd c
+  <*> traverse cvHsCmd d
+cvHsCmd (HsCmdLet a b) = HsCmdLet
+  <$> traverse cvHsLocalBinds a <*> traverse cvHsCmd b
+cvHsCmd (HsCmdDo a b) = HsCmdDo
+  <$> traverse (traverse (traverse (cvStmtLR (traverse cvHsCmd)))) a
+  <*> pure b
+cvHsCmd e@(HsCmdWrap {}) = unsupported "HsCmdWrap" "HsCmd" (ppr e)
+
+cvArithSeqInfo :: TypeConstraints p q => ArithSeqInfo p -> Conv (ArithSeqInfo q)
+cvArithSeqInfo (From e) = From <$> cvLHsExpr e
+cvArithSeqInfo (FromThen a b) = FromThen <$> cvLHsExpr a <*> cvLHsExpr b
+cvArithSeqInfo (FromTo a b) = FromTo <$> cvLHsExpr a <*> cvLHsExpr b
+cvArithSeqInfo (FromThenTo a b c) = FromThenTo <$> cvLHsExpr a <*> cvLHsExpr b <*> cvLHsExpr c
+
+cvHsTupArg :: TypeConstraints p q => HsTupArg p -> Conv (HsTupArg q)
+cvHsTupArg (Present a) = Present <$> cvLHsExpr a
+cvHsTupArg (Missing a) = pure (Missing a)
+
+cvAFieldOcc
+  :: TypeConstraints p q => AmbiguousFieldOcc p -> Conv (AmbiguousFieldOcc q)
+cvAFieldOcc (Unambiguous a b) = Unambiguous <$> convertName a <*> pure b
+cvAFieldOcc (Ambiguous a b) = Ambiguous <$> convertName a <*> pure b
+
+cvOverLit :: TypeConstraints p q => HsOverLit p -> Conv (HsOverLit q)
+cvOverLit (OverLit a b c d) = OverLit a b <$> cvHsExpr c <*> pure d
+
+cvLit :: TypeConstraints p q => HsLit p -> Conv (HsLit q)
+cvLit (HsChar a b) = pure (HsChar a b)
+cvLit (HsCharPrim a b) = pure (HsCharPrim a b)
+cvLit (HsString a b) = pure (HsString a b)
+cvLit (HsStringPrim a b) = pure (HsStringPrim a b)
+cvLit (HsInt a b) = pure (HsInt a b)
+cvLit (HsIntPrim a b) = pure (HsIntPrim a b)
+cvLit (HsWordPrim a b) = pure (HsWordPrim a b)
+cvLit (HsInt64Prim a b) = pure (HsInt64Prim a b)
+cvLit (HsWord64Prim a b) = pure (HsWord64Prim a b)
+cvLit (HsInteger a b c) = HsInteger a b <$> convertType c
+cvLit (HsRat a b c) = HsRat a b <$> convertType c
+cvLit (HsFloatPrim a b) = pure (HsFloatPrim a b)
+cvLit (HsDoublePrim a b) = pure (HsDoublePrim a b)
+
+cvMatchGroup
+  :: TypeConstraints p q
+  => (a -> Conv b) -> MatchGroup p a -> Conv (MatchGroup q b)
+cvMatchGroup f (MG a b c d) = MG
+  <$> traverse (traverse (traverse (cvMatch f))) a
+  <*> pure b <*> pure c <*> pure d
+
+cvMatch
+  :: TypeConstraints p q
+  => (a -> Conv b) -> Match p a -> Conv (Match q b)
+cvMatch f (Match a b c) = Match
+   <$> convertName a
+   <*> traverse (traverse cvPat) b <*> cvGRHSs f c
+
+cvPat :: TypeConstraints p q => Pat p -> Conv (Pat q)
+cvPat (WildPat a) = pure (WildPat a)
+cvPat (VarPat a) = VarPat <$> convertName a
+cvPat (LazyPat a) = LazyPat <$> traverse cvPat a
+cvPat (AsPat a b) = AsPat <$> convertName a <*> traverse cvPat b
+cvPat (ParPat a) = ParPat <$> traverse cvPat a
+cvPat (BangPat a) = BangPat <$> traverse cvPat a
+cvPat (ListPat a b c) =
+  ListPat <$> traverse (traverse cvPat) a
+          <*> pure b
+          <*> traverse (\(d, e) -> (\x -> (d, x)) <$> cvSyntaxExpr e) c
+cvPat (TuplePat a b c) = TuplePat <$> traverse (traverse cvPat) a
+                                  <*> pure b <*> pure c
+cvPat (SumPat a b c d) = SumPat <$> traverse cvPat a
+                                <*> pure b <*> pure c <*> pure d
+cvPat (ConPatIn a b) = ConPatIn <$> convertName a <*> cvHsConPatDetails b
+cvPat (ViewPat a b c) = ViewPat <$> cvLHsExpr a <*> traverse cvPat b <*> pure c
+cvPat (LitPat a) = LitPat <$> cvLit a
+cvPat (NPat a b c d) =
+  NPat <$> traverse cvOverLit a <*> traverse cvSyntaxExpr b
+       <*> cvSyntaxExpr c <*> pure d
+cvPat (NPlusKPat a b c d e f) =
+  NPlusKPat
+    <$> convertName a
+    <*> traverse cvOverLit b <*> cvOverLit c
+    <*> cvSyntaxExpr d <*> cvSyntaxExpr e <*> pure f
+cvPat (SigPatIn a b) = SigPatIn <$> traverse cvPat a <*> cvHsSigWcType b
+cvPat (SplicePat a) = SplicePat <$> cvHsSplice a
+cvPat e@(PArrPat {}) = unsupported "PArrPat" "Pat" (ppr e)
+cvPat e@(SigPatOut {}) = unsupported "SigPatOut" "Pat" (ppr e)
+cvPat e@(CoPat {}) = unsupported "CoPat" "Pat" (ppr e)
+cvPat e@(ConPatOut {}) = unsupported "ConPatOut" "Pat" (ppr e)
+
+cvGRHSs
+  :: TypeConstraints p q
+  => (a -> Conv b) -> GRHSs p a -> Conv (GRHSs q b)
+cvGRHSs f (GRHSs a b) = GRHSs
+  <$> traverse (traverse (cvGRHS f)) a
+  <*> traverse cvHsLocalBinds b
+
+cvGRHS
+  :: TypeConstraints p q
+  => (a -> Conv b) -> GRHS p a -> Conv (GRHS q b)
+cvGRHS f (GRHS a b) = GRHS
+  <$> traverse (traverse (cvStmtLR cvLHsExpr)) a <*> f b
+
+cvHsLocalBinds
+  :: TypeConstraints p q
+  => HsLocalBinds p -> Conv (HsLocalBinds q)
+cvHsLocalBinds (HsValBinds a) = HsValBinds <$> cvHsValBindsLR a
+cvHsLocalBinds (HsIPBinds a) = HsIPBinds <$> cvHsIPBinds a
+cvHsLocalBinds EmptyLocalBinds = pure EmptyLocalBinds
+
+cvHsValBindsLR
+  :: TypeConstraints p q
+  => HsValBindsLR p p -> Conv (HsValBindsLR q q)
+cvHsValBindsLR (ValBindsIn a b) = ValBindsIn <$> mapBagM (traverse cvHsBindLR) a
+                                             <*> traverse (traverse cvSig) b
+cvHsValBindsLR e@(ValBindsOut {}) = unsupported "ValBindsOut" "HsValBindsLR" (ppr e)
+
+cvHsConPatDetails
+  :: TypeConstraints p q => HsConPatDetails p -> Conv (HsConPatDetails q)
+cvHsConPatDetails (PrefixCon a) = PrefixCon <$> traverse (traverse cvPat) a
+cvHsConPatDetails (RecCon a) = RecCon <$> cvHsRecFieldsPat a
+cvHsConPatDetails (InfixCon a b) = InfixCon <$> traverse cvPat a
+                                            <*> traverse cvPat b
+
+cvHsRecFields
+  :: TypeConstraints p q
+  => (thing -> Conv thing')
+  -> HsRecFields p thing
+  -> Conv (HsRecFields q thing')
+cvHsRecFields f (HsRecFields a b) =
+  HsRecFields <$> traverse (traverse (cvHsRecField' cvFieldOcc f)) a <*> pure b
+
+cvHsRecField'
+  :: (id -> Conv id')
+  -> (thing -> Conv thing')
+  -> HsRecField' id thing
+  -> Conv (HsRecField' id' thing')
+cvHsRecField' f g (HsRecField a b c) =
+  HsRecField <$> traverse f a <*> g b <*> pure c
+
+cvHsRecFieldsPat
+  :: TypeConstraints p q
+  => HsRecFields p (LPat p) -> Conv (HsRecFields q (LPat q))
+cvHsRecFieldsPat = cvHsRecFields (traverse cvPat)
+
+cvHsRecUpdField
+  :: TypeConstraints p q => HsRecUpdField p -> Conv (HsRecUpdField q)
+cvHsRecUpdField = cvHsRecField' cvAFieldOcc cvLHsExpr
+
+cvRecordBinds
+  :: TypeConstraints p q => HsRecordBinds p -> Conv (HsRecordBinds q)
+cvRecordBinds = cvHsRecFields cvLHsExpr
+
+cvFieldOcc :: TypeConstraints p q => FieldOcc p -> Conv (FieldOcc q)
+cvFieldOcc (FieldOcc a b) = FieldOcc <$> convertName a <*> pure b
+
+cvStmtLR
+  :: TypeConstraints p q
+  => (a -> Conv b) -> StmtLR p p a -> Conv (StmtLR q q b)
+cvStmtLR k (LastStmt a b c) = LastStmt
+  <$> k a <*> pure b <*> cvSyntaxExpr c
+cvStmtLR k (BindStmt a b c d e) = BindStmt
+  <$> traverse cvPat a <*> k b
+  <*> cvSyntaxExpr c <*> cvSyntaxExpr d
+  <*> pure e
+cvStmtLR k (BodyStmt a b c d) = BodyStmt
+  <$> k a <*> cvSyntaxExpr b
+  <*> cvSyntaxExpr c <*> pure d
+cvStmtLR _ (ApplicativeStmt a b c) = ApplicativeStmt
+  <$> traverse
+        (\(se, aa) -> (,) <$> cvSyntaxExpr se <*> cvApplicativeArg aa)
+        a
+  <*> traverse cvSyntaxExpr b
+  <*> pure c
+cvStmtLR _ (LetStmt a) = LetStmt <$> traverse cvHsLocalBinds a
+cvStmtLR k (RecStmt a b c d e f g h i j) = RecStmt
+  <$> traverse (traverse (cvStmtLR k)) a
+  <*> convertName b
+  <*> convertName c
+  <*> cvSyntaxExpr d
+  <*> cvSyntaxExpr e
+  <*> cvSyntaxExpr f
+  <*> pure g <*> pure h <*> pure i <*> pure j
+cvStmtLR _ (ParStmt a b c d) = ParStmt
+  <$> traverse cvParStmtBlock a
+  <*> cvHsExpr b
+  <*> cvSyntaxExpr c
+  <*> pure d
+cvStmtLR _ (TransStmt a b c d e f g h i) = TransStmt a
+  <$> traverse (traverse (cvStmtLR cvLHsExpr)) b
+  <*> traverse (\(x, y) -> (,) <$> convertName x <*> convertName y) c
+  <*> cvLHsExpr d
+  <*> traverse cvLHsExpr e
+  <*> cvSyntaxExpr f
+  <*> cvSyntaxExpr g
+  <*> pure h
+  <*> cvHsExpr i
+
+cvParStmtBlock
+  :: TypeConstraints p q => ParStmtBlock p p -> Conv (ParStmtBlock q q)
+cvParStmtBlock (ParStmtBlock a b c) = ParStmtBlock
+  <$> traverse (traverse (cvStmtLR cvLHsExpr)) a
+  <*> convertName b
+  <*> cvSyntaxExpr c
+
+cvSyntaxExpr :: TypeConstraints p q => SyntaxExpr p -> Conv (SyntaxExpr q)
+cvSyntaxExpr (SyntaxExpr a b c) =
+  SyntaxExpr <$> cvHsExpr a <*> pure b <*> pure c
+
+cvHsIPBinds
+  :: TypeConstraints p q => HsIPBinds p -> Conv (HsIPBinds q)
+cvHsIPBinds (IPBinds a b) = IPBinds <$> traverse (traverse cvIPBind) a <*> pure b
+
+cvIPBind
+  :: TypeConstraints p q => IPBind p -> Conv (IPBind q)
+cvIPBind (IPBind a b) = IPBind <$> convertName a <*> cvLHsExpr b
+
+cvHsBindLR
+  :: TypeConstraints p q => HsBindLR p p -> Conv (HsBindLR q q)
+cvHsBindLR (FunBind a b c d e) = FunBind
+  <$> convertName a
+  <*> cvMatchGroup cvLHsExpr b
+  <*> pure c <*> pure d <*> pure e
+cvHsBindLR (PatBind a b c d e) = PatBind
+                             <$> traverse cvPat a
+                             <*> cvGRHSs cvLHsExpr b
+                             <*> pure c <*> pure d <*> pure e
+cvHsBindLR (VarBind a b c) = VarBind <$> convertName a <*> cvLHsExpr b <*> pure c
+cvHsBindLR (PatSynBind a) = PatSynBind <$> cvPatSynBind a
+cvHsBindLR e@(AbsBinds {}) = unsupported "AbsBind" "HsBindLR" (ppr e)
+
+cvHsWildCardBndrs
+  :: TypeConstraints p q
+  => (thing -> Conv thing')
+  -> HsWildCardBndrs p thing
+  -> Conv (HsWildCardBndrs q thing')
+cvHsWildCardBndrs thingF (HsWC a b) = HsWC a <$> thingF b
+
+cvLHsWcType
+  :: TypeConstraints p q => LHsWcType p -> Conv (LHsWcType q)
+cvLHsWcType = cvHsWildCardBndrs (traverse cvType)
+
+cvHsSigWcType
+  :: TypeConstraints p q => LHsSigWcType p -> Conv (LHsSigWcType q)
+cvHsSigWcType = cvHsWildCardBndrs (cvHsImplicitBndrs (traverse cvType))
+
+cvHsImplicitBndrs
+  :: TypeConstraints p q
+  => (thing -> Conv thing')
+  -> HsImplicitBndrs p thing
+  -> Conv (HsImplicitBndrs q thing')
+cvHsImplicitBndrs f (HsIB a b c) = HsIB a <$> f b <*> pure c
+
+cvType :: TypeConstraints p q => HsType p -> Conv (HsType q)
+cvType (HsForAllTy a b) = HsForAllTy
+                      <$> traverse (traverse cvHsTyVarBndr) a
+                      <*> traverse cvType b
+cvType (HsQualTy a b) = HsQualTy
+                    <$> traverse (traverse (traverse cvType)) a
+                    <*> traverse cvType b
+cvType (HsTyVar a b) = HsTyVar a <$> convertName b
+cvType (HsAppsTy a) = HsAppsTy <$> traverse (traverse cvHsAppType) a
+cvType (HsAppTy a b) = HsAppTy <$> traverse cvType a
+                               <*> traverse cvType b
+cvType (HsFunTy a b) = HsFunTy <$> traverse cvType a
+                               <*> traverse cvType b
+cvType (HsListTy a) = HsListTy <$> traverse cvType a
+cvType (HsTupleTy a b) = HsTupleTy a <$> traverse (traverse cvType) b
+cvType (HsSumTy a) = HsSumTy <$> traverse (traverse cvType) a
+cvType (HsOpTy a b c) = HsOpTy <$> traverse cvType a
+                               <*> convertName b
+                               <*> traverse cvType c
+cvType (HsParTy a) = HsParTy <$> traverse cvType a
+cvType (HsIParamTy a b) = HsIParamTy a <$> traverse cvType b
+cvType (HsEqTy a b) = HsEqTy <$> traverse cvType a
+                             <*> traverse cvType b
+cvType (HsKindSig a b) = HsKindSig <$> traverse cvType a
+                                   <*> traverse cvType b
+cvType (HsBangTy a b) = HsBangTy a <$> traverse cvType b
+cvType (HsRecTy a) = HsRecTy <$> traverse (traverse cvConDeclField) a
+cvType (HsExplicitListTy a b c) = HsExplicitListTy a b
+                              <$> traverse (traverse cvType) c
+cvType (HsExplicitTupleTy a b) = HsExplicitTupleTy a
+                             <$> traverse (traverse cvType) b
+cvType (HsTyLit a) = pure (HsTyLit a)
+cvType (HsWildCardTy (AnonWildCard a)) = pure (HsWildCardTy (AnonWildCard a))
+cvType (HsDocTy a b) = HsDocTy <$> traverse cvType a <*> pure b
+cvType (HsSpliceTy a b) = HsSpliceTy <$> cvHsSplice a <*> pure b
+cvType e@(HsPArrTy {}) = unsupported "HsPArrTy" "HsType" (ppr e)
+cvType e@(HsCoreTy {}) = unsupported "HsCoreTy" "HsType" (ppr e)
+
+cvHsAppType
+  :: TypeConstraints p q => HsAppType p -> Conv (HsAppType q)
+cvHsAppType (HsAppInfix a) = HsAppInfix <$> convertName a
+cvHsAppType (HsAppPrefix a) = HsAppPrefix <$> traverse cvType a
+
+cvHsTyVarBndr
+  :: TypeConstraints p q => HsTyVarBndr p -> Conv (HsTyVarBndr q)
+cvHsTyVarBndr (UserTyVar a) = UserTyVar <$> convertName a
+cvHsTyVarBndr (KindedTyVar a b) = KindedTyVar
+                              <$> convertName a
+                              <*> traverse cvType b
+
+cvApplicativeArg
+  :: TypeConstraints p q => ApplicativeArg p a -> Conv (ApplicativeArg q b)
+cvApplicativeArg (ApplicativeArgOne a b c) = ApplicativeArgOne
+  <$> traverse cvPat a <*> cvLHsExpr b <*> pure c
+cvApplicativeArg (ApplicativeArgMany a b c) = ApplicativeArgMany
+  <$> traverse (traverse (cvStmtLR cvLHsExpr)) a <*> cvHsExpr b
+  <*> traverse cvPat c
+
+cvSig :: TypeConstraints p q => Sig p -> Conv (Sig q)
+cvSig (TypeSig a b) = TypeSig <$> convertName a <*> cvHsSigWcType b
+cvSig (PatSynSig a b) = PatSynSig
+  <$> convertName a <*> cvHsImplicitBndrs (traverse cvType) b
+cvSig (ClassOpSig a b c) = ClassOpSig a
+  <$> convertName b <*> cvHsImplicitBndrs (traverse cvType) c
+cvSig (InlineSig a b) = InlineSig <$> convertName a <*> pure b
+cvSig (FixSig a) = FixSig <$> cvFixitySig a
+cvSig (SpecSig a b c) = SpecSig
+  <$> convertName a
+  <*> traverse (cvHsImplicitBndrs (traverse cvType)) b
+  <*> pure c
+cvSig (SpecInstSig a b) = SpecInstSig a <$> cvHsImplicitBndrs (traverse cvType) b
+cvSig (SCCFunSig a b c) = SCCFunSig a <$> convertName b <*> pure c
+cvSig (CompleteMatchSig a b c) = CompleteMatchSig a
+  <$> convertName b <*> convertName c
+cvSig (MinimalSig a b) = MinimalSig a <$> traverse (traverse convertName) b
+cvSig e@(IdSig {}) = unsupported "IdSig" "Sig" (ppr e)
+
+cvFixitySig :: TypeConstraints p q => FixitySig p -> Conv (FixitySig q)
+cvFixitySig (FixitySig a b) = FixitySig <$> convertName a <*> pure b
+
+cvPatSynBind :: TypeConstraints p q => PatSynBind p p -> Conv (PatSynBind q q)
+cvPatSynBind (PSB a b c d e) =
+  PSB <$> convertName a
+      <*> pure b
+      <*> cvHsPatSynDetails convertName c <*> traverse cvPat d
+      <*> cvHsPatSynDir e
+
+cvHsPatSynDetails
+  :: (a -> Conv b)
+  -> HsPatSynDetails a
+  -> Conv (HsPatSynDetails b)
+cvHsPatSynDetails f =
+  cvHsConDetails f (traverse (cvRecordPatSynField f))
+
+cvRecordPatSynField
+  :: (a -> Conv b)
+  -> RecordPatSynField a
+  -> Conv (RecordPatSynField b)
+cvRecordPatSynField f (RecordPatSynField a b) =
+  RecordPatSynField <$> f a <*> f b
+
+cvHsPatSynDir :: TypeConstraints p q => HsPatSynDir p -> Conv (HsPatSynDir q)
+cvHsPatSynDir Unidirectional = pure Unidirectional
+cvHsPatSynDir ImplicitBidirectional = pure ImplicitBidirectional
+cvHsPatSynDir (ExplicitBidirectional a) = ExplicitBidirectional <$> cvMatchGroup cvLHsExpr a
+
+-- * Looking up modules/packages for Orig names
+
+-- this rejects wired in packages, because we want to leave them untouched
+parseUnitId' :: String -> Maybe (String, String, Maybe String)
+parseUnitId' = parse
+
+  where
+    parse s = case splitOn '-' (reverse s) of
+      ("":_) -> Nothing
+      xs | length xs >= 1 && last xs == "" -> Nothing
+      (hash:ver:name) | isVersion ver ->
+         Just (intercalate "-" (reverse name), ver, Just hash)
+      (ver:name) | isVersion ver ->
+         Just (intercalate "-" (reverse name), ver, Nothing)
+      _ -> Nothing
+    splitOn c = go []
+      where go acc (x:xs)
+              | x == c    = acc : go "" xs
+              | otherwise = go (x:acc) xs
+            go acc [] = [acc]
+    isVersion = go False
+      -- True: waiting for digit or dot (we've seen a digit last)
+      -- False: waiting for digit (we've just seen a dot)
+      where go False (c:cs)
+              | isDigit c = go True cs
+              | otherwise = False
+            go True (c:cs)
+              | isDigit c = go True cs
+              | c == '.'  = go False cs
+              | otherwise = False
+            go b [] = b -- if we've seen a dot last (False), we fail
+                        -- otherwise, the version number can end here
+
+-- | Look up the module from the same package, but built by the
+--   current compiler, therefore with a slightly different hash
+--   in the unit id than the input Module, which was built by some
+--   non-cross-compiling GHC.
+findEquivalentModule :: Module -> RnM (Maybe Module)
+findEquivalentModule mod = do
+  liftIO $ putStrLn ("Looking for equivalent to: " ++ unitIdStr)
+  case parseUnitId' unitIdStr of
+    Nothing -> return Nothing
+    Just (pkg, ver, _mhash) -> do
+      muid <- lookFor pkg ver
+      maybe (pure Nothing) (\uid -> return $ Just (mod { moduleUnitId = uid })) muid
+
+  where unitIdStr = unitIdString (moduleUnitId mod)
+
+lookFor :: String -> String -> RnM (Maybe UnitId)
+lookFor pkg ver = do
+  dflags <- getDynFlags
+  let pkgid = mkFastString (pkg ++ "-" ++ ver)
+      pkgs = searchPackageId dflags (SourcePackageId pkgid)
+  liftIO $ putStrLn ("Looking for: " ++ pkg ++ "-" ++ ver)
+  liftIO . putStrLn . unwords $
+    [ "Found", show (length pkgs), "pkgs:" ] ++
+    [ unitIdString (packageConfigId p) | p <- pkgs ]
+  if null pkgs then pure Nothing else pure (Just $ packageConfigId (head pkgs))
diff --git a/compiler/hsSyn/HsExprBin_Instances.hs b/compiler/hsSyn/HsExprBin_Instances.hs
new file mode 100644
index 0000000000..09187bb7cc
--- /dev/null
+++ b/compiler/hsSyn/HsExprBin_Instances.hs
@@ -0,0 +1,1394 @@
+-- too noisy during development...
+{-# OPTIONS_GHC -fno-warn-orphans #-}
+{-# LANGUAGE GeneralizedNewtypeDeriving #-}
+{-# LANGUAGE StandaloneDeriving #-}
+{-# LANGUAGE FlexibleContexts, FlexibleInstances #-}
+module HsExprBin_Instances where
+
+import Control.Applicative
+import Control.Monad
+
+import BasicTypes
+import Binary
+import CoreSyn ( Tickish(..) )
+import GhcPrelude
+import HsBinds
+import HsDecls
+import HsDoc
+import HsExpr
+import HsExtension
+import HsLit
+import HsPat
+import HsTypes
+import Name
+import Outputable
+import PlaceHolder
+import RdrName
+import SeName
+import SrcLoc
+import TcEvidence (HsWrapper(WpHole))
+
+putPanic :: String -> String -> a
+putPanic tyName conName =
+  panic ("Binary " ++ tyName ++ ".put: " ++ conName ++ " not supported")
+
+getPanic :: String -> a
+getPanic tyName =
+  panic ("Binary " ++ tyName ++ ".get: unknown (or unsupported) tag")
+
+-- * Binary instances
+
+instance Binary (HsExpr GhcSe) where
+  put_ bh e = case e of
+    HsVar a ->
+      putByte bh 0 >> put_ bh a
+    HsUnboundVar a ->
+      putByte bh 1 >> put_ bh a
+    HsRecFld a ->
+      putByte bh 2 >> put_ bh a
+    HsOverLabel a b ->
+      putByte bh 3 >> put_ bh a >> put_ bh b
+    HsIPVar a ->
+      putByte bh 4 >> put_ bh a
+    HsOverLit a ->
+      putByte bh 5 >> put_ bh a
+    HsLit a ->
+      putByte bh 6 >> put_ bh a
+    HsLam a ->
+      putByte bh 7 >> put_ bh a
+    HsLamCase a ->
+      putByte bh 8 >> put_ bh a
+    HsApp a b ->
+      putByte bh 9 >> put_ bh a >> put_ bh b
+    HsAppType a b ->
+      putByte bh 10 >> put_ bh a >> put_ bh b
+    OpApp a b c d ->
+      putByte bh 11 >> put_ bh a >> put_ bh b >> put_ bh c
+                    >> put_ bh d
+    NegApp a b ->
+      putByte bh 12 >> put_ bh a >> put_ bh b
+    HsPar a ->
+      putByte bh 13 >> put_ bh a
+    SectionL a b ->
+      putByte bh 14 >> put_ bh a >> put_ bh b
+    SectionR a b ->
+      putByte bh 15 >> put_ bh a >> put_ bh b
+    ExplicitTuple a b ->
+      putByte bh 16 >> put_ bh a >> put_ bh b
+    ExplicitSum a b c d ->
+      putByte bh 17 >> put_ bh a >> put_ bh b >> put_ bh c
+                    >> put_ bh d
+    HsCase a b ->
+      putByte bh 18 >> put_ bh a >> put_ bh b
+    HsIf a b c d ->
+      putByte bh 19 >> put_ bh a >> put_ bh b >> put_ bh c
+                    >> put_ bh d
+    HsMultiIf a b ->
+      putByte bh 20 >> put_ bh a >> put_ bh b
+    HsLet a b ->
+      putByte bh 21 >> put_ bh a >> put_ bh b
+    HsDo a b c ->
+      putByte bh 22 >> put_ bh a >> put_ bh b >> put_ bh c
+    ExplicitList a b c ->
+      putByte bh 23 >> put_ bh a >> put_ bh b >> put_ bh c
+    RecordCon a _b _c d ->
+      putByte bh 24 >> put_ bh a >> put_ bh d
+    RecordUpd a b c d e f ->
+      putByte bh 25 >> put_ bh a >> put_ bh b >> put_ bh c
+                    >> put_ bh d >> put_ bh e >> put_ bh f
+    ExprWithTySig a b ->
+      putByte bh 26 >> put_ bh a >> put_ bh b
+    ArithSeq _a b c ->
+      putByte bh 27 >> put_ bh b >> put_ bh c
+    EWildPat ->
+      putByte bh 28
+    EAsPat a b ->
+      putByte bh 29 >> put_ bh a >> put_ bh b
+    EViewPat a b ->
+      putByte bh 30 >> put_ bh a >> put_ bh b
+    ELazyPat a ->
+      putByte bh 31 >> put_ bh a
+    HsStatic a b ->
+      putByte bh 32 >> put_ bh a >> put_ bh b
+    HsProc a b ->
+      putByte bh 33 >> put_ bh a >> put_ bh b
+    HsBinTick a b c ->
+      putByte bh 34 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsTickPragma a b c d ->
+      putByte bh 35 >> put_ bh a >> put_ bh b >> put_ bh c
+                    >> put_ bh d
+    HsSpliceE a ->
+      putByte bh 36 >> put_ bh a
+    HsSCC a b c ->
+      putByte bh 37 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsCoreAnn a b c ->
+      putByte bh 38 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsBracket a ->
+      putByte bh 39 >> put_ bh a
+    HsConLikeOut {} -> putPanic "HsExpr" "HsConLikeOut"
+    HsAppTypeOut {} -> putPanic "HsExpr" "HsAppTypeOut"
+    ExplicitPArr {} -> putPanic "HsExpr" "ExplicitPArr"
+    ExprWithTySigOut {} -> putPanic "HsExpr" "ExprWithTySigOut"
+    PArrSeq {} -> putPanic "HsExpr" "PArrSeq"
+    HsRnBracketOut {} -> putPanic "HsExpr" "HsRnBracketOut"
+    HsTcBracketOut {} -> putPanic "HsExpr" "HsTcBracketOut"
+    HsArrApp {} -> putPanic "HsExpr" "HsArrApp"
+    HsArrForm {} -> putPanic "HsExpr" "HsArrForm"
+    HsTick {} -> putPanic "HsExpr" "HsTick"
+    HsWrap {} -> putPanic "HsExpr" "HsWrap"
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0  -> HsVar <$> get bh
+      1  -> HsUnboundVar <$> get bh
+      2  -> HsRecFld <$> get bh
+      3  -> HsOverLabel <$> get bh <*> get bh
+      4  -> HsIPVar <$> get bh
+      5  -> HsOverLit <$> get bh
+      6  -> HsLit <$> get bh
+      7  -> HsLam <$> get bh
+      8  -> HsLamCase <$> get bh
+      9  -> HsApp <$> get bh <*> get bh
+      10 -> HsAppType <$> get bh <*> get bh
+      11 -> OpApp <$> get bh <*> get bh <*> get bh <*> get bh
+      12 -> NegApp <$> get bh <*> get bh
+      13 -> HsPar <$> get bh
+      14 -> SectionL <$> get bh <*> get bh
+      15 -> SectionR <$> get bh <*> get bh
+      16 -> ExplicitTuple <$> get bh <*> get bh
+      17 -> ExplicitSum <$> get bh <*> get bh <*> get bh <*> get bh
+      18 -> HsCase <$> get bh <*> get bh
+      19 -> HsIf <$> get bh <*> get bh <*> get bh <*> get bh
+      20 -> HsMultiIf <$> get bh <*> get bh
+      21 -> HsLet <$> get bh <*> get bh
+      22 -> HsDo <$> get bh <*> get bh <*> get bh
+      23 -> ExplicitList <$> get bh <*> get bh <*> get bh
+      24 -> RecordCon <$> get bh <*> pure PlaceHolder <*> pure noPostTcExpr
+                      <*> get bh
+      25 -> RecordUpd <$> get bh <*> get bh <*> get bh
+                      <*> get bh <*> get bh <*> get bh
+      26 -> ExprWithTySig <$> get bh <*> get bh
+      27 -> ArithSeq <$> pure noPostTcExpr <*> get bh <*> get bh
+      28 -> pure EWildPat
+      29 -> EAsPat <$> get bh <*> get bh
+      30 -> EViewPat <$> get bh <*> get bh
+      31 -> ELazyPat <$> get bh
+      32 -> HsStatic <$> get bh <*> get bh
+      33 -> HsProc <$> get bh <*> get bh
+      34 -> HsBinTick <$> get bh <*> get bh <*> get bh
+      35 -> HsTickPragma <$> get bh <*> get bh <*> get bh <*> get bh
+      36 -> HsSpliceE <$> get bh
+      37 -> HsSCC <$> get bh <*> get bh <*> get bh
+      38 -> HsCoreAnn <$> get bh <*> get bh <*> get bh
+      39 -> HsBracket <$> get bh
+      _  -> getPanic "HsExpr"
+
+instance Binary (HsBracket GhcSe) where
+  put_ bh b = case b of
+    ExpBr a ->
+      putByte bh 0 >> put_ bh a
+    PatBr a ->
+      putByte bh 1 >> put_ bh a
+    DecBrL a ->
+      putByte bh 2 >> put_ bh a
+    DecBrG a ->
+      putByte bh 3 >> put_ bh a
+    TypBr a ->
+      putByte bh 4 >> put_ bh a
+    VarBr a b ->
+      putByte bh 5 >> put_ bh a >> put_ bh b
+    TExpBr a ->
+      putByte bh 6 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> ExpBr <$> get bh
+      1 -> PatBr <$> get bh
+      2 -> DecBrL <$> get bh
+      3 -> DecBrG <$> get bh
+      4 -> TypBr <$> get bh
+      5 -> VarBr <$> get bh <*> get bh
+      6 -> TExpBr <$> get bh
+      _ -> getPanic "HsBracket"
+
+instance Binary SeName where
+  put_ bh (SeName n) = put_ bh n
+  get bh = mkSeName <$> get bh
+
+instance Binary RealSrcSpan where
+  put_ bh s =
+    put_ bh (srcSpanFile s) >>
+    put_ bh (srcSpanStartLine s) >>
+    put_ bh (srcSpanStartCol s) >>
+    put_ bh (srcSpanEndLine s) >>
+    put_ bh (srcSpanEndCol s)
+  get bh = do
+    file <- get bh
+    (startLine, startCol) <- (,) <$> get bh <*> get bh
+    (endLine, endCol) <- (,) <$> get bh <*> get bh
+    let startLoc = mkRealSrcLoc file startLine startCol
+        endLoc = mkRealSrcLoc file endLine endCol
+    return (mkRealSrcSpan startLoc endLoc)
+
+instance Binary UnboundVar where
+  put_ bh v = case v of
+    OutOfScope a b -> putByte bh 0 >> put_ bh a >> put_ bh b
+    TrueExprHole a -> putByte bh 1 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> OutOfScope <$> get bh <*> get bh
+      1 -> TrueExprHole <$> get bh
+      _ -> getPanic "UnboundVar"
+
+instance Binary a => Binary (StmtLR GhcSe GhcSe a) where
+  put_ bh s = case s of
+    LastStmt a b c ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+    BindStmt a b c d e ->
+      putByte bh 1 >> put_ bh a >> put_ bh b >> put bh c >> put_ bh d
+                   >> put_ bh e
+    ApplicativeStmt a b c ->
+      putByte bh 2 >> put_ bh a >> put_ bh b >> put_ bh c
+    BodyStmt a b c d ->
+      putByte bh 3 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    LetStmt a ->
+      putByte bh 4 >> put_ bh a
+    ParStmt a b c d ->
+      putByte bh 5 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    RecStmt a b c d e f _g _h _i _j ->
+      putByte bh 6 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+                   >> put_ bh e >> put_ bh f
+    TransStmt a b c d e f g h i ->
+      putByte bh 7 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+                   >> put_ bh e >> put_ bh f >> put_ bh g >> put_ bh h
+                   >> put_ bh i
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> LastStmt <$> get bh <*> get bh <*> get bh
+      1 -> BindStmt <$> get bh <*> get bh <*> get bh <*> get bh <*> get bh
+      2 -> ApplicativeStmt <$> get bh <*> get bh <*> get bh
+      3 -> BodyStmt <$> get bh <*> get bh <*> get bh <*> get bh
+      4 -> LetStmt <$> get bh
+      5 -> ParStmt <$> get bh <*> get bh <*> get bh <*> get bh
+      6 -> RecStmt <$> get bh <*> get bh <*> get bh <*> get bh <*> get bh
+                   <*> get bh <*> pure PlaceHolder <*> pure [] <*> pure []
+                   <*> pure PlaceHolder
+      7 -> TransStmt <$> get bh <*> get bh <*> get bh <*> get bh
+                     <*> get bh <*> get bh <*> get bh <*> get bh
+                     <*> get bh
+      _ -> getPanic "StmtLR"
+
+instance Binary (HsGroup GhcSe) where
+  put_ bh (HsGroup a b c d e f g h i j k l) =
+    put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+              >> put_ bh e >> put_ bh f >> put_ bh g
+              >> put_ bh h >> put_ bh i >> put_ bh j
+              >> put_ bh k >> put_ bh l
+  get bh = HsGroup
+       <$> get bh <*> get bh <*> get bh <*> get bh
+       <*> get bh <*> get bh <*> get bh <*> get bh
+       <*> get bh <*> get bh <*> get bh <*> get bh
+
+instance Binary (TyClGroup GhcSe) where
+  put_ bh (TyClGroup a b c) = put_ bh a >> put_ bh b >> put_ bh c
+  get bh = TyClGroup <$> get bh <*> get bh <*> get bh
+
+instance Binary (VectDecl GhcSe) where
+  put_ bh d = case d of
+    HsVect a b c ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsNoVect a b ->
+      putByte bh 1 >> put_ bh a >> put_ bh b
+    HsVectTypeIn a b c d ->
+      putByte bh 2 >> put_ bh a >> put_ bh b >> put_ bh c
+                   >> put_ bh d
+    HsVectClassIn a b ->
+      putByte bh 3 >> put_ bh a >> put_ bh b
+    HsVectInstIn a ->
+      putByte bh 4 >> put_ bh a
+    HsVectTypeOut {} -> putPanic "HsVectTypeOut" "VectDecl"
+    HsVectClassOut {} -> putPanic "HsVectClassOut" "VectDecl"
+    HsVectInstOut {} -> putPanic "HsVectInstOut" "VectDecl"
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> HsVect <$> get bh <*> get bh <*> get bh
+      1 -> HsNoVect <$> get bh <*> get bh
+      2 -> HsVectTypeIn <$> get bh <*> get bh <*> get bh <*> get bh
+      3 -> HsVectClassIn <$> get bh <*> get bh
+      4 -> HsVectInstIn <$> get bh
+      _ -> getPanic "VectDecl"
+
+instance Binary (HsCmdTop GhcSe) where
+  put_ bh (HsCmdTop a b c d) =
+    put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+  get bh = HsCmdTop <$> get bh <*> get bh <*> get bh <*> get bh
+
+instance Binary (HsCmd GhcSe) where
+  put_ bh c = case c of
+    HsCmdArrApp a b c d e ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+                   >> put_ bh d >> put_ bh e
+    HsCmdArrForm a b c d ->
+      putByte bh 1 >> put_ bh a >> put_ bh b >> put_ bh c
+                   >> put_ bh d
+    HsCmdApp a b ->
+      putByte bh 2 >> put_ bh a >> put_ bh b
+    HsCmdLam a ->
+      putByte bh 3 >> put_ bh a
+    HsCmdPar a ->
+      putByte bh 4 >> put_ bh a
+    HsCmdCase a b ->
+      putByte bh 5 >> put_ bh a >> put_ bh b
+    HsCmdIf a b c d ->
+      putByte bh 6 >> put_ bh a >> put_ bh b >> put_ bh c
+                   >> put_ bh d
+    HsCmdLet a b ->
+      putByte bh 7 >> put_ bh a >> put_ bh b
+    HsCmdDo a b ->
+      putByte bh 8 >> put_ bh a >> put_ bh b
+    HsCmdWrap {} ->
+      putPanic "HsCmdWrap" "HsCmd"
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> HsCmdArrApp <$> get bh <*> get bh <*> get bh
+                       <*> get bh <*> get bh
+      1 -> HsCmdArrForm <$> get bh <*> get bh <*> get bh
+                        <*> get bh
+      2 -> HsCmdApp <$> get bh <*> get bh
+      3 -> HsCmdLam <$> get bh
+      4 -> HsCmdPar <$> get bh
+      5 -> HsCmdCase <$> get bh <*> get bh
+      6 -> HsCmdIf <$> get bh <*> get bh <*> get bh <*> get bh
+      7 -> HsCmdLet <$> get bh <*> get bh
+      8 -> HsCmdDo <$> get bh <*> get bh
+      _ -> getPanic "HsCmd"
+
+instance Binary HsArrAppType where
+  put_ bh t = putByte bh $ case t of
+    HsHigherOrderApp -> 0
+    HsFirstOrderApp  -> 1
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure HsHigherOrderApp
+      1 -> pure HsFirstOrderApp
+      _ -> getPanic "HsArrAppType"
+
+instance Binary TransForm where
+  put_ bh f = putByte bh $ case f of
+    ThenForm  -> 0
+    GroupForm -> 1
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure ThenForm
+      1 -> pure GroupForm
+      _ -> getPanic "TransForm"
+
+instance Binary (ApplicativeArg GhcSe GhcSe) where
+  put_ bh a = case a of
+    ApplicativeArgOne a b c ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+    ApplicativeArgMany a b c ->
+      putByte bh 1 >> put_ bh a >> put_ bh b >> put_ bh c
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> ApplicativeArgOne <$> get bh <*> get bh <*> get bh
+      1 -> ApplicativeArgMany <$> get bh <*> get bh <*> get bh
+      _ -> getPanic "ApplicativeAr"
+
+instance Binary (ParStmtBlock GhcSe GhcSe) where
+  put_ bh b = case b of
+    ParStmtBlock a b c ->
+      put_ bh a >> put_ bh b >> put_ bh c
+  get bh = ParStmtBlock <$> get bh <*> get bh <*> get bh
+
+instance Binary (SyntaxExpr GhcSe) where
+  put_ bh (SyntaxExpr a [] WpHole) = put_ bh a
+  put_ _ _ = panic "Binary SyntaxExpr.put: wrappers should be empty"
+  get bh = SyntaxExpr <$> get bh <*> pure [] <*> pure WpHole
+
+instance Binary a => Binary (GRHSs GhcSe a) where
+  put_ bh g = case g of
+    GRHSs a b -> putByte bh 0 >> put_ bh a >> put_ bh b
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> GRHSs <$> get bh <*> get bh
+      _ -> getPanic "GRHSs"
+
+instance Binary a => Binary (GRHS GhcSe a) where
+  put_ bh g = case g of
+    GRHS a b -> put_ bh a >> put_ bh b
+  get bh = GRHS <$> get bh <*> get bh
+
+instance Binary a => Binary (MatchGroup GhcSe a) where
+  put_ bh g = case g of
+    MG a b c d -> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+  get bh = MG <$> get bh <*> get bh <*> get bh <*> get bh
+
+instance Binary a => Binary (Match GhcSe a) where
+  put_ bh m = case m of
+    Match a b c ->
+      put_ bh a >> put_ bh b >> put_ bh c
+  get bh = Match <$> get bh <*> get bh <*> get bh
+
+instance Binary (HsMatchContext SeName) where
+  put_ bh c = case c of
+    FunRhs a b c ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+    LambdaExpr ->
+      putByte bh 1
+    CaseAlt ->
+      putByte bh 2
+    IfAlt ->
+      putByte bh 3
+    ProcExpr ->
+      putByte bh 4
+    PatBindRhs ->
+      putByte bh 5
+    RecUpd ->
+      putByte bh 6
+    StmtCtxt a ->
+      putByte bh 7 >> put_ bh a
+    ThPatSplice ->
+      putByte bh 8
+    ThPatQuote ->
+      putByte bh 9
+    PatSyn ->
+      putByte bh 10
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0  -> FunRhs <$> get bh <*> get bh <*> get bh
+      1  -> pure LambdaExpr
+      2  -> pure CaseAlt
+      3  -> pure IfAlt
+      4  -> pure ProcExpr
+      5  -> pure PatBindRhs
+      6  -> pure RecUpd
+      7  -> StmtCtxt <$> get bh
+      8  -> pure ThPatSplice
+      9  -> pure ThPatQuote
+      10 -> pure PatSyn
+      _  -> getPanic "HsMatchContext"
+
+instance Binary (HsStmtContext SeName) where
+  put_ bh c = case c of
+    ListComp        -> putByte bh 0
+    MonadComp       -> putByte bh 1
+    DoExpr          -> putByte bh 3
+    MDoExpr         -> putByte bh 4
+    ArrowExpr       -> putByte bh 5
+    GhciStmtCtxt    -> putByte bh 6
+    PatGuard a      -> putByte bh 7 >> put_ bh a
+    ParStmtCtxt a   -> putByte bh 8 >> put_ bh a
+    TransStmtCtxt a -> putByte bh 9 >> put_ bh a
+    PArrComp {}     -> putPanic "HsStmtContext" "PArrComp"
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure ListComp
+      1 -> pure MonadComp
+      3 -> pure DoExpr
+      4 -> pure MDoExpr
+      5 -> pure ArrowExpr
+      6 -> pure GhciStmtCtxt
+      7 -> PatGuard <$> get bh
+      8 -> ParStmtCtxt <$> get bh
+      9 -> TransStmtCtxt <$> get bh
+      _ -> getPanic "HsStmtContext"
+
+instance Binary (ArithSeqInfo GhcSe) where
+  put_ bh i = case i of
+    From a ->
+      putByte bh 0 >> put_ bh a
+    FromThen a b ->
+      putByte bh 1 >> put_ bh a >> put_ bh b
+    FromTo a b ->
+      putByte bh 2 >> put_ bh a >> put_ bh b
+    FromThenTo a b c ->
+      putByte bh 3 >> put_ bh a >> put_ bh b >> put_ bh c
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> From <$> get bh
+      1 -> FromThen <$> get bh <*> get bh
+      2 -> FromTo <$> get bh <*> get bh
+      3 -> FromThenTo <$> get bh <*> get bh <*> get bh
+      _ -> getPanic "ArithSeqInfo"
+
+instance Binary (HsTupArg GhcSe) where
+  put_ bh a = case a of
+    Present a -> putByte bh 0 >> put_ bh a
+    Missing a -> putByte bh 1 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> Present <$> get bh
+      1 -> Missing <$> get bh
+      _ -> getPanic "HsTupArg"
+
+instance Binary (Pat GhcSe) where
+  put_ bh p = case p of
+    WildPat a ->
+      putByte bh 0 >> put_ bh a
+    VarPat a ->
+      putByte bh 1 >> put_ bh a
+    LazyPat a ->
+      putByte bh 2 >> put_ bh a
+    AsPat a b ->
+      putByte bh 3 >> put_ bh a >> put_ bh b
+    ParPat a ->
+      putByte bh 4 >> put_ bh a
+    BangPat a ->
+      putByte bh 5 >> put_ bh a
+    ListPat a b c ->
+      putByte bh 6 >> put_ bh a >> put_ bh b >> put_ bh c
+    TuplePat a b c ->
+      putByte bh 7 >> put_ bh a >> put_ bh b >> put_ bh c
+    SumPat a b c d ->
+      putByte bh 8 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    ConPatIn a b ->
+      putByte bh 9 >> put_ bh a >> put_ bh b
+    ViewPat a b c ->
+      putByte bh 10 >> put_ bh a >> put_ bh b >> put_ bh c
+    LitPat a ->
+      putByte bh 11 >> put_ bh a
+    NPat a b c d ->
+      putByte bh 12 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    NPlusKPat a b c d e f ->
+      putByte bh 13 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+                    >> put_ bh e >> put_ bh f
+    SigPatIn a b ->
+      putByte bh 14 >> put_ bh a >> put_ bh b
+    SplicePat a ->
+      putByte bh 15 >> put_ bh a
+    ConPatOut {} -> putPanic "Pat" "ConPatOut"
+    CoPat {} -> putPanic "Pat" "CoPat"
+    PArrPat {} -> putPanic "Pat" "PArrPat"
+    SigPatOut {} -> putPanic "Pat" "SigPatOut"
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> WildPat <$> get bh
+      1 -> VarPat <$> get bh
+      2 -> LazyPat <$> get bh
+      3 -> AsPat <$> get bh <*> get bh
+      4 -> ParPat <$> get bh
+      5 -> BangPat <$> get bh
+      6 -> ListPat <$> get bh <*> get bh <*> get bh
+      7 -> TuplePat <$> get bh <*> get bh <*> get bh
+      8 -> SumPat <$> get bh <*> get bh <*> get bh <*> get bh
+      9 -> ConPatIn <$> get bh <*> get bh
+      10 -> ViewPat <$> get bh <*> get bh <*> get bh
+      11 -> LitPat <$> get bh
+      12 -> NPat <$> get bh <*> get bh <*> get bh <*> get bh
+      13 -> NPlusKPat <$> get bh <*> get bh <*> get bh <*> get bh
+                      <*> get bh <*> get bh
+      14 -> SigPatIn <$> get bh <*> get bh
+      15 -> SplicePat <$> get bh
+      _ -> getPanic "HsPat"
+
+instance (Binary (FieldOcc a), Binary b) => Binary (HsRecFields a b) where
+  put_ bh (HsRecFields a b) = put_ bh a >> put_ bh b
+  get bh = HsRecFields <$> get bh <*> get bh
+
+instance (Binary id, Binary arg) => Binary (HsRecField' id arg) where
+  put_ bh (HsRecField a b c) = put_ bh a >> put_ bh b >> put_ bh c
+  get bh = HsRecField <$> get bh <*> get bh <*> get bh
+
+instance Binary (HsType GhcSe) where
+  put_ bh t = case t of
+    HsForAllTy a b ->
+      putByte bh 0 >> put_ bh a >> put_ bh b
+    HsQualTy a b ->
+      putByte bh 1 >> put_ bh a >> put_ bh b
+    HsTyVar a b ->
+      putByte bh 2 >> put_ bh a >> put_ bh b
+    HsAppsTy a ->
+      putByte bh 3 >> put_ bh a
+    HsAppTy a b ->
+      putByte bh 4 >> put_ bh a >> put_ bh b
+    HsFunTy a b ->
+      putByte bh 5 >> put_ bh a >> put_ bh b
+    HsListTy a ->
+      putByte bh 6 >> put_ bh a
+    HsTupleTy a b ->
+      putByte bh 7 >> put_ bh a >> put_ bh b
+    HsSumTy a ->
+      putByte bh 8 >> put_ bh a
+    HsOpTy a b c ->
+      putByte bh 9 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsParTy a ->
+      putByte bh 10 >> put_ bh a
+    HsIParamTy a b ->
+      putByte bh 11 >> put_ bh a >> put_ bh b
+    HsEqTy a b ->
+      putByte bh 12 >> put_ bh a >> put_ bh b
+    HsKindSig a b ->
+      putByte bh 13 >> put_ bh a >> put_ bh b
+    HsBangTy a b ->
+      putByte bh 14 >> put_ bh a >> put_ bh b
+    HsRecTy a ->
+      putByte bh 15 >> put_ bh a
+    HsExplicitListTy a b c ->
+      putByte bh 16 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsExplicitTupleTy a b ->
+      putByte bh 17 >> put_ bh a >> put_ bh b
+    HsTyLit a ->
+      putByte bh 18 >> put_ bh a
+    HsWildCardTy a ->
+      putByte bh 19 >> put_ bh a
+    HsDocTy a b ->
+      putByte bh 20 >> put_ bh a >> put_ bh b
+    HsSpliceTy a b ->
+      putByte bh 21 >> put_ bh a >> put_ bh b
+    HsPArrTy {} -> putPanic "HsType" "PArrTy"
+    HsCoreTy {} -> putPanic "HsType" "HsCoreTy"
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> HsForAllTy <$> get bh <*> get bh
+      1 -> HsQualTy <$> get bh <*> get bh
+      2 -> HsTyVar <$> get bh <*> get bh
+      3 -> HsAppsTy <$> get bh
+      4 -> HsAppTy <$> get bh <*> get bh
+      5 -> HsFunTy <$> get bh <*> get bh
+      6 -> HsListTy <$> get bh
+      7 -> HsTupleTy <$> get bh <*> get bh
+      8 -> HsSumTy <$> get bh
+      9 -> HsOpTy <$> get bh <*> get bh <*> get bh
+      10 -> HsParTy <$> get bh
+      11 -> HsIParamTy <$> get bh <*> get bh
+      12 -> HsEqTy <$> get bh <*> get bh
+      13 -> HsKindSig <$> get bh <*> get bh
+      14 -> HsBangTy <$> get bh <*> get bh
+      15 -> HsRecTy <$> get bh
+      16 -> HsExplicitListTy <$> get bh <*> get bh <*> get bh
+      17 -> HsExplicitTupleTy <$> get bh <*> get bh
+      18 -> HsTyLit <$> get bh
+      19 -> HsWildCardTy <$> get bh
+      20 -> HsDocTy <$> get bh <*> get bh
+      21 -> HsSpliceTy <$> get bh <*> get bh
+      _  -> getPanic "HsType"
+
+instance Binary HsTyLit where
+  put_ bh l = case l of
+    HsNumTy a b -> putByte bh 0 >> put_ bh a >> put_ bh b
+    HsStrTy a b -> putByte bh 1 >> put_ bh a >> put_ bh b
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> HsNumTy <$> get bh <*> get bh
+      1 -> HsStrTy <$> get bh <*> get bh
+      _ -> getPanic "HsTyLit"
+
+instance Binary (HsAppType GhcSe) where
+  put_ bh t = case t of
+    HsAppInfix a -> putByte bh 0 >> put_ bh a
+    HsAppPrefix a -> putByte bh 1 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> HsAppInfix <$> get bh
+      1 -> HsAppPrefix <$> get bh
+      _ -> getPanic "HsAppType"
+
+deriving instance Binary (HsWildCardInfo GhcSe)
+
+instance Binary a => Binary (HsWildCardBndrs GhcSe a) where
+  put_ bh w = case w of
+    HsWC a b -> put_ bh a >> put_ bh b
+  get bh = HsWC <$> get bh <*> get bh
+
+instance Binary a => Binary (HsImplicitBndrs GhcSe a) where
+  put_ bh b = case b of
+    HsIB a b c -> put_ bh a >> put_ bh b >> put_ bh c
+  get bh = HsIB <$> get bh <*> get bh <*> get bh
+
+instance Binary Promoted where
+  put_ bh p = putByte bh (case p of
+    Promoted -> 0
+    NotPromoted -> 1)
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure Promoted
+      1 -> pure NotPromoted
+      _ -> getPanic "Promoted"
+
+instance Binary HsTupleSort where
+  put_ bh s = putByte bh (case s of
+    HsUnboxedTuple -> 0
+    HsBoxedTuple -> 1
+    HsConstraintTuple -> 2
+    HsBoxedOrConstraintTuple -> 3)
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure HsUnboxedTuple
+      1 -> pure HsBoxedTuple
+      2 -> pure HsConstraintTuple
+      3 -> pure HsBoxedOrConstraintTuple
+      _ -> getPanic "HsTupleSort"
+
+instance Binary (ConDeclField GhcSe) where
+  put_ bh f = case f of
+    ConDeclField a b c ->
+      put_ bh a >> put_ bh b >> put_ bh c
+  get bh = ConDeclField <$> get bh <*> get bh <*> get bh
+
+instance Binary (FieldOcc GhcSe) where
+  put_ bh o = case o of
+    FieldOcc a b -> put_ bh a >> put_ bh b
+  get bh = FieldOcc <$> get bh <*> get bh
+
+instance Binary (HsTyVarBndr GhcSe) where
+  put_ bh v = case v of
+    UserTyVar a -> putByte bh 0 >> put_ bh a
+    KindedTyVar a b -> putByte bh 1 >> put_ bh a >> put_ bh b
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> UserTyVar <$> get bh
+      1 -> KindedTyVar <$> get bh <*> get bh
+      _ -> getPanic "HsTyVarBndr"
+
+instance (Binary a, Binary b) => Binary (HsConDetails a b) where
+  put_ bh c = case c of
+    PrefixCon a -> putByte bh 0 >> put_ bh a
+    RecCon a -> putByte bh 1 >> put_ bh a
+    InfixCon a b -> putByte bh 2 >> put_ bh a >> put_ bh b
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> PrefixCon <$> get bh
+      1 -> RecCon <$> get bh
+      2 -> InfixCon <$> get bh <*> get bh
+      _ -> getPanic "HsConDetails"
+
+instance Binary (AmbiguousFieldOcc GhcSe) where
+  put_ bh o = case o of
+    Unambiguous a b -> putByte bh 0 >> put_ bh a >> put_ bh b
+    Ambiguous a b   -> putByte bh 1 >> put_ bh a >> put_ bh b
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> Unambiguous <$> get bh <*> get bh
+      1 -> Ambiguous <$> get bh <*> get bh
+      _ -> getPanic "AmbiguousOccField"
+
+instance Binary (LHsQTyVars GhcSe) where
+  put_ bh v = case v of
+    HsQTvs a b c -> putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+  get bh = HsQTvs <$> get bh <*> get bh <*> get bh
+
+instance Binary (Sig GhcSe) where
+  put_ bh s = case s of
+    TypeSig a b ->
+      putByte bh 0 >> put_ bh a >> put_ bh b
+    PatSynSig a b ->
+      putByte bh 1 >> put_ bh a >> put_ bh b
+    ClassOpSig a b c ->
+      putByte bh 2 >> put_ bh a >> put_ bh b >> put_ bh c
+    IdSig a ->
+      putByte bh 3 >> put_ bh a
+    FixSig a ->
+      putByte bh 4 >> put_ bh a
+    InlineSig a b ->
+      putByte bh 5 >> put_ bh a >> put_ bh b
+    SpecSig a b c ->
+      putByte bh 6 >> put_ bh a >> put_ bh b >> put_ bh c
+    SpecInstSig a b ->
+      putByte bh 7 >> put_ bh a >> put_ bh b
+    SCCFunSig a b c ->
+      putByte bh 8 >> put_ bh a >> put_ bh b >> put_ bh c
+    CompleteMatchSig a b c ->
+      putByte bh 9 >> put_ bh a >> put_ bh b >> put_ bh c
+    MinimalSig a b ->
+      putByte bh 10 >> put_ bh a >> put_ bh b
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> TypeSig <$> get bh <*> get bh
+      1 -> PatSynSig <$> get bh <*> get bh
+      2 -> ClassOpSig <$> get bh <*> get bh <*> get bh
+      3 -> IdSig <$> get bh
+      4 -> FixSig <$> get bh
+      5 -> InlineSig <$> get bh <*> get bh
+      6 -> SpecSig <$> get bh <*> get bh <*> get bh
+      7 -> SpecInstSig <$> get bh <*> get bh
+      8 -> SCCFunSig <$> get bh <*> get bh <*> get bh
+      9 -> CompleteMatchSig <$> get bh <*> get bh <*> get bh
+      10 -> MinimalSig <$> get bh <*> get bh
+      _ -> getPanic "Sig"
+
+instance Binary (FixitySig GhcSe) where
+  put_ bh s = case s of
+    FixitySig a b -> put_ bh a >> put_ bh b
+  get bh = FixitySig <$> get bh <*> get bh
+
+instance Binary (HsBindLR GhcSe GhcSe) where
+  put_ bh b = case b of
+    -- TODO: we drop the "fun_co_fn" field, as it seems
+    --       to always be WpHole in the places where the binary
+    --       serialisation instances will be used.
+    -- TODO: we drop the "fun_tick" field, as it is unlikely
+    --       to be used in our immediate use cases. Let's
+    --       return to parametrising away the 'Id' in that
+    --       field's type.
+    FunBind a b c d _ -> case c of
+      WpHole ->
+        putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh d
+      _ ->
+        panic "Binary HsBindLR: FunBind with non-WpHole value in fun_co_fn"
+    -- TODO: same as for FunBind, we drop pat_ticks
+    PatBind a b c d _ ->
+      putByte bh 1 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    VarBind a b c ->
+      putByte bh 2 >> put_ bh a >> put_ bh b >> put_ bh c
+    PatSynBind a ->
+      putByte bh 3 >> put_ bh a
+    AbsBinds {} -> putPanic "HsBindsLR" "AbsBinds"
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> FunBind <$> get bh <*> get bh <*> pure WpHole <*> get bh <*> pure []
+      1 -> PatBind <$> get bh <*> get bh <*> get bh <*> get bh <*> pure ([], [])
+      2 -> VarBind <$> get bh <*> get bh <*> get bh
+      3 -> PatSynBind <$> get bh
+      _ -> getPanic "HsBindsLR"
+
+instance Binary (HsLocalBindsLR GhcSe GhcSe) where
+  put_ bh b = case b of
+    HsValBinds a    -> putByte bh 0 >> put_ bh a
+    EmptyLocalBinds -> putByte bh 1
+    HsIPBinds {}    -> putPanic "HsLocalBindsLR" "HsIPBinds"
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> HsValBinds <$> get bh
+      1 -> pure EmptyLocalBinds
+      _ -> getPanic "HsLocalBindsLR"
+
+instance Binary (HsValBindsLR GhcSe GhcSe) where
+  put_ bh b = case b of
+    ValBindsIn a b -> putByte bh 0 >> put_ bh a >> put_ bh b
+    ValBindsOut {} -> putPanic "HsValBindsLR" "ValBindsOut"
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> ValBindsIn <$> get bh <*> get bh
+      _ -> getPanic "HsValBindsLR"
+
+instance Binary (PatSynBind GhcSe GhcSe) where
+  put_ bh b = case b of
+    PSB a b c d e ->
+      put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d >> put_ bh e
+
+  get bh = PSB <$> get bh <*> get bh <*> get bh <*> get bh <*> get bh
+
+instance Binary (HsPatSynDir GhcSe) where
+  put_ bh d = case d of
+    Unidirectional -> putByte bh 0
+    ImplicitBidirectional -> putByte bh 1
+    ExplicitBidirectional a -> putByte bh 2 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure Unidirectional
+      1 -> pure ImplicitBidirectional
+      2 -> ExplicitBidirectional <$> get bh
+      _ -> getPanic "HsPatSynDir"
+
+instance Binary a => Binary (RecordPatSynField a) where
+  put_ bh (RecordPatSynField a b) = put_ bh a >> put_ bh b
+  get bh = RecordPatSynField <$> get bh <*> get bh
+
+instance Binary (IPBind GhcSe) where
+  put_ bh b = case b of
+    IPBind a b -> put_ bh a >> put_ bh b
+  get bh = IPBind <$> get bh <*> get bh
+
+-- * HsDecls
+
+instance Binary (HsDecl GhcSe) where
+  put_ bh d = case d of
+    TyClD a      -> putByte bh 0 >> put_ bh a
+    InstD a      -> putByte bh 1 >> put_ bh a
+    DerivD a     -> putByte bh 2 >> put_ bh a
+    ValD a       -> putByte bh 3 >> put_ bh a
+    SigD a       -> putByte bh 4 >> put_ bh a
+    DefD a       -> putByte bh 5 >> put_ bh a
+    ForD a       -> putByte bh 6 >> put_ bh a
+    WarningD a   -> putByte bh 7 >> put_ bh a
+    RoleAnnotD a -> putByte bh 8 >> put_ bh a
+    RuleD a      -> putByte bh 9 >> put_ bh a
+    AnnD a       -> putByte bh 10 >> put_ bh a
+    SpliceD a    -> putByte bh 11 >> put_ bh a
+    DocD a       -> putByte bh 12 >> put_ bh a
+    VectD a      -> putByte bh 13 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> TyClD <$> get bh
+      1 -> InstD <$> get bh
+      2 -> DerivD <$> get bh
+      3 -> ValD <$> get bh
+      4 -> SigD <$> get bh
+      5 -> DefD <$> get bh
+      6 -> ForD <$> get bh
+      7 -> WarningD <$> get bh
+      8 -> RoleAnnotD <$> get bh
+      9 -> RuleD <$> get bh
+      10 -> AnnD <$> get bh
+      11 -> SpliceD <$> get bh
+      12 -> DocD <$> get bh
+      13 -> VectD <$> get bh
+      _ -> getPanic "HsDecl"
+
+instance Binary (ForeignDecl GhcSe) where
+  put_ bh d = case d of
+    ForeignImport a b c d ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+                   >> put_ bh d
+    ForeignExport a b c d ->
+      putByte bh 1 >> put_ bh a >> put_ bh b >> put_ bh c
+                   >> put_ bh d
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> ForeignImport <$> get bh <*> get bh <*> get bh <*> get bh
+      1 -> ForeignExport <$> get bh <*> get bh <*> get bh <*> get bh
+      _ -> getPanic "ForeignDecl"
+
+instance Binary (DefaultDecl GhcSe) where
+  put_ bh d = case d of
+    DefaultDecl a -> put_ bh a
+  get bh = DefaultDecl <$> get bh
+
+instance Binary (TyClDecl GhcSe) where
+  put_ bh d = case d of
+    FamDecl a ->
+      putByte bh 0 >> put_ bh a
+    SynDecl a b c d e ->
+      putByte bh 1 >> put_ bh a >> put_ bh b >> put_ bh c
+                   >> put_ bh d >> put_ bh e
+    DataDecl a b c d e f ->
+      putByte bh 2 >> put_ bh a >> put_ bh b >> put_ bh c
+                   >> put_ bh d >> put_ bh e >> put_ bh f
+    ClassDecl a b c d e f g h i j k ->
+      putByte bh 3 >> put_ bh a >> put_ bh b >> put_ bh c
+                   >> put_ bh d >> put_ bh e >> put_ bh f
+                   >> put_ bh g >> put_ bh h >> put_ bh i
+                   >> put_ bh j >> put_ bh k
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> FamDecl <$> get bh
+      1 -> SynDecl <$> get bh <*> get bh <*> get bh <*> get bh <*> get bh
+      2 -> DataDecl <$> get bh <*> get bh <*> get bh <*> get bh <*> get bh <*> get bh
+      3 -> ClassDecl <$> get bh <*> get bh <*> get bh <*> get bh <*> get bh
+                     <*> get bh <*> get bh <*> get bh <*> get bh <*> get bh
+                     <*> get bh
+      _ -> getPanic "TyClDecl"
+
+instance Binary DocDecl where
+  put_ bh d = case d of
+    DocCommentNext a    -> putByte bh 0 >> put_ bh a
+    DocCommentPrev a    -> putByte bh 1 >> put_ bh a
+    DocCommentNamed a b -> putByte bh 2 >> put_ bh a >> put_ bh b
+    DocGroup a b        -> putByte bh 3 >> put_ bh a >> put_ bh b
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> DocCommentNext <$> get bh
+      1 -> DocCommentPrev <$> get bh
+      2 -> DocCommentNamed <$> get bh <*> get bh
+      3 -> DocGroup <$> get bh <*> get bh
+      _ -> getPanic "DocDecl"
+
+instance Binary (WarnDecls GhcSe) where
+  put_ bh (Warnings a b) = put_ bh a >> put_ bh b
+  get bh = Warnings <$> get bh <*> get bh
+
+instance Binary (WarnDecl GhcSe) where
+  put_ bh (Warning a b) = put_ bh a >> put_ bh b
+  get bh = Warning <$> get bh <*> get bh
+
+instance Binary (RoleAnnotDecl GhcSe) where
+  put_ bh (RoleAnnotDecl a b) = put_ bh a >> put_ bh b
+  get bh = RoleAnnotDecl <$> get bh <*> get bh
+
+instance Binary (RuleDecls GhcSe) where
+  put_ bh (HsRules a b) = put_ bh a >> put_ bh b
+  get bh = HsRules <$> get bh <*> get bh
+
+instance Binary (RuleDecl GhcSe) where
+  put_ bh (HsRule a b c d e f g) =
+    put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+              >> put_ bh e >> put_ bh f >> put_ bh g
+  get bh = HsRule <$> get bh <*> get bh <*> get bh <*> get bh
+                  <*> get bh <*> get bh <*> get bh
+
+instance Binary (AnnDecl GhcSe) where
+  put_ bh (HsAnnotation a b c) = put_ bh a >> put_ bh b >> put_ bh c
+  get bh = HsAnnotation <$> get bh <*> get bh <*> get bh
+
+instance Binary (SpliceDecl GhcSe) where
+  put_ bh (SpliceDecl a b) = put_ bh a >> put_ bh b
+  get bh = SpliceDecl <$> get bh <*> get bh
+
+instance Binary a => Binary (Tickish a) where
+  put_ bh t = case t of
+    ProfNote a b c ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+    HpcTick a b ->
+      putByte bh 1 >> put_ bh a >> put_ bh b
+    Breakpoint a b ->
+      putByte bh 2 >> put_ bh a >> put_ bh b
+    SourceNote a b ->
+      putByte bh 3 >> put_ bh a >> put_ bh b
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> ProfNote <$> get bh <*> get bh <*> get bh
+      1 -> HpcTick <$> get bh <*> get bh
+      2 -> Breakpoint <$> get bh <*> get bh
+      3 -> SourceNote <$> get bh <*> get bh
+      _ -> getPanic "Tickish"
+
+instance Binary SpliceExplicitFlag where
+  put_ bh f = putByte bh $ case f of
+    ExplicitSplice -> 0
+    ImplicitSplice -> 1
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure ExplicitSplice
+      1 -> pure ImplicitSplice
+      _ -> getPanic "SpliceExplicitFlag"
+
+instance Binary SpliceDecoration where
+  put_ bh d = putByte bh $ case d of
+    HasParens -> 0
+    HasDollar -> 1
+    NoParens  -> 2
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure HasParens
+      1 -> pure HasDollar
+      2 -> pure NoParens
+      _ -> getPanic "SpliceDecoration"
+
+instance Binary (HsSplice GhcSe) where
+  put_ bh s = case s of
+    HsTypedSplice a b c ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsUntypedSplice a b c ->
+      putByte bh 1 >> put_ bh a >> put_ bh b >> put_ bh c
+    HsQuasiQuote a b c d ->
+      putByte bh 2 >> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+    HsSpliced {} -> putPanic "HsSplice" "HsSpliced"
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> HsTypedSplice <$> get bh <*> get bh <*> get bh
+      1 -> HsUntypedSplice <$> get bh <*> get bh <*> get bh
+      2 -> HsQuasiQuote <$> get bh <*> get bh <*> get bh <*> get bh
+      _ -> getPanic "HsSplice"
+
+instance Binary (AnnProvenance SeName) where
+  put_ bh p = case p of
+    ValueAnnProvenance a -> putByte bh 0 >> put_ bh a
+    TypeAnnProvenance a -> putByte bh 1 >> put_ bh a
+    ModuleAnnProvenance -> putByte bh 2
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> ValueAnnProvenance <$> get bh
+      1 -> TypeAnnProvenance <$> get bh
+      2 -> pure ModuleAnnProvenance
+      _ -> getPanic "AnnProvenance"
+
+instance Binary ForeignImport where
+  put_ bh (CImport a b c d e) =
+    put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+              >> put_ bh e
+  get bh = CImport <$> get bh <*> get bh <*> get bh
+                   <*> get bh <*> get bh
+
+instance Binary CImportSpec where
+  put_ bh s = case s of
+    CLabel a -> putByte bh 0 >> put_ bh a
+    CFunction a -> putByte bh 1 >> put_ bh a
+    CWrapper -> putByte bh 2
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> CLabel <$> get bh
+      1 -> CFunction <$> get bh
+      2 -> pure CWrapper
+      _ -> getPanic "CImportSpec"
+
+instance Binary ForeignExport where
+  put_ bh (CExport a b) = put_ bh a >> put_ bh b
+  get bh = CExport <$> get bh <*> get bh
+
+instance Binary (RuleBndr GhcSe) where
+  put_ bh b = case b of
+    RuleBndr a -> putByte bh 0 >> put_ bh a
+    RuleBndrSig a b -> putByte bh 1 >> put_ bh a >> put_ bh b
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> RuleBndr <$> get bh
+      1 -> RuleBndrSig <$> get bh <*> get bh
+      _ -> getPanic "RuleBndr"
+
+instance (Binary a, Binary b) => Binary (FamEqn GhcSe a b) where
+  put_ bh e = case e of
+    FamEqn a b c d ->
+      put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+  get bh = FamEqn <$> get bh <*> get bh <*> get bh <*> get bh
+
+instance Binary (HsDataDefn GhcSe) where
+  put_ bh d = case d of
+    HsDataDefn a b c d e f ->
+      put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+                >> put_ bh e >> put_ bh f
+  get bh = HsDataDefn <$> get bh <*> get bh <*> get bh <*> get bh
+                      <*> get bh <*> get bh
+
+instance Binary NewOrData where
+  put_ bh a = putByte bh (case a of
+    NewType  -> 0
+    DataType -> 1)
+  get bh = getByte bh >>= \b -> case b of
+    0 -> pure NewType
+    1 -> pure DataType
+    _ -> getPanic "NewOrData"
+
+instance Binary (HsDerivingClause GhcSe) where
+  put_ bh c = case c of
+    HsDerivingClause a b ->
+      put_ bh a >> put_ bh b
+  get bh = HsDerivingClause <$> get bh <*> get bh
+
+instance Binary (ConDecl GhcSe) where
+  put_ bh d = case d of
+    ConDeclGADT a b c ->
+      putByte bh 0 >> put_ bh a >> put_ bh b >> put_ bh c
+    ConDeclH98 a b c d e ->
+      putByte bh 1 >> put_ bh a >> put_ bh b >> put_ bh c
+                   >> put_ bh d >> put_ bh e
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> ConDeclGADT <$> get bh <*> get bh <*> get bh
+      1 -> ConDeclH98 <$> get bh <*> get bh <*> get bh <*> get bh <*> get bh
+      _ -> getPanic "ConDecl"
+
+
+instance Binary (FamilyDecl GhcSe) where
+  put_ bh d = case d of
+    FamilyDecl a b c d e f ->
+      put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d >> put_ bh e >> put_ bh f
+
+  get bh = FamilyDecl <$> get bh <*> get bh <*> get bh <*> get bh <*> get bh
+                      <*> get bh
+
+instance Binary (InjectivityAnn GhcSe) where
+  put_ bh a = case a of
+    InjectivityAnn a b -> put_ bh a >> put_ bh b
+  get bh = InjectivityAnn <$> get bh <*> get bh
+
+instance Binary (FamilyInfo GhcSe) where
+  put_ bh i = case i of
+    DataFamily ->
+      putByte bh 0
+    OpenTypeFamily ->
+      putByte bh 1
+    ClosedTypeFamily a ->
+      putByte bh 2 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure DataFamily
+      1 -> pure OpenTypeFamily
+      2 -> ClosedTypeFamily <$> get bh
+      _ -> getPanic "FamilyInfo"
+
+instance Binary (FamilyResultSig GhcSe) where
+  put_ bh s = case s of
+    NoSig ->
+      putByte bh 0
+    KindSig a ->
+      putByte bh 1 >> put_ bh a
+    TyVarSig a ->
+      putByte bh 2 >> put_ bh a
+
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure NoSig
+      1 -> KindSig <$> get bh
+      2 -> TyVarSig <$> get bh
+      _ -> getPanic "FamilyResultSig"
+
+instance Binary (InstDecl GhcSe) where
+  put_ bh d = case d of
+    ClsInstD a ->
+      putByte bh 0 >> put_ bh a
+    DataFamInstD a ->
+      putByte bh 1 >> put_ bh a
+    TyFamInstD a ->
+      putByte bh 2 >> put_ bh a
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> ClsInstD <$> get bh
+      1 -> DataFamInstD <$> get bh
+      2 -> TyFamInstD <$> get bh
+      _ -> getPanic "InstDecl"
+
+instance Binary (ClsInstDecl GhcSe) where
+  put_ bh d = case d of
+    ClsInstDecl a b c d e f ->
+      put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+                >> put_ bh e >> put_ bh f
+  get bh = ClsInstDecl <$> get bh <*> get bh <*> get bh <*> get bh
+                       <*> get bh <*> get bh
+
+instance Binary (DataFamInstDecl GhcSe) where
+  put_ bh (DataFamInstDecl a) = put_ bh a
+  get bh = DataFamInstDecl <$> get bh
+
+instance Binary (TyFamInstDecl GhcSe) where
+  put_ bh (TyFamInstDecl a) = put_ bh a
+  get bh = TyFamInstDecl <$> get bh
+
+instance Binary (DerivDecl GhcSe) where
+  put_ bh d = case d of
+    DerivDecl a b c ->
+      put_ bh a >> put_ bh b >> put_ bh c
+  get bh = DerivDecl <$> get bh <*> get bh <*> get bh
+
+instance Binary DerivStrategy where
+  put_ bh s = putByte bh (case s of
+    StockStrategy    -> 0
+    AnyclassStrategy -> 1
+    NewtypeStrategy  -> 2)
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure StockStrategy
+      1 -> pure AnyclassStrategy
+      2 -> pure NewtypeStrategy
+      _ -> getPanic "DerivStrategy"
+
+instance Binary HsSrcBang where
+  put_ bh (HsSrcBang a b c) =
+    put_ bh a >> put_ bh b >> put_ bh c
+  get bh = HsSrcBang <$> get bh <*> get bh <*> get bh
+
+instance Binary RdrName where
+  put_ bh n = case n of
+    Unqual a -> putByte bh 0 >> put_ bh a
+    Qual a b -> putByte bh 1 >> put_ bh a >> put_ bh b
+    Orig a b -> putByte bh 2 >> put_ bh a >> put_ bh b
+    Exact a
+      | isExternalName a -> putByte bh 3 >> put_ bh a
+      | otherwise -> putByte bh (if isSystemName a then 4 else 5)
+          >> put_ bh (nameUnique a) >> put_ bh (nameOccName a)
+          >> put_ bh (nameSrcSpan a)
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> Unqual <$> get bh
+      1 -> Qual <$> get bh <*> get bh
+      2 -> Orig <$> get bh <*> get bh
+      3 -> Exact <$> get bh
+      4 -> fmap Exact (mkSystemNameAt <$> get bh <*> get bh <*> get bh)
+      5 -> fmap Exact (mkInternalName <$> get bh <*> get bh <*> get bh)
+      _ -> getPanic "RdrName"
+
+-- * HsDoc
+
+instance Binary HsDocString where
+  put_ bh (HsDocString s) = put_ bh s
+  get bh = HsDocString <$> get bh
+
+-- * HsLit
+
+instance Binary (HsLit GhcSe) where
+  put_ bh lit
+    = case lit of
+        HsChar a b       -> putByte bh 0  >> put_ bh a >> put_ bh b
+        HsCharPrim a b   -> putByte bh 1  >> put_ bh a >> put_ bh b
+        HsString a b     -> putByte bh 2  >> put_ bh a >> put_ bh b
+        HsStringPrim a b -> putByte bh 3  >> put_ bh a >> put_ bh b
+        HsInt a b        -> putByte bh 4  >> put_ bh a >> put_ bh b
+        HsIntPrim a b    -> putByte bh 5  >> put_ bh a >> put_ bh b
+        HsWordPrim a b   -> putByte bh 6  >> put_ bh a >> put_ bh b
+        HsInt64Prim a b  -> putByte bh 7  >> put_ bh a >> put_ bh b
+        HsWord64Prim a b -> putByte bh 8  >> put_ bh a >> put_ bh b
+        HsInteger a b c  -> putByte bh 9  >> put_ bh a >> put_ bh b >> put_ bh c
+        HsRat a b c      -> putByte bh 10 >> put_ bh a >> put_ bh b >> put_ bh c
+        HsFloatPrim a b  -> putByte bh 11 >> put_ bh a >> put_ bh b
+        HsDoublePrim a b -> putByte bh 12 >> put_ bh a >> put_ bh b
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0  -> HsChar       <$> get bh <*> get bh
+      1  -> HsCharPrim   <$> get bh <*> get bh
+      2  -> HsString     <$> get bh <*> get bh
+      3  -> HsStringPrim <$> get bh <*> get bh
+      4  -> HsInt        <$> get bh <*> get bh
+      5  -> HsIntPrim    <$> get bh <*> get bh
+      6  -> HsWordPrim   <$> get bh <*> get bh
+      7  -> HsInt64Prim  <$> get bh <*> get bh
+      8  -> HsWord64Prim <$> get bh <*> get bh
+      9  -> HsInteger    <$> get bh <*> get bh <*> get bh
+      10 -> HsRat        <$> get bh <*> get bh <*> get bh
+      11 -> HsFloatPrim  <$> get bh <*> get bh
+      12 -> HsDoublePrim <$> get bh <*> get bh
+      _ -> getPanic "Binary HsLit.get: unknown tag"
+
+instance Binary (HsOverLit GhcSe) where
+  put_ bh lit = case lit of
+    OverLit a b c d -> put_ bh a >> put_ bh b >> put_ bh c >> put_ bh d
+  get bh = OverLit <$> get bh <*> get bh <*> get bh <*> get bh
+
+instance Binary OverLitVal where
+  put_ bh v
+    = case v of
+        HsIntegral a   -> putByte bh 0 >> put_ bh a
+        HsFractional a -> putByte bh 1 >> put_ bh a
+        HsIsString a b -> putByte bh 2 >> put_ bh a >> put_ bh b
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> HsIntegral <$> get bh
+      1 -> HsFractional <$> get bh
+      2 -> HsIsString <$> get bh <*> get bh
+      _ -> getPanic "OverLitVal"
+
+instance Binary PlaceHolder where
+  put_ _ _ = return ()
+  get _ = pure PlaceHolder
diff --git a/compiler/hsSyn/HsExtension.hs b/compiler/hsSyn/HsExtension.hs
index 80dfa67ea3..dffae5af39 100644
--- a/compiler/hsSyn/HsExtension.hs
+++ b/compiler/hsSyn/HsExtension.hs
@@ -23,7 +23,9 @@ import ConLike
 import NameSet
 import Name
 import RdrName
+import SeName
 import Var
+import IfaceType  ( IfaceType )
 import Type       ( Type )
 import Outputable
 import SrcLoc (Located)
@@ -60,14 +62,15 @@ data GhcPass (c :: Pass)
 deriving instance Eq (GhcPass c)
 deriving instance Typeable c => Data (GhcPass c)
 
-data Pass = Parsed | Renamed | Typechecked
+data Pass = Parsed | Renamed | Typechecked | Serialisable
          deriving (Data)
 
 -- Type synonyms as a shorthand for tagging
-type GhcPs   = GhcPass 'Parsed      -- Old 'RdrName' type param
-type GhcRn   = GhcPass 'Renamed     -- Old 'Name' type param
-type GhcTc   = GhcPass 'Typechecked -- Old 'Id' type para,
-type GhcTcId = GhcTc                -- Old 'TcId' type param
+type GhcPs   = GhcPass 'Parsed       -- Old 'RdrName' type param
+type GhcRn   = GhcPass 'Renamed      -- Old 'Name' type param
+type GhcTc   = GhcPass 'Typechecked  -- Old 'Id' type para,
+type GhcSe   = GhcPass 'Serialisable -- New pass, with serialisable AST representations
+type GhcTcId = GhcTc                 -- Old 'TcId' type param
 
 
 -- | Types that are not defined until after type checking
@@ -75,19 +78,21 @@ type family PostTc x ty -- Note [Pass sensitive types] in PlaceHolder
 type instance PostTc GhcPs ty = PlaceHolder
 type instance PostTc GhcRn ty = PlaceHolder
 type instance PostTc GhcTc ty = ty
+type instance PostTc GhcSe ty = PlaceHolder
 
 -- | Types that are not defined until after renaming
 type family PostRn x ty  -- Note [Pass sensitive types] in PlaceHolder
 type instance PostRn GhcPs ty = PlaceHolder
 type instance PostRn GhcRn ty = ty
 type instance PostRn GhcTc ty = ty
+type instance PostRn GhcSe ty = PlaceHolder
 
 -- | Maps the "normal" id type for a given pass
 type family IdP p
 type instance IdP GhcPs = RdrName
 type instance IdP GhcRn = Name
 type instance IdP GhcTc = Id
-
+type instance IdP GhcSe = SeName
 
 -- We define a type family for each extension point. This is based on prepending
 -- 'X' to the constructor name, for ease of reference.
@@ -169,6 +174,21 @@ type instance XHsRat        GhcTc = ()
 type instance XHsFloatPrim  GhcTc = ()
 type instance XHsDoublePrim GhcTc = ()
 
+-- Provide the specific extension types for the serialisation phase.
+type instance XHsChar       GhcSe = SourceText
+type instance XHsCharPrim   GhcSe = SourceText
+type instance XHsString     GhcSe = SourceText
+type instance XHsStringPrim GhcSe = SourceText
+type instance XHsInt        GhcSe = ()
+type instance XHsIntPrim    GhcSe = SourceText
+type instance XHsWordPrim   GhcSe = SourceText
+type instance XHsInt64Prim  GhcSe = SourceText
+type instance XHsWord64Prim GhcSe = SourceText
+type instance XHsInteger    GhcSe = SourceText
+type instance XHsRat        GhcSe = ()
+type instance XHsFloatPrim  GhcSe = ()
+type instance XHsDoublePrim GhcSe = ()
+
 
 -- ---------------------------------------------------------------------
 
@@ -264,8 +284,11 @@ type DataId p =
   ( Data p
   , ForallX Data p
   , Data (NameOrRdrName (IdP p))
-
+  , Data (RdrOrSeName p)
   , Data (IdP p)
+  , Data (LitType p)
+  , Data (IdSigId p)
+  , Data (DoName p)
   , Data (PostRn p (IdP p))
   , Data (PostRn p (Located Name))
   , Data (PostRn p Bool)
@@ -288,4 +311,35 @@ type DataId p =
 type OutputableBndrId id =
   ( OutputableBndr (NameOrRdrName (IdP id))
   , OutputableBndr (IdP id)
+  , OutputableBndr (RdrOrSeName id)
+  , OutputableBndr (IdSigId id)
+  , VarType (IdSigId id)
+  -- , RdrOrSeName id ~ RdrName
   )
+
+class VarType a where
+  getVarType :: a -> Maybe Type
+
+instance VarType Var where
+  getVarType = Just . varType
+
+instance VarType SeName where
+  getVarType _ = Nothing
+
+type family IdSigId pass where
+  IdSigId GhcSe       = SeName
+  IdSigId (GhcPass _) = Id
+
+type family LitType x where
+  LitType (GhcPass 'Serialisable) = IfaceType
+  LitType                       a = Type
+
+type family DoName pass where
+  DoName GhcSe = SeName
+  DoName (GhcPass _) = Name
+
+type family RdrOrSeName pass
+type instance RdrOrSeName GhcSe = SeName
+type instance RdrOrSeName GhcRn = RdrName
+type instance RdrOrSeName GhcTc = RdrName
+type instance RdrOrSeName GhcPs = RdrName
diff --git a/compiler/hsSyn/HsImpExp.hs b/compiler/hsSyn/HsImpExp.hs
index 2930b51ee2..fd14631718 100644
--- a/compiler/hsSyn/HsImpExp.hs
+++ b/compiler/hsSyn/HsImpExp.hs
@@ -11,6 +11,7 @@ HsImpExp: Abstract syntax: imports, exports, interfaces
 {-# LANGUAGE StandaloneDeriving #-}
 {-# LANGUAGE UndecidableInstances #-} -- Note [Pass sensitive types]
                                       -- in module PlaceHolder
+{-# LANGUAGE TypeFamilies #-}
 
 module HsImpExp where
 
diff --git a/compiler/hsSyn/HsLit.hs b/compiler/hsSyn/HsLit.hs
index d46ef9b448..273f260c17 100644
--- a/compiler/hsSyn/HsLit.hs
+++ b/compiler/hsSyn/HsLit.hs
@@ -14,7 +14,7 @@
                                       -- in module PlaceHolder
 {-# LANGUAGE ConstraintKinds #-}
 {-# LANGUAGE TypeFamilies #-}
-
+{-# LANGUAGE DataKinds #-}
 module HsLit where
 
 #include "HsVersions.h"
@@ -64,11 +64,11 @@ data HsLit x
       -- ^ literal @Int64#@
   | HsWord64Prim (XHsWord64Prim x) {- SourceText -} Integer
       -- ^ literal @Word64#@
-  | HsInteger (XHsInteger x) {- SourceText -} Integer Type
+  | HsInteger (XHsInteger x) {- SourceText -} Integer (LitType x)
       -- ^ Genuinely an integer; arises only
       -- from TRANSLATION (overloaded
       -- literals are done with HsOverLit)
-  | HsRat (XHsRat x)  FractionalLit Type
+  | HsRat (XHsRat x)  FractionalLit (LitType x)
       -- ^ Genuinely a rational; arises only from
       -- TRANSLATION (overloaded literals are
       -- done with HsOverLit)
@@ -124,7 +124,7 @@ overLitType = ol_type
 
 -- | Convert a literal from one index type to another, updating the annotations
 -- according to the relevant 'Convertable' instance
-convertLit :: (ConvertIdX a b) => HsLit a -> HsLit b
+convertLit :: (ConvertIdX a b, LitType a ~ LitType b) => HsLit a -> HsLit b
 convertLit (HsChar a x)       = (HsChar (convert a) x)
 convertLit (HsCharPrim a x)   = (HsCharPrim (convert a) x)
 convertLit (HsString a x)     = (HsString (convert a) x)
diff --git a/compiler/hsSyn/HsPat.hs b/compiler/hsSyn/HsPat.hs
index e25ff7bbcc..721888423d 100644
--- a/compiler/hsSyn/HsPat.hs
+++ b/compiler/hsSyn/HsPat.hs
@@ -396,7 +396,8 @@ hsRecFieldSel = fmap selectorFieldOcc . hsRecFieldLbl
 hsRecFieldId :: HsRecField GhcTc arg -> Located Id
 hsRecFieldId = hsRecFieldSel
 
-hsRecUpdFieldRdr :: HsRecUpdField p -> Located RdrName
+hsRecUpdFieldRdr
+  :: RdrOrSeName p ~ RdrName => HsRecUpdField p -> Located RdrName
 hsRecUpdFieldRdr = fmap rdrNameAmbiguousFieldOcc . hsRecFieldLbl
 
 hsRecUpdFieldId :: HsRecField' (AmbiguousFieldOcc GhcTc) arg -> Located Id
@@ -491,7 +492,7 @@ pprConArgs (PrefixCon pats) = sep (map pprParendLPat pats)
 pprConArgs (InfixCon p1 p2) = sep [pprParendLPat p1, pprParendLPat p2]
 pprConArgs (RecCon rpats)   = ppr rpats
 
-instance (Outputable arg)
+instance (Outputable arg, Outputable (RdrOrSeName p))
       => Outputable (HsRecFields p arg) where
   ppr (HsRecFields { rec_flds = flds, rec_dotdot = Nothing })
         = braces (fsep (punctuate comma (map ppr flds)))
diff --git a/compiler/hsSyn/HsPat.hs-boot b/compiler/hsSyn/HsPat.hs-boot
index 8cb82ed22e..7cfb5ba6cd 100644
--- a/compiler/hsSyn/HsPat.hs-boot
+++ b/compiler/hsSyn/HsPat.hs-boot
@@ -4,6 +4,7 @@
                                       -- in module PlaceHolder
 {-# LANGUAGE ConstraintKinds #-}
 {-# LANGUAGE RoleAnnotations #-}
+{-# LaNGUAGE TypeFamilies #-} -- needed to use OutputableBndrId
 
 module HsPat where
 import SrcLoc( Located )
diff --git a/compiler/hsSyn/HsSyn.hs b/compiler/hsSyn/HsSyn.hs
index 62bfa2e5c5..a5174cd3d5 100644
--- a/compiler/hsSyn/HsSyn.hs
+++ b/compiler/hsSyn/HsSyn.hs
@@ -15,6 +15,7 @@ therefore, is almost nothing but re-exporting.
 {-# LANGUAGE UndecidableInstances #-} -- Note [Pass sensitive types]
                                       -- in module PlaceHolder
 {-# LANGUAGE ConstraintKinds #-}
+{-# LANGUAGE TypeFamilies #-}
 
 module HsSyn (
         module HsBinds,
diff --git a/compiler/hsSyn/HsTypes.hs b/compiler/hsSyn/HsTypes.hs
index af30d227d3..77e70d79b9 100644
--- a/compiler/hsSyn/HsTypes.hs
+++ b/compiler/hsSyn/HsTypes.hs
@@ -10,6 +10,7 @@ HsTypes: Abstract syntax: user-defined types
 {-# LANGUAGE FlexibleContexts #-}
 {-# LANGUAGE FlexibleInstances #-}
 {-# LANGUAGE StandaloneDeriving #-}
+{-# LANGUAGE TypeFamilies #-}
 {-# LANGUAGE TypeSynonymInstances #-}
 {-# LANGUAGE UndecidableInstances #-} -- Note [Pass sensitive types]
                                       -- in module PlaceHolder
@@ -39,7 +40,7 @@ module HsTypes (
 
         HsConDetails(..),
 
-        FieldOcc(..), LFieldOcc, mkFieldOcc,
+        FieldOcc(..), LFieldOcc, mkFieldOcc, fieldOccRdrName,
         AmbiguousFieldOcc(..), mkAmbiguousFieldOcc,
         rdrNameAmbiguousFieldOcc, selectorAmbiguousFieldOcc,
         unambiguousFieldOcc, ambiguousFieldOcc,
@@ -86,6 +87,7 @@ import TysPrim( funTyConName )
 import Type
 import HsDoc
 import BasicTypes
+import Binary
 import SrcLoc
 import Outputable
 import FastString
@@ -392,6 +394,10 @@ newtype HsIPName = HsIPName FastString
 hsIPNameFS :: HsIPName -> FastString
 hsIPNameFS (HsIPName n) = n
 
+instance Binary HsIPName where
+  put_ bh (HsIPName s) = put_ bh s
+  get bh = HsIPName <$> get bh
+
 instance Outputable HsIPName where
     ppr (HsIPName n) = char '?' <> ftext n -- Ordinary implicit parameters
 
@@ -1100,20 +1106,24 @@ type LFieldOcc pass = Located (FieldOcc pass)
 -- Represents an *occurrence* of an unambiguous field.  We store
 -- both the 'RdrName' the user originally wrote, and after the
 -- renamer, the selector function.
-data FieldOcc pass = FieldOcc { rdrNameFieldOcc  :: Located RdrName
+data FieldOcc pass = FieldOcc { rdrNameFieldOcc  :: Located (RdrOrSeName pass)
                                  -- ^ See Note [Located RdrNames] in HsExpr
                               , selectorFieldOcc :: PostRn pass (IdP pass)
                               }
-deriving instance Eq (PostRn pass (IdP pass))  => Eq  (FieldOcc pass)
-deriving instance Ord (PostRn pass (IdP pass)) => Ord (FieldOcc pass)
+deriving instance (Eq (PostRn pass (IdP pass)), Eq (RdrOrSeName pass))
+               => Eq  (FieldOcc pass)
+deriving instance (Ord (PostRn pass (IdP pass)), Ord (RdrOrSeName pass))
+               => Ord (FieldOcc pass)
 deriving instance (DataId pass) => Data (FieldOcc pass)
 
-instance Outputable (FieldOcc pass) where
+instance Outputable (RdrOrSeName pass) => Outputable (FieldOcc pass) where
   ppr = ppr . rdrNameFieldOcc
 
 mkFieldOcc :: Located RdrName -> FieldOcc GhcPs
 mkFieldOcc rdr = FieldOcc rdr PlaceHolder
 
+fieldOccRdrName :: RdrOrSeName pass ~ RdrName => FieldOcc pass -> Located RdrName
+fieldOccRdrName = rdrNameFieldOcc
 
 -- | Ambiguous Field Occurrence
 --
@@ -1128,21 +1138,24 @@ mkFieldOcc rdr = FieldOcc rdr PlaceHolder
 -- Note [Disambiguating record fields] in TcExpr.
 -- See Note [Located RdrNames] in HsExpr
 data AmbiguousFieldOcc pass
-  = Unambiguous (Located RdrName) (PostRn pass (IdP pass))
-  | Ambiguous   (Located RdrName) (PostTc pass (IdP pass))
+  = Unambiguous (Located (RdrOrSeName pass)) (PostRn pass (IdP pass))
+  | Ambiguous   (Located (RdrOrSeName pass)) (PostTc pass (IdP pass))
 deriving instance DataId pass => Data (AmbiguousFieldOcc pass)
 
-instance Outputable (AmbiguousFieldOcc pass) where
+instance Outputable (RdrOrSeName pass)
+      => Outputable (AmbiguousFieldOcc pass) where
   ppr = ppr . rdrNameAmbiguousFieldOcc
 
-instance OutputableBndr (AmbiguousFieldOcc pass) where
+instance OutputableBndr (RdrOrSeName pass)
+      => OutputableBndr (AmbiguousFieldOcc pass) where
   pprInfixOcc  = pprInfixOcc . rdrNameAmbiguousFieldOcc
   pprPrefixOcc = pprPrefixOcc . rdrNameAmbiguousFieldOcc
 
 mkAmbiguousFieldOcc :: Located RdrName -> AmbiguousFieldOcc GhcPs
 mkAmbiguousFieldOcc rdr = Unambiguous rdr PlaceHolder
 
-rdrNameAmbiguousFieldOcc :: AmbiguousFieldOcc pass -> RdrName
+rdrNameAmbiguousFieldOcc
+  :: AmbiguousFieldOcc pass -> RdrOrSeName pass
 rdrNameAmbiguousFieldOcc (Unambiguous (L _ rdr) _) = rdr
 rdrNameAmbiguousFieldOcc (Ambiguous   (L _ rdr) _) = rdr
 
diff --git a/compiler/hsSyn/HsUtils.hs b/compiler/hsSyn/HsUtils.hs
index 5cc70c4a06..65a7e10980 100644
--- a/compiler/hsSyn/HsUtils.hs
+++ b/compiler/hsSyn/HsUtils.hs
@@ -1089,8 +1089,9 @@ hsTyClForeignBinders tycl_decls foreign_decls
     getSelectorNames (ns, fs) = map unLoc ns ++ map (selectorFieldOcc.unLoc) fs
 
 -------------------
-hsLTyClDeclBinders :: Located (TyClDecl pass)
-                   -> ([Located (IdP pass)], [LFieldOcc pass])
+hsLTyClDeclBinders
+  :: RdrOrSeName pass ~ RdrName
+  => Located (TyClDecl pass) -> ([Located (IdP pass)], [LFieldOcc pass])
 -- ^ Returns all the /binding/ names of the decl.  The first one is
 -- guaranteed to be the name of the decl. The first component
 -- represents all binding names except record fields; the second
@@ -1140,8 +1141,9 @@ getPatSynBinds binds
           , L _ (PatSynBind psb) <- bagToList lbinds ]
 
 -------------------
-hsLInstDeclBinders :: LInstDecl pass
-                   -> ([Located (IdP pass)], [LFieldOcc pass])
+hsLInstDeclBinders
+  :: RdrOrSeName pass ~ RdrName
+  => LInstDecl pass -> ([Located (IdP pass)], [LFieldOcc pass])
 hsLInstDeclBinders (L _ (ClsInstD { cid_inst = ClsInstDecl { cid_datafam_insts = dfis } }))
   = foldMap (hsDataFamInstBinders . unLoc) dfis
 hsLInstDeclBinders (L _ (DataFamInstD { dfid_inst = fi }))
@@ -1150,8 +1152,9 @@ hsLInstDeclBinders (L _ (TyFamInstD {})) = mempty
 
 -------------------
 -- the SrcLoc returned are for the whole declarations, not just the names
-hsDataFamInstBinders :: DataFamInstDecl pass
-                     -> ([Located (IdP pass)], [LFieldOcc pass])
+hsDataFamInstBinders
+  :: RdrOrSeName pass ~ RdrName
+  => DataFamInstDecl pass -> ([Located (IdP pass)], [LFieldOcc pass])
 hsDataFamInstBinders (DataFamInstDecl { dfid_eqn = HsIB { hsib_body =
                        FamEqn { feqn_rhs = defn }}})
   = hsDataDefnBinders defn
@@ -1159,13 +1162,17 @@ hsDataFamInstBinders (DataFamInstDecl { dfid_eqn = HsIB { hsib_body =
 
 -------------------
 -- the SrcLoc returned are for the whole declarations, not just the names
-hsDataDefnBinders :: HsDataDefn pass -> ([Located (IdP pass)], [LFieldOcc pass])
+hsDataDefnBinders
+  :: RdrOrSeName pass ~ RdrName
+  => HsDataDefn pass -> ([Located (IdP pass)], [LFieldOcc pass])
 hsDataDefnBinders (HsDataDefn { dd_cons = cons })
   = hsConDeclsBinders cons
   -- See Note [Binders in family instances]
 
 -------------------
-hsConDeclsBinders :: [LConDecl pass] -> ([Located (IdP pass)], [LFieldOcc pass])
+hsConDeclsBinders
+  :: forall pass. RdrOrSeName pass ~ RdrName
+  => [LConDecl pass] -> ([Located (IdP pass)], [LFieldOcc pass])
   -- See hsLTyClDeclBinders for what this does
   -- The function is boringly complicated because of the records
   -- And since we only have equality, we have to be a little careful
@@ -1195,9 +1202,10 @@ hsConDeclsBinders cons = go id cons
                  (_tvs, _cxt, tau) = splitLHsSigmaTy res_ty
                  record_gadt flds = (map (L loc . unLoc) names ++ ns, r' ++ fs)
                    where r' = remSeen (concatMap (cd_fld_names . unLoc) flds)
+                         remSeen' :: [LFieldOcc pass] -> [LFieldOcc pass]
                          remSeen' = foldr (.) remSeen
                                         [deleteBy ((==) `on`
-                                              unLoc . rdrNameFieldOcc . unLoc) v
+                                              unLoc . fieldOccRdrName . unLoc) v
                                         | v <- r']
                          (ns, fs) = go remSeen' rs
 
@@ -1206,10 +1214,11 @@ hsConDeclsBinders cons = go id cons
                ([L loc (unLoc name)] ++ ns, r' ++ fs)
                   where r' = remSeen (concatMap (cd_fld_names . unLoc)
                                                 (unLoc flds))
+                        remSeen' :: [LFieldOcc pass] -> [LFieldOcc pass]
                         remSeen'
                           = foldr (.) remSeen
                                [deleteBy ((==) `on`
-                                   unLoc . rdrNameFieldOcc . unLoc) v | v <- r']
+                                   unLoc . fieldOccRdrName . unLoc) v | v <- r']
                         (ns, fs) = go remSeen' rs
              L loc (ConDeclH98 { con_name = name }) ->
                 ([L loc (unLoc name)] ++ ns, fs)
diff --git a/compiler/hsSyn/PlaceHolder.hs b/compiler/hsSyn/PlaceHolder.hs
index 0b4711a364..e7a742ba99 100644
--- a/compiler/hsSyn/PlaceHolder.hs
+++ b/compiler/hsSyn/PlaceHolder.hs
@@ -13,6 +13,7 @@ import Outputable
 import Name
 import NameSet
 import RdrName
+import SeName
 import Var
 
 import Data.Data hiding ( Fixity )
@@ -94,3 +95,4 @@ type family NameOrRdrName id where
   NameOrRdrName Id      = Name
   NameOrRdrName Name    = Name
   NameOrRdrName RdrName = RdrName
+  NameOrRdrName SeName  = SeName
diff --git a/compiler/hsSyn/SeName.hs b/compiler/hsSyn/SeName.hs
new file mode 100644
index 0000000000..f8bca59243
--- /dev/null
+++ b/compiler/hsSyn/SeName.hs
@@ -0,0 +1,13 @@
+{-# LANGUAGE GeneralizedNewtypeDeriving #-}
+module SeName (SeName(..), mkSeName) where
+
+import Outputable
+import RdrName
+
+-- TODO: make this smarter, so as to check whether
+-- the name is local or not.
+newtype SeName = SeName RdrName
+  deriving (Outputable, OutputableBndr)
+
+mkSeName :: RdrName -> SeName
+mkSeName = SeName
diff --git a/compiler/iface/BinIface.hs b/compiler/iface/BinIface.hs
index 31b5af0e86..1843bee3f5 100644
--- a/compiler/iface/BinIface.hs
+++ b/compiler/iface/BinIface.hs
@@ -15,7 +15,10 @@ module BinIface (
         getSymtabName,
         getDictFastString,
         CheckHiWay(..),
-        TraceBinIFaceReading(..)
+        TraceBinIFaceReading(..),
+        getWithUserData,
+        putWithUserData
+
     ) where
 
 #include "HsVersions.h"
@@ -134,7 +137,14 @@ readBinIface_ dflags checkHiWay traceBinIFaceReading hi_path ncu = do
     wantedGot "Way" way_descr check_way
     when (checkHiWay == CheckHiWay) $
         errorOnMismatch "mismatched interface file ways" way_descr check_way
+    getWithUserData ncu bh
+
 
+-- | This performs a get action after reading the dictionary and symbol
+-- table. It is necessary to run this before trying to deserialise any
+-- Names or FastStrings.
+getWithUserData :: Binary a => NameCacheUpdater -> BinHandle -> IO a
+getWithUserData ncu bh = do
     -- Read the dictionary
     -- The next word in the file is a pointer to where the dictionary is
     -- (probably at the end of the file)
@@ -179,6 +189,17 @@ writeBinIface dflags hi_path mod_iface = do
     let way_descr = getWayDescr dflags
     put_  bh way_descr
 
+
+    putWithUserData (debugTraceMsg dflags 3) bh mod_iface
+    -- And send the result to the file
+    writeBinMem bh hi_path
+
+-- | Put a piece of data with an initialised `UserData` field. This
+-- is necessary if you want to serialise Names or FastStrings.
+-- It also writes a symbol table and the dictionary.
+-- This segment should be read using `getWithUserData`.
+putWithUserData :: Binary a => (SDoc -> IO ()) -> BinHandle -> a -> IO ()
+putWithUserData log_action bh payload = do
     -- Remember where the dictionary pointer will go
     dict_p_p <- tellBin bh
     -- Placeholder for ptr to dictionary
@@ -187,7 +208,6 @@ writeBinIface dflags hi_path mod_iface = do
     -- Remember where the symbol table pointer will go
     symtab_p_p <- tellBin bh
     put_ bh symtab_p_p
-
     -- Make some intial state
     symtab_next <- newFastMutInt
     writeFastMutInt symtab_next 0
@@ -206,7 +226,7 @@ writeBinIface dflags hi_path mod_iface = do
     bh <- return $ setUserData bh $ newWriteState (putName bin_dict bin_symtab)
                                                   (putName bin_dict bin_symtab)
                                                   (putFastString bin_dict)
-    put_ bh mod_iface
+    put_ bh payload
 
     -- Write the symtab pointer at the front of the file
     symtab_p <- tellBin bh        -- This is where the symtab will start
@@ -217,7 +237,7 @@ writeBinIface dflags hi_path mod_iface = do
     symtab_next <- readFastMutInt symtab_next
     symtab_map  <- readIORef symtab_map
     putSymbolTable bh symtab_next symtab_map
-    debugTraceMsg dflags 3 (text "writeBinIface:" <+> int symtab_next
+    log_action (text "writeBinIface:" <+> int symtab_next
                                 <+> text "Names")
 
     -- NB. write the dictionary after the symbol table, because
@@ -232,11 +252,10 @@ writeBinIface dflags hi_path mod_iface = do
     dict_next <- readFastMutInt dict_next_ref
     dict_map  <- readIORef dict_map_ref
     putDictionary bh dict_next dict_map
-    debugTraceMsg dflags 3 (text "writeBinIface:" <+> int dict_next
+    log_action (text "writeBinIface:" <+> int dict_next
                                 <+> text "dict entries")
 
-    -- And send the result to the file
-    writeBinMem bh hi_path
+
 
 -- | Initial ram buffer to allocate for writing interface files
 initBinMemSize :: Int
diff --git a/compiler/iface/IfaceType.hs b/compiler/iface/IfaceType.hs
index c5a4a3d6db..461282e56c 100644
--- a/compiler/iface/IfaceType.hs
+++ b/compiler/iface/IfaceType.hs
@@ -7,7 +7,7 @@ This module defines interface types and binders
 -}
 
 {-# LANGUAGE CPP, FlexibleInstances, BangPatterns #-}
-{-# LANGUAGE MultiWayIf #-}
+{-# LANGUAGE DeriveDataTypeable, MultiWayIf #-}
     -- FlexibleInstances for Binary (DefMethSpec IfaceType)
 
 module IfaceType (
@@ -67,6 +67,7 @@ import FastString
 import FastStringEnv
 import Util
 
+import Data.Data (Data)
 import Data.Maybe( isJust )
 import Data.List (foldl')
 import qualified Data.Semigroup as Semi
@@ -130,6 +131,7 @@ data IfaceType     -- A kind of universal type, used for types and kinds
        IsPromoted                 -- A bit like IfaceTyCon
        IfaceTcArgs                -- arity = length args
           -- For promoted data cons, the kind args are omitted
+  deriving Data
 
 type IfacePredType = IfaceType
 type IfaceContext = [IfacePredType]
@@ -137,7 +139,7 @@ type IfaceContext = [IfacePredType]
 data IfaceTyLit
   = IfaceNumTyLit Integer
   | IfaceStrTyLit FastString
-  deriving (Eq)
+  deriving (Data, Eq)
 
 type IfaceTyConBinder = TyVarBndr IfaceTvBndr TyConBndrVis
 type IfaceForAllBndr  = TyVarBndr IfaceTvBndr ArgFlag
@@ -152,6 +154,7 @@ data IfaceTcArgs
   | ITC_Vis   IfaceType IfaceTcArgs   -- "Vis" means show when pretty-printing
   | ITC_Invis IfaceKind IfaceTcArgs   -- "Invis" means don't show when pretty-printing
                                       --         except with -fprint-explicit-kinds
+  deriving Data
 
 instance Semi.Semigroup IfaceTcArgs where
   ITC_Nil <> xs           = xs
@@ -168,11 +171,11 @@ instance Monoid IfaceTcArgs where
 -- properly.
 data IfaceTyCon = IfaceTyCon { ifaceTyConName :: IfExtName
                              , ifaceTyConInfo :: IfaceTyConInfo }
-    deriving (Eq)
+    deriving (Data, Eq)
 
 -- | Is a TyCon a promoted data constructor or just a normal type constructor?
 data IsPromoted = IsNotPromoted | IsPromoted
-    deriving (Eq)
+    deriving (Data, Eq)
 
 -- | The various types of TyCons which have special, built-in syntax.
 data IfaceTyConSort = IfaceNormalTyCon          -- ^ a regular tycon
@@ -192,7 +195,7 @@ data IfaceTyConSort = IfaceNormalTyCon          -- ^ a regular tycon
                       -- that is actually being applied to two types
                       -- of the same kind.  This affects pretty-printing
                       -- only: see Note [Equality predicates in IfaceType]
-                    deriving (Eq)
+                    deriving (Data, Eq)
 
 {- Note [Free tyvars in IfaceType]
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@@ -247,7 +250,7 @@ data IfaceTyConInfo   -- Used to guide pretty-printing
                       -- and to disambiguate D from 'D (they share a name)
   = IfaceTyConInfo { ifaceTyConIsPromoted :: IsPromoted
                    , ifaceTyConSort       :: IfaceTyConSort }
-    deriving (Eq)
+    deriving (Data, Eq)
 
 data IfaceCoercion
   = IfaceReflCo       Role IfaceType
@@ -269,12 +272,14 @@ data IfaceCoercion
   | IfaceAxiomRuleCo  IfLclName [IfaceCoercion]
   | IfaceFreeCoVar    CoVar    -- See Note [Free tyvars in IfaceType]
   | IfaceHoleCo       CoVar    -- ^ See Note [Holes in IfaceCoercion]
+  deriving Data
 
 data IfaceUnivCoProv
   = IfaceUnsafeCoerceProv
   | IfacePhantomProv IfaceCoercion
   | IfaceProofIrrelProv IfaceCoercion
   | IfacePluginProv String
+  deriving Data
 
 {- Note [Holes in IfaceCoercion]
 ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
@@ -1488,6 +1493,7 @@ instance Binary IfaceUnivCoProv where
            _ -> panic ("get IfaceUnivCoProv " ++ show tag)
 
 
+{-
 instance Binary (DefMethSpec IfaceType) where
     put_ bh VanillaDM     = putByte bh 0
     put_ bh (GenericDM t) = putByte bh 1 >> put_ bh t
@@ -1496,3 +1502,4 @@ instance Binary (DefMethSpec IfaceType) where
             case h of
               0 -> return VanillaDM
               _ -> do { t <- get bh; return (GenericDM t) }
+-}
diff --git a/compiler/main/DynFlags.hs b/compiler/main/DynFlags.hs
index 5b512a1b71..0cb3f81a17 100644
--- a/compiler/main/DynFlags.hs
+++ b/compiler/main/DynFlags.hs
@@ -838,6 +838,8 @@ data DynFlags = DynFlags {
   hiDir                 :: Maybe String,
   stubDir               :: Maybe String,
   dumpDir               :: Maybe String,
+  saveSplicesDir        :: Maybe String,
+  loadSplicesDir        :: Maybe String,
 
   objectSuf             :: String,
   hcSuf                 :: String,
@@ -1692,6 +1694,8 @@ defaultDynFlags mySettings myLlvmTargets =
         hiDir                   = Nothing,
         stubDir                 = Nothing,
         dumpDir                 = Nothing,
+        saveSplicesDir          = Nothing,
+        loadSplicesDir          = Nothing,
 
         objectSuf               = phaseInputExt StopLn,
         hcSuf                   = phaseInputExt HCc,
@@ -2282,6 +2286,7 @@ getVerbFlags dflags
   | otherwise             = []
 
 setObjectDir, setHiDir, setStubDir, setDumpDir, setOutputDir,
+         setSaveSplicesDir, setLoadSplicesDir,
          setDynObjectSuf, setDynHiSuf,
          setDylibInstallName,
          setObjectSuf, setHiSuf, setHcSuf, parseDynLibLoaderMode,
@@ -2299,6 +2304,8 @@ setStubDir    f d = d { stubDir    = Just f, includePaths = f : includePaths d }
   -- \#included from the .hc file when compiling via C (i.e. unregisterised
   -- builds).
 setDumpDir    f d = d { dumpDir    = Just f}
+setSaveSplicesDir f d = d { saveSplicesDir = Just f}
+setLoadSplicesDir f d = d { loadSplicesDir = Just f}
 setOutputDir  f = setObjectDir f . setHiDir f . setStubDir f . setDumpDir f
 setDylibInstallName  f d = d { dylibInstallName = Just f}
 
@@ -2867,6 +2874,8 @@ dynamic_flags_deps = [
   , make_ord_flag defGhcFlag "tmpdir"            (hasArg setTmpDir)
   , make_ord_flag defGhcFlag "stubdir"           (hasArg setStubDir)
   , make_ord_flag defGhcFlag "dumpdir"           (hasArg setDumpDir)
+  , make_ord_flag defGhcFlag "save-splices"      (hasArg setSaveSplicesDir)
+  , make_ord_flag defGhcFlag "load-splices"      (hasArg setLoadSplicesDir)
   , make_ord_flag defGhcFlag "outputdir"         (hasArg setOutputDir)
   , make_ord_flag defGhcFlag "ddump-file-prefix"
         (hasArg (setDumpPrefixForce . Just))
diff --git a/compiler/main/HscStats.hs b/compiler/main/HscStats.hs
index 48b8eccaca..20bdbf448d 100644
--- a/compiler/main/HscStats.hs
+++ b/compiler/main/HscStats.hs
@@ -4,8 +4,7 @@
 -- (c) The GRASP/AQUA Project, Glasgow University, 1993-1998
 --
 
-{-# LANGUAGE FlexibleContexts #-}
-
+{-# LANGUAGE FlexibleContexts, GADTs #-}
 module HscStats ( ppSourceStats ) where
 
 import GhcPrelude
diff --git a/compiler/prelude/PrimOp.hs-boot b/compiler/prelude/PrimOp.hs-boot
index f10ef44972..6d759bb961 100644
--- a/compiler/prelude/PrimOp.hs-boot
+++ b/compiler/prelude/PrimOp.hs-boot
@@ -1,5 +1,7 @@
 module PrimOp where
 
-import GhcPrelude ()
+import GhcPrelude (Int)
 
 data PrimOp
+primOpTag :: PrimOp -> Int
+allThePrimOps :: [PrimOp]
diff --git a/compiler/rename/RnPat.hs b/compiler/rename/RnPat.hs
index 2846754f11..fdeb5fe4a2 100644
--- a/compiler/rename/RnPat.hs
+++ b/compiler/rename/RnPat.hs
@@ -10,7 +10,7 @@ general, all of these functions return a renamed thing, and a set of
 free variables.
 -}
 
-{-# LANGUAGE CPP, RankNTypes, ScopedTypeVariables #-}
+{-# LANGUAGE CPP, RankNTypes, ScopedTypeVariables, GADTs #-}
 
 module RnPat (-- main entry points
               rnPat, rnPats, rnBindPat, rnPatAndThen,
@@ -794,11 +794,11 @@ rnHsRecUpdFields flds
 getFieldIds :: [LHsRecField GhcRn arg] -> [Name]
 getFieldIds flds = map (unLoc . hsRecFieldSel . unLoc) flds
 
-getFieldLbls :: [LHsRecField id arg] -> [RdrName]
+getFieldLbls :: RdrOrSeName id ~ RdrName => [LHsRecField id arg] -> [RdrName]
 getFieldLbls flds
   = map (unLoc . rdrNameFieldOcc . unLoc . hsRecFieldLbl . unLoc) flds
 
-getFieldUpdLbls :: [LHsRecUpdField id] -> [RdrName]
+getFieldUpdLbls :: RdrOrSeName id ~ RdrName => [LHsRecUpdField id] -> [RdrName]
 getFieldUpdLbls flds = map (rdrNameAmbiguousFieldOcc . unLoc . hsRecFieldLbl . unLoc) flds
 
 needFlagDotDot :: HsRecFieldContext -> SDoc
diff --git a/compiler/typecheck/Inst.hs b/compiler/typecheck/Inst.hs
index 9da96c4cc0..2a935b0a76 100644
--- a/compiler/typecheck/Inst.hs
+++ b/compiler/typecheck/Inst.hs
@@ -7,7 +7,7 @@ The @Inst@ type: dictionaries or method instances
 -}
 
 {-# LANGUAGE CPP, MultiWayIf, TupleSections #-}
-{-# LANGUAGE FlexibleContexts #-}
+{-# LANGUAGE FlexibleContexts, TypeFamilies #-}
 
 module Inst (
        deeplySkolemise,
@@ -575,7 +575,9 @@ newNonTrivialOverloadedLit _ lit _
   = pprPanic "newNonTrivialOverloadedLit" (ppr lit)
 
 ------------
-mkOverLit ::(HasDefaultX p, SourceTextX p) => OverLitVal -> TcM (HsLit p)
+mkOverLit
+  :: (HasDefaultX p, SourceTextX p, LitType p ~ Type)
+  => OverLitVal -> TcM (HsLit p)
 mkOverLit (HsIntegral i)
   = do  { integer_ty <- tcMetaTy integerTyConName
         ; return (HsInteger (setSourceText $ il_text i)
diff --git a/compiler/typecheck/TcAnnotations.hs b/compiler/typecheck/TcAnnotations.hs
index edf696e3c9..a97819ef9c 100644
--- a/compiler/typecheck/TcAnnotations.hs
+++ b/compiler/typecheck/TcAnnotations.hs
@@ -7,6 +7,7 @@
 
 {-# LANGUAGE CPP #-}
 {-# LANGUAGE FlexibleContexts #-}
+{-# LANGUAGE GADTs #-}
 
 module TcAnnotations ( tcAnnotations, annCtxt ) where
 
diff --git a/compiler/typecheck/TcEnv.hs b/compiler/typecheck/TcEnv.hs
index ef3131b922..c0d60b7a6d 100644
--- a/compiler/typecheck/TcEnv.hs
+++ b/compiler/typecheck/TcEnv.hs
@@ -1,6 +1,6 @@
 -- (c) The University of Glasgow 2006
 {-# LANGUAGE CPP, FlexibleInstances #-}
-{-# LANGUAGE FlexibleContexts #-}
+{-# LANGUAGE FlexibleContexts, GADTs #-}
 {-# OPTIONS_GHC -fno-warn-orphans #-}  -- instance MonadThings is necessarily an
                                        -- orphan
 {-# LANGUAGE UndecidableInstances #-} -- Note [Pass sensitive types]
diff --git a/compiler/typecheck/TcHsSyn.hs b/compiler/typecheck/TcHsSyn.hs
index 8d097f52fb..65d725eeca 100644
--- a/compiler/typecheck/TcHsSyn.hs
+++ b/compiler/typecheck/TcHsSyn.hs
@@ -110,7 +110,7 @@ hsPatType (NPlusKPat _ _ _ _ _ ty)    = ty
 hsPatType (CoPat _ _ ty)              = ty
 hsPatType p                           = pprPanic "hsPatType" (ppr p)
 
-hsLitType :: HsLit p -> TcType
+hsLitType :: LitType p ~ TcType => HsLit p -> TcType
 hsLitType (HsChar _ _)       = charTy
 hsLitType (HsCharPrim _ _)   = charPrimTy
 hsLitType (HsString _ _)     = stringTy
diff --git a/compiler/typecheck/TcRnDriver.hs b/compiler/typecheck/TcRnDriver.hs
index 40b5efec84..42745dd2c8 100644
--- a/compiler/typecheck/TcRnDriver.hs
+++ b/compiler/typecheck/TcRnDriver.hs
@@ -44,7 +44,7 @@ module TcRnDriver (
 
 import GhcPrelude
 
-import {-# SOURCE #-} TcSplice ( finishTH )
+import {-# SOURCE #-} TcSplice ( finishTH, writeHsSpliceData )
 import RnSplice ( rnTopSpliceDecls, traceSplice, SpliceInfo(..) )
 import IfaceEnv( externaliseName )
 import TcHsType
@@ -114,6 +114,7 @@ import Avail
 import TyCon
 import SrcLoc
 import HscTypes
+import HsExprBin
 import ListSetOps
 import Outputable
 import ConLike
@@ -136,6 +137,8 @@ import HsDumpAst
 import qualified Data.Set as S
 
 import Control.Monad
+import System.Directory
+import System.FilePath (takeDirectory)
 
 #include "HsVersions.h"
 
@@ -417,6 +420,17 @@ tcRnSrcDecls explicit_mod_hdr decls
         -- Finalizers must run after constraints are simplified, or some types
         -- might not be complete when using reify (see #12777).
       ; (tcg_env, tcl_env) <- setGblEnv tcg_env run_th_modfinalizers
+
+      ; dynflags <- getDynFlags
+      ; whenSet (saveSplicesDir dynflags)
+          (\splicesDir -> do
+              moduleSplicesPath <- getModuleSplicesPath splicesDir <$> getModule
+              hs_splice_data <- readTcRef (tcg_hs_splice_data tcg_env)
+              liftIO $ createDirectoryIfMissing True (takeDirectory moduleSplicesPath)
+              writeHsSpliceData moduleSplicesPath hs_splice_data
+          )
+          (pure ())
+
       ; setEnvs (tcg_env, tcl_env) $ do {
 
       ; finishTH
diff --git a/compiler/typecheck/TcRnMonad.hs b/compiler/typecheck/TcRnMonad.hs
index 184093f066..4a03512d61 100644
--- a/compiler/typecheck/TcRnMonad.hs
+++ b/compiler/typecheck/TcRnMonad.hs
@@ -142,6 +142,7 @@ import IOEnv            -- Re-export all
 import TcEvidence
 
 import HsSyn hiding (LIE)
+import HsExprBin
 import HscTypes
 import Module
 import RdrName
@@ -179,7 +180,7 @@ import Control.Monad
 import Data.Set ( Set )
 import qualified Data.Set as Set
 
-import {-# SOURCE #-} TcSplice ( runRemoteModFinalizers )
+import {-# SOURCE #-} TcSplice ( runRemoteModFinalizers, readHsSpliceData )
 import {-# SOURCE #-} TcEnv    ( tcInitTidyEnv )
 
 import qualified Data.Map as Map
@@ -224,9 +225,16 @@ initTc hsc_env hsc_src keep_rn_syntax mod loc do_this
         th_coreplugins_var <- newIORef [] ;
         th_state_var         <- newIORef Map.empty ;
         th_remote_state_var  <- newIORef Nothing ;
+        dflags <- pure (hsc_dflags hsc_env) ;
+        hs_splice_data <- newIORef =<< whenSet (loadSplicesDir dflags)
+          (\splicesDir -> do
+              if moduleUnitId mod == interactiveUnitId
+                then return emptyHsSpliceData
+                else do let moduleSplicesPath = getModuleSplicesPath splicesDir mod
+                        readHsSpliceData hsc_env moduleSplicesPath
+          )
+          (pure emptyHsSpliceData) ;
         let {
-             dflags = hsc_dflags hsc_env ;
-
              maybe_rn_syntax :: forall a. a -> Maybe a ;
              maybe_rn_syntax empty_val
                 | dopt Opt_D_dump_rn_ast dflags = Just empty_val
@@ -302,7 +310,8 @@ initTc hsc_env hsc_src keep_rn_syntax mod loc do_this
                 tcg_tc_plugins     = [],
                 tcg_top_loc        = loc,
                 tcg_static_wc      = static_wc_var,
-                tcg_complete_matches = []
+                tcg_complete_matches = [],
+                tcg_hs_splice_data = hs_splice_data
              } ;
         } ;
 
diff --git a/compiler/typecheck/TcRnTypes.hs b/compiler/typecheck/TcRnTypes.hs
index e4c781f10d..25bd697f21 100644
--- a/compiler/typecheck/TcRnTypes.hs
+++ b/compiler/typecheck/TcRnTypes.hs
@@ -156,6 +156,7 @@ import TyCoRep  ( CoercionHole(..), coHoleCoVar )
 import Coercion ( Coercion, mkHoleCo )
 import ConLike  ( ConLike(..) )
 import DataCon  ( DataCon, dataConUserType, dataConOrigArgTys )
+import {-# SOURCE #-} HsExprBin
 import PatSyn   ( PatSyn, pprPatSynType )
 import Id       ( idType, idName )
 import FieldLabel ( FieldLabel )
@@ -700,7 +701,20 @@ data TcGblEnv
         tcg_static_wc :: TcRef WantedConstraints,
           -- ^ Wanted constraints of static forms.
         -- See Note [Constraints in static forms].
-        tcg_complete_matches :: [CompleteMatch]
+        tcg_complete_matches :: [CompleteMatch],
+
+        -- ^ Splice evaluation results
+        --
+        -- When @-save-splices@ is passed, we will
+        -- record splice results in this field and write
+        -- them all to an .hs-splice file when we are done
+        -- processing the module.
+        --
+        -- When @-load-splices@ is passed, we will read
+        -- the .hs-splice file before we start processing a
+        -- module (when it exists) and store all its contents
+        -- in this field.
+        tcg_hs_splice_data :: TcRef HsSpliceData
     }
 
 -- NB: topModIdentity, not topModSemantic!
diff --git a/compiler/typecheck/TcSplice.hs b/compiler/typecheck/TcSplice.hs
index 45e18e69fe..e9ee4ec540 100644
--- a/compiler/typecheck/TcSplice.hs
+++ b/compiler/typecheck/TcSplice.hs
@@ -26,6 +26,7 @@ module TcSplice(
      runMetaE, runMetaP, runMetaT, runMetaD, runQuasi,
      tcTopSpliceExpr, lookupThName_maybe,
      defaultRunMeta, runMeta', runRemoteModFinalizers,
+     readHsSpliceData, writeHsSpliceData,
      finishTH
       ) where
 
@@ -34,6 +35,7 @@ module TcSplice(
 import GhcPrelude
 
 import HsSyn
+import HsExprBin
 import Annotations
 import Finder
 import Name
@@ -110,6 +112,9 @@ import Maybes( MaybeErr(..) )
 import DynFlags
 import Panic
 import Lexeme
+import BinIface ( getWithUserData, putWithUserData )
+import IfaceEnv ( NameCacheUpdater(..) )
+import qualified Binary as Bin
 import qualified EnumSet
 
 import qualified Language.Haskell.TH as TH
@@ -130,6 +135,7 @@ import Data.Typeable ( typeOf, Typeable, TypeRep, typeRep )
 import Data.Data (Data)
 import Data.Proxy    ( Proxy (..) )
 import GHC.Exts         ( unsafeCoerce# )
+import System.Directory ( doesFileExist )
 
 {-
 ************************************************************************
@@ -667,12 +673,26 @@ runQResult show_th f runQ expr_span hval
 
 
 -----------------
+
 runMeta :: (MetaHook TcM -> LHsExpr GhcTc -> TcM hs_syn)
+        -> (LHsExpr GhcTc -> TcM hs_syn)
+           -- ^ function to load the result of the given expression from
+           --   an .hs-splice file's data
+        -> (LHsExpr GhcTc -> hs_syn -> TcM ())
+           -- ^ function to "save" the result (hs_syn) of evaluating the given
+           --   LHsExpr
         -> LHsExpr GhcTc
         -> TcM hs_syn
-runMeta unwrap e
-  = do { h <- getHooked runMetaHook defaultRunMeta
-       ; unwrap h e }
+runMeta unwrap loadSpliceFun saveSpliceFun e
+  = do { dflags <- getDynFlags
+       ; whenSet (loadSplicesDir dflags)
+           (\_ -> loadSpliceFun e)
+           (do { h <- getHooked runMetaHook defaultRunMeta
+               ; res <- unwrap h e
+               ; whenSet (saveSplicesDir dflags)
+                   (\_ -> saveSpliceFun e res)
+                   (return ())
+               ; return res }) }
 
 defaultRunMeta :: MetaHook TcM
 defaultRunMeta (MetaE r)
@@ -689,29 +709,110 @@ defaultRunMeta (MetaAW r)
     -- the toAnnotationWrapper function that we slap around the user's code
 
 ----------------
+
+readHsSpliceData :: HscEnv -> FilePath -> IO HsSpliceData
+readHsSpliceData hsc_env hsSpliceFile = do
+  let ncu = NCU (updNameCacheIO hsc_env)
+  exists <- doesFileExist hsSpliceFile
+  if exists
+    then do bh <- Bin.readBinMem hsSpliceFile
+            getWithUserData ncu bh
+    else pure emptyHsSpliceData
+
+writeHsSpliceData :: FilePath -> HsSpliceData -> TcM ()
+writeHsSpliceData hsSpliceFile hsSpliceData =
+  when (nonEmptyHsSpliceData hsSpliceData) $ do
+    dflags <- getDynFlags
+    liftIO $ do
+      bh <- Bin.openBinMem (100 * 1024)
+      --  ^^^ FIXME: how should we compute an approximation of size?
+      putWithUserData (debugTraceMsg dflags 3) bh hsSpliceData
+      Bin.writeBinMem bh hsSpliceFile
+
+-- | Update the splice data from the TcGblEnv using the given
+--   function. Used when -save-splices is passed, to record
+--   the splice results as we evaluate them and dump them
+--   to an .hs-splice file.
+modifyHsSpliceData :: (HsSpliceData -> HsSpliceData) -> TcM ()
+modifyHsSpliceData f = do
+  spliceDataRef <- tcg_hs_splice_data <$> getGblEnv
+  updTcRef spliceDataRef f
+
+-- | Record the result (second argument) of evaluating the expression splice
+--   represented by the first argument.
+addSpliceExprResult :: LHsExpr GhcTc -> LHsExpr GhcPs -> TcM ()
+addSpliceExprResult th@(L l _) resultE = do
+  serialExpr <- handleUnsupported (fmap ppr th) (Just $ ppr resultE)
+            =<< exprPS2SE resultE
+  modifyHsSpliceData $ recordSpliceResult l (SRExpr serialExpr)
+
+-- | Record the result (second argument) of evaluating the declaration splice
+--   represented by the first argument.
+addSpliceDeclsResult :: LHsExpr GhcTc -> [LHsDecl GhcPs] -> TcM ()
+addSpliceDeclsResult th@(L l _) resultDs = do
+  serialDecls <- traverse
+     (declPS2SE >=> handleUnsupported (fmap ppr th) (Just $ ppr resultDs))
+     resultDs
+  modifyHsSpliceData $ recordSpliceResult l (SRDecls serialDecls)
+
+-- | Look up the result of evaluating the splice represented by the first
+--   argument in an .hs-splice file, using the given function to extract
+--   the result in question (when found).
+getSpliceResult :: LHsExpr GhcTc -> (SpliceResult -> TcM a) -> TcM a
+getSpliceResult (L l _) f = do
+  gblEnv <- getGblEnv
+  hs_splice_data <- readTcRef (tcg_hs_splice_data gblEnv)
+  case lookupSpliceResult l hs_splice_data of
+    Nothing -> panic ("Could not find splice result for source span " ++ show l)
+    Just r  -> f r
+
+-- | Look up the result of evaluating an expression splice.
+getSpliceExprResult :: LHsExpr GhcTc -> TcM (LHsExpr GhcPs)
+getSpliceExprResult spliceE = getSpliceResult spliceE $ \res -> case res of
+    SRExpr e  -> exprSE2PS e >>= handleUnsupported (fmap ppr spliceE) Nothing
+    SRDecls _ -> panic ("Expected an expression splice but found a declaration one")
+
+-- | Look up the result of evaluating a declaration splice.
+getSpliceDeclsResult :: LHsExpr GhcTc -> TcM [LHsDecl GhcPs]
+getSpliceDeclsResult spliceE = getSpliceResult spliceE $ \res -> case res of
+    SRExpr _   -> panic ("Expected a declaration splice result but found an expression one")
+    SRDecls ds -> traverse
+      (declSE2PS >=> handleUnsupported (fmap ppr spliceE) Nothing)
+      ds
+
 runMetaAW :: LHsExpr GhcTc         -- Of type AnnotationWrapper
           -> TcM Serialized
 runMetaAW = runMeta metaRequestAW
+  -- We cannot process annotations as they use the same
+  -- mechanism as TH. Instead, we ignore them when
+  -- doing a -save-splices pass, and we pretend we
+  -- read {-# ANN () #-} when doing a -load-splices pass.
+  (\_ -> pure $ toSerialized serializeWithData ())
+  (\_ _ -> pure ())
 
 runMetaE :: LHsExpr GhcTc          -- Of type (Q Exp)
          -> TcM (LHsExpr GhcPs)
-runMetaE = runMeta metaRequestE
+runMetaE = runMeta metaRequestE getSpliceExprResult addSpliceExprResult
 
 runMetaP :: LHsExpr GhcTc          -- Of type (Q Pat)
          -> TcM (LPat GhcPs)
 runMetaP = runMeta metaRequestP
+  (panic "runMetaP doesn't support splice caching (read)")
+  (panic "runMetaP doesn't support splice caching (write)")
 
 runMetaT :: LHsExpr GhcTc          -- Of type (Q Type)
          -> TcM (LHsType GhcPs)
 runMetaT = runMeta metaRequestT
+  (panic "runMetaT doesn't support splice caching (read)")
+  (panic "runMetaT doesn't support splice caching (write)")
 
 runMetaD :: LHsExpr GhcTc          -- Of type Q [Dec]
          -> TcM [LHsDecl GhcPs]
-runMetaD = runMeta metaRequestD
+runMetaD = runMeta metaRequestD getSpliceDeclsResult addSpliceDeclsResult
 
 ---------------
 runMeta' :: Bool                 -- Whether code should be printed in the exception message
-         -> (hs_syn -> SDoc)                                    -- how to print the code
+         -> (hs_syn -> SDoc)     -- how to print the code
          -> (SrcSpan -> ForeignHValue -> TcM (Either MsgDoc hs_syn))        -- How to run x
          -> LHsExpr GhcTc        -- Of type x; typically x = Q TH.Exp, or
                                  --    something like that
@@ -722,7 +823,7 @@ runMeta' show_code ppr_hs run_and_convert expr
                             -- we catch all kinds of splices and annotations.
 
         -- Check that we've had no errors of any sort so far.
-        -- For example, if we found an error in an earlier defn f, but
+        -- For example, if we found an error in an earlier defn f, but
         -- recovered giving it type f :: forall a.a, it'd be very dodgy
         -- to carry ont.  Mind you, the staging restrictions mean we won't
         -- actually run f, but it still seems wrong. And, more concretely,
diff --git a/compiler/typecheck/TcSplice.hs-boot b/compiler/typecheck/TcSplice.hs-boot
index be2c67d887..003948c1fb 100644
--- a/compiler/typecheck/TcSplice.hs-boot
+++ b/compiler/typecheck/TcSplice.hs-boot
@@ -9,6 +9,8 @@ import HsExpr   ( PendingRnSplice )
 import TcRnTypes( TcM , SpliceType )
 import TcType   ( ExpRhoType )
 import Annotations ( Annotation, CoreAnnTarget )
+import HscTypes    ( HscEnv )
+import HsExprBin   ( HsSpliceData )
 import HsExtension ( GhcTcId, GhcRn, GhcPs )
 
 import HsSyn      ( HsSplice, HsBracket, HsExpr, LHsExpr, LHsType, LPat,
@@ -42,3 +44,6 @@ lookupThName_maybe :: TH.Name -> TcM (Maybe Name)
 runQuasi :: TH.Q a -> TcM a
 runRemoteModFinalizers :: ThModFinalizers -> TcM ()
 finishTH :: TcM ()
+
+readHsSpliceData :: HscEnv -> FilePath -> IO HsSpliceData
+writeHsSpliceData :: FilePath -> HsSpliceData -> TcM ()
\ No newline at end of file
diff --git a/compiler/typecheck/TcType.hs-boot b/compiler/typecheck/TcType.hs-boot
index 2bc14735f1..1b014c2d2a 100644
--- a/compiler/typecheck/TcType.hs-boot
+++ b/compiler/typecheck/TcType.hs-boot
@@ -4,5 +4,6 @@ import Outputable( SDoc )
 data MetaDetails
 
 data TcTyVarDetails
+
 pprTcTyVarDetails :: TcTyVarDetails -> SDoc
 vanillaSkolemTv :: TcTyVarDetails
diff --git a/compiler/types/CoAxiom.hs b/compiler/types/CoAxiom.hs
index 5234290fd2..9aef679ab4 100644
--- a/compiler/types/CoAxiom.hs
+++ b/compiler/types/CoAxiom.hs
@@ -39,9 +39,9 @@ import Name
 import Unique
 import Var
 import Util
-import Binary
 import Pair
 import BasicTypes
+import Binary
 import Data.Typeable ( Typeable )
 import SrcLoc
 import qualified Data.Data as Data
@@ -440,15 +440,16 @@ instance Outputable Role where
   ppr = ftext . fsFromRole
 
 instance Binary Role where
-  put_ bh Nominal          = putByte bh 1
-  put_ bh Representational = putByte bh 2
-  put_ bh Phantom          = putByte bh 3
-
-  get bh = do tag <- getByte bh
-              case tag of 1 -> return Nominal
-                          2 -> return Representational
-                          3 -> return Phantom
-                          _ -> panic ("get Role " ++ show tag)
+  put_ bh r = putByte bh $ case r of
+    Nominal          -> 0
+    Representational -> 1
+    Phantom          -> 2
+  get bh = do
+    tag <- getByte bh
+    pure $ case tag of
+      0 -> Nominal
+      1 -> Representational
+      _ -> Phantom
 
 {-
 ************************************************************************
@@ -501,7 +502,6 @@ instance Ord CoAxiomRule where
 instance Outputable CoAxiomRule where
   ppr = ppr . coaxrName
 
-
 -- Type checking of built-in families
 data BuiltInSynFamily = BuiltInSynFamily
   { sfMatchFam      :: [Type] -> Maybe (CoAxiomRule, [Type], Type)
diff --git a/compiler/types/TyCoRep.hs-boot b/compiler/types/TyCoRep.hs-boot
index 8dcbd10744..3d3375bcfc 100644
--- a/compiler/types/TyCoRep.hs-boot
+++ b/compiler/types/TyCoRep.hs-boot
@@ -20,4 +20,3 @@ pprType :: Type -> SDoc
 
 instance Data Type
   -- To support Data instances in CoAxiom
-
diff --git a/compiler/types/TyCon.hs b/compiler/types/TyCon.hs
index cf96a49403..652edd4cf0 100644
--- a/compiler/types/TyCon.hs
+++ b/compiler/types/TyCon.hs
@@ -573,7 +573,6 @@ instance Binary TyConBndrVis where
                   0 -> return AnonTCB
                   _ -> do { vis <- get bh; return (NamedTCB vis) } }
 
-
 {- *********************************************************************
 *                                                                      *
                The TyCon type
diff --git a/compiler/utils/Binary.hs b/compiler/utils/Binary.hs
index c3c8ae3ab7..dc869793e4 100644
--- a/compiler/utils/Binary.hs
+++ b/compiler/utils/Binary.hs
@@ -63,12 +63,16 @@ module Binary
 import GhcPrelude
 
 import {-# SOURCE #-} Name (Name)
+import Bag
 import FastString
 import Panic
+import Unique
 import UniqFM
+import UniqSet
 import FastMutInt
 import Fingerprint
 import BasicTypes
+import {-# SOURCE #-} PrimOp
 import SrcLoc
 
 import Foreign
@@ -76,8 +80,10 @@ import Data.Array
 import Data.ByteString (ByteString)
 import qualified Data.ByteString.Internal as BS
 import qualified Data.ByteString.Unsafe   as BS
+import qualified Data.IntMap              as IM
 import Data.IORef
 import Data.Char                ( ord, chr )
+import Data.List                ( find )
 import Data.Time
 #if MIN_VERSION_base(4,10,0)
 import Type.Reflection
@@ -87,7 +93,7 @@ import GHC.Exts (TYPE, RuntimeRep(..), VecCount(..), VecElem(..))
 #else
 import Data.Typeable
 #endif
-import Control.Monad            ( when )
+import Control.Monad            ( when, replicateM )
 import System.IO as IO
 import System.IO.Unsafe         ( unsafeInterleaveIO )
 import System.IO.Error          ( mkIOError, eofErrorType )
@@ -384,8 +390,8 @@ instance Binary () where
     get  _    = return ()
 
 instance Binary Bool where
-    put_ bh b = putByte bh (fromIntegral (fromEnum b))
-    get  bh   = do x <- getWord8 bh; return $! (toEnum (fromIntegral x))
+    put_ bh b = putByte bh (if b then 1 else 0)
+    get  bh   = do x <- getByte bh; return $! if x == 0 then False else True
 
 instance Binary Char where
     put_  bh c = put_ bh (fromIntegral (ord c) :: Word32)
@@ -1199,3 +1205,130 @@ instance Binary SourceText where
         s <- get bh
         return (SourceText s)
       _ -> panic $ "Binary SourceText:" ++ show h
+
+instance Binary IntegralLit where
+  put_ bh (IL a b c) = put_ bh a >> put_ bh b >> put_ bh c
+  get bh = IL <$> get bh <*> get bh <*> get bh
+
+instance Binary FractionalLit where
+  put_ bh (FL a b c) = put_ bh a >> put_ bh b >> put_ bh c
+  get bh = FL <$> get bh <*> get bh <*> get bh
+
+instance Binary Boxity where
+  put_ bh b = case b of
+    Boxed   -> putByte bh 0
+    Unboxed -> putByte bh 1
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure Boxed
+      _ -> pure Unboxed
+
+-- FIXME: optimise?
+instance (Ix i, Binary i, Binary a) => Binary (Array i a) where
+  put_ bh arr = case bounds arr of
+    (a, b) -> put_ bh a >> put_ bh b >> put_ bh (elems arr)
+  get bh = do
+    bounds <- (,) <$> get bh <*> get bh
+    xs <- replicateM (rangeSize bounds) (get bh)
+    return (listArray bounds xs)
+
+instance Binary Unique where
+  put_ bh u = put_ bh (getKey u)
+  get bh = mkUniqueGrimily <$> get bh
+
+instance Binary ty => Binary (DefMethSpec ty) where
+  put_ bh s
+    = case s of
+        VanillaDM   -> putByte bh 0
+        GenericDM t -> putByte bh 1 >> put_ bh t
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure VanillaDM
+      _ -> GenericDM <$> get bh
+
+instance Binary a => Binary (IM.IntMap a) where
+  put_ bh m = put_ bh (IM.toAscList m)
+  get bh = IM.fromAscList <$> get bh
+
+instance Binary PrimOp where
+  put_ bh primop = put_ bh (primOpTag primop)
+  -- FIXME: inefficient.
+  get bh = do
+    tag <- getTag
+    case find (\p -> primOpTag p == tag) allThePrimOps of
+      Nothing -> error "Binary PrimOp.get: unknown primop tag"
+      Just p  -> pure p
+
+    where getTag :: IO Int
+          getTag = get bh
+
+instance Binary OccInfo where
+  put_ bh i
+    = case i of
+        ManyOccs a          -> putByte bh 0 >> put_ bh a
+        IAmDead             -> putByte bh 1
+        OneOcc a b c d      -> putByte bh 2 >> put_ bh a >> put_ bh b
+                                            >> put_ bh c >> put_ bh d
+        IAmALoopBreaker a b -> putByte bh 3 >> put_ bh a >> put_ bh b
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> ManyOccs <$> get bh
+      1 -> pure IAmDead
+      2 -> OneOcc <$> get bh <*> get bh <*> get bh <*> get bh
+      _ -> IAmALoopBreaker <$> get bh <*> get bh
+
+instance Binary TailCallInfo where
+  put_ bh i
+    = case i of
+        AlwaysTailCalled a -> putByte bh 0 >> put_ bh a
+        NoTailCallInfo     -> putByte bh 1
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> AlwaysTailCalled <$> get bh
+      _ -> pure NoTailCallInfo
+
+instance Binary OneShotInfo where
+  put_ bh i
+    = case i of
+        NoOneShotInfo -> putByte bh 0
+        OneShotLam    -> putByte bh 1
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure NoOneShotInfo
+      _ -> pure OneShotLam
+
+instance Binary LexicalFixity where
+  put_ bh f = case f of
+    Prefix -> putByte bh 0
+    Infix  -> putByte bh 1
+  get bh = do
+    tag <- getByte bh
+    case tag of
+      0 -> pure Prefix
+      _ -> pure Infix
+
+instance Binary ele => Binary (UniqFM ele) where
+  put_ bh ufm = put_ bh (ufmToIntMap ufm)
+  get bh = intMapToUFM <$> get bh
+
+instance Binary a => Binary (UniqSet a) where
+  put_ bh s = put_ bh (getUniqSet s)
+  get bh = unsafeUFMToUniqSet <$> get bh
+
+instance Binary a => Binary (Bag a) where
+  put_ bh b = put_ bh (bagToList b)
+  get bh = listToBag <$> get bh
+
+instance Binary Origin where
+  put_ bh o = putByte bh $ case o of
+    FromSource -> 0
+    Generated  -> 1
+  get bh = getByte bh >>= \n -> case n of
+    0 -> pure FromSource
+    1 -> pure Generated
+    _ -> panic "Binary Origin.get: unknown tag"
diff --git a/compiler/utils/UniqDFM.hs b/compiler/utils/UniqDFM.hs
index 715600ddb8..90389da0d1 100644
--- a/compiler/utils/UniqDFM.hs
+++ b/compiler/utils/UniqDFM.hs
@@ -62,6 +62,7 @@ module UniqDFM (
 import GhcPrelude
 
 import Unique           ( Uniquable(..), Unique, getKey )
+import Binary
 import Outputable
 
 import qualified Data.IntMap as M
@@ -128,6 +129,10 @@ instance Eq val => Eq (TaggedVal val) where
 instance Functor TaggedVal where
   fmap f (TaggedVal val i) = TaggedVal (f val) i
 
+instance Binary val => Binary (TaggedVal val) where
+  put_ bh (TaggedVal a b) = put_ bh a >> put_ bh b
+  get bh = TaggedVal <$> get bh <*> get bh
+
 -- | Type of unique deterministic finite maps
 data UniqDFM ele =
   UDFM
@@ -139,6 +144,10 @@ data UniqDFM ele =
                                 -- time. See Note [Overflow on plusUDFM]
   deriving (Data, Functor)
 
+instance Binary ele => Binary (UniqDFM ele) where
+  put_ bh (UDFM a b) = put_ bh a >> put_ bh b
+  get bh = UDFM <$> get bh <*> get bh
+
 emptyUDFM :: UniqDFM elt
 emptyUDFM = UDFM M.empty 0
 
diff --git a/compiler/utils/UniqFM.hs b/compiler/utils/UniqFM.hs
index f0cc197b71..2f874c04e5 100644
--- a/compiler/utils/UniqFM.hs
+++ b/compiler/utils/UniqFM.hs
@@ -67,7 +67,7 @@ module UniqFM (
         lookupWithDefaultUFM, lookupWithDefaultUFM_Directly,
         nonDetEltsUFM, eltsUFM, nonDetKeysUFM,
         ufmToSet_Directly,
-        nonDetUFMToList, ufmToIntMap,
+        nonDetUFMToList, ufmToIntMap, intMapToUFM,
         pprUniqFM, pprUFM, pprUFMWithKeys, pluralUFM
     ) where
 
@@ -344,6 +344,9 @@ nonDetUFMToList (UFM m) = map (\(k, v) -> (getUnique k, v)) $ M.toList m
 ufmToIntMap :: UniqFM elt -> M.IntMap elt
 ufmToIntMap (UFM m) = m
 
+intMapToUFM :: M.IntMap elt -> UniqFM elt
+intMapToUFM = UFM
+
 -- Determines whether two 'UniqFm's contain the same keys.
 equalKeysUFM :: UniqFM a -> UniqFM b -> Bool
 #if MIN_VERSION_containers(0,5,9)
